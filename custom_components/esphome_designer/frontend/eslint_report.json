[{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\battery_icon\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\calendar\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\calendar\\yaml_export.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'pages' is defined but never used. Allowed unused args must match /^_/u.","line":1,"column":41,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":46,"suggestions":[{"messageId":"removeVar","data":{"varName":"pages"},"fix":{"range":[38,45],"text":""},"desc":"Remove unused variable 'pages'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'deviceModel' is defined but never used. Allowed unused args must match /^_/u.","line":1,"column":48,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":59,"suggestions":[{"messageId":"removeVar","data":{"varName":"deviceModel"},"fix":{"range":[45,58],"text":""},"desc":"Remove unused variable 'deviceModel'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export function generateSnippet(widget, pages, deviceModel) {\n    const id = widget.id;\n    const x = widget.x;\n    const y = widget.y;\n    const w = widget.w;\n    const h = widget.h;\n\n    // We need to fetch data from HA, so we assume the user has set up the python script.\n    // The reference project uses a text_sensor to pull the JSON string.\n\n    // Check if we need to add the common components (only once per device ideally, but simple \"if not exists\" checks in ESPHome help, \n    // or we rely on the main generator to handle common \"time\" etc. \n    // However, for this specific widget, we need specific sensors.)\n\n    // We will namespace the sensors with the widget ID or a common name if we assume one calendar. \n    // Let's use the widget ID to allow multiple (though heavy).\n\n    // Note: The reference implementation relies on `id(calendar_json).state`.\n\n    const calendarDataEntity = widget.properties.entity_id || \"sensor.esp_calendar_data\";\n\n    // Instructions for the user\n    const userInstructions = `\n# --------------------------------------------------------------------------------------\n# [Calendar Widget Setup Instructions]\n# 1. Copy 'esp_calendar_data_conversion.py' to your HA 'python_scripts/' folder.\n# 2. Add the following to your HA configuration.yaml:\n#\n# template:\n#   - trigger:\n#       - platform: time_pattern\n#         minutes: \"*\"\n#     action:\n#       - service: calendar.get_events\n#         data:\n#           duration:\n#             days: 28\n#         target:\n#           entity_id:\n#             - calendar.YOUR_CALENDAR_HERE\n#         response_variable: calendar_response\n#       - service: python_script.esp_calendar_data_conversion\n#         data:\n#           calendar: \"{{ calendar_response }}\"\n#           now: \"{{ now().date() }}\"\n#         response_variable: calendar_converted\n#     sensor:\n#       - name: ESP Calendar Data\n#         state: \"OK\"\n#         attributes:\n#           todays_day_name: >\n#             {{ ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'][now().weekday()] }}\n#           todays_date_month_year: >\n#             {% set months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"] %}\n#             {{ months[now().month-1] }} {{  now().strftime('%Y') }}\n#           entries: \"{{ calendar_converted.entries }}\"\n# --------------------------------------------------------------------------------------\n`;\n\n    // Sensors needed by the lambda\n    const sensors = `\ntext_sensor:\n  - platform: homeassistant\n    entity_id: ${calendarDataEntity}\n    attribute: entries\n    id: calendar_json_${id}\n    internal: true\n  - platform: homeassistant\n    entity_id: ${calendarDataEntity}\n    attribute: todays_day_name\n    id: todays_day_name_${id}\n    internal: true\n  - platform: homeassistant\n    entity_id: ${calendarDataEntity}\n    attribute: todays_date_month_year\n    id: todays_date_month_year_${id}\n    internal: true\n`;\n\n    // Common includes for the lambda\n    // We need to inline the C++ helper functions since we can't easily distribute .h files.\n    // Logic adapted from reference 'calendar_utilities.h' and 'text_utilities.h'\n\n    const lambdaHelpers = `\n    // --- Calendar Helpers (Inlined) ---\n    auto is_leap_year = [](int year) -> int {\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n    };\n\n    auto get_calendar_matrix = [&](int year, int month, char cal[7][7][3]) {\n        int days_in_month[] = {31, 28 + is_leap_year(year), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        int num_days = days_in_month[month - 1];\n        \n        if (month < 3) {\n            month = month + 12;\n            year = year - 1;\n        }\n        int day_of_week = (1 + (13 * (month + 1)) / 5 + year + year / 4 - year / 100 + year / 400) % 7;\n        day_of_week = (day_of_week + 5) % 7;\n        \n        const char *weekdays[] = {\"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"};\n        for (int i = 0; i < 7; i++) {\n            strcpy(cal[0][i], weekdays[i]);\n        }\n        \n        int current_day = 1 - day_of_week;\n        for (int week_num = 1; week_num < 7; week_num++) {\n            for (int day_num = 0; day_num < 7; day_num++) {\n                if (current_day > 0 && current_day <= num_days) {\n                    sprintf(cal[week_num][day_num], \"%d\", current_day);\n                } else {\n                    strcpy(cal[week_num][day_num], \"\");\n                }\n                current_day++;\n            }\n        }\n    };\n    \n    auto extract_time = [](const char* datetime) -> std::string {\n        std::string datetimeStr(datetime);\n        size_t pos = datetimeStr.find('T');\n        if (pos != std::string::npos && pos + 3 < datetimeStr.size()) {\n            return datetimeStr.substr(pos + 1, 5);\n        }\n        return \"\";\n    };\n    \n    // --- End Helpers ---\n    `;\n\n    // Main drawing lambda\n    const lambda = `\n      // --- Calendar Widget (${id}) ---\n      // Bounds: x=${x}, y=${y}, w=${w}, h=${h}\n      {\n          ${lambdaHelpers}\n          \n          auto time = id(current_time_id).now(); // Assumes current_time_id is available globally in the main generator or we need to find it.\n          // Fallback if global id not known:\n          // auto time = id(homeassistant_time).now(); \n          \n          // Background\n          it.filled_rectangle(${x}, ${y}, ${w}, ${h}, id(color_white)); // Assuming color_white/black exists\n          \n          // Header\n          // We need font IDs. Assuming standard ones extracted from properties or globals.\n          // For now using specific ones from the reference or approximating.\n          \n          /* \n             NOTE: This lambda is quite complex and relies on specific fonts being available.\n             The generator should ideally ensure these fonts are added to 'font:' section.\n             We will assume standard Roboto fonts are available.\n          */\n          \n          auto color_content = id(color_black);\n          auto color_background = id(color_white);\n          \n          // Calculate layout relative to ${x}, ${y}\n          \n          int cx = ${x} + (${w} / 2);\n          \n          // Date\n          it.printf(cx, ${y} + 0, id(font_roboto_100), color_content, TextAlign::TOP_CENTER, \"%d\", time.day_of_month);\n          it.printf(cx, ${y} + 70, id(font_roboto_24), color_content, TextAlign::TOP_CENTER, \"%s\", id(todays_day_name_${id}).state.c_str());\n          it.printf(cx, ${y} + 92, id(font_roboto_14), color_content, TextAlign::TOP_CENTER, \"%s\", id(todays_date_month_year_${id}).state.c_str());\n          \n          // Calendar Grid\n          int calendar_y_pos = ${y} + 115;\n          \n          // 2. Mock-ish Calendar Rendering for ESPHome (simplified from reference)\n          char cal[7][7][3];\n          get_calendar_matrix(time.year, time.month, cal);\n          \n          int cell_width = (${w} - 40) / 7;\n          int cell_height = 17;\n          int start_x = ${x} + 20;\n          \n          for (int i = 0; i < 7; i++) {\n              for (int j = 0; j < 7; j++) {\n                  int px = start_x + (j * cell_width) + (cell_width / 2);\n                  int py = calendar_y_pos + (i * cell_height);\n                  \n                  if (i == 0) {\n                      it.printf(px, py, id(font_roboto_14), color_content, TextAlign::TOP_CENTER, \"%s\", cal[i][j]);\n                  } else {\n                      // Day Num\n                      if (atoi(cal[i][j]) == time.day_of_month) {\n                           it.filled_circle(px, py + 12, 10, color_content);\n                           it.printf(px, py + 5, id(font_roboto_14), color_background, TextAlign::TOP_CENTER, \"%s\", cal[i][j]);\n                      } else {\n                           it.printf(px, py + 5, id(font_roboto_14), color_content, TextAlign::TOP_CENTER, \"%s\", cal[i][j]);\n                      }\n                  }\n              }\n          }\n          it.line(start_x, calendar_y_pos + cell_height, ${x} + ${w} - 20, calendar_y_pos + cell_height, color_content);\n          \n          // 3. Events List from JSON\n          // Requires built-in JSON support in ESPHome (json component)\n          // Data source: id(calendar_json_${id}).state\n          \n           // Robust Manual Parsing for Mixed Types (Array/Object)\n           ESP_LOGD(\"calendar\", \"Raw JSON: %s\", id(calendar_json_${id}).state.c_str());\n           if (id(calendar_json_${id}).state.length() > 5 && id(calendar_json_${id}).state != \"unknown\") {\n              StaticJsonDocument<2048> doc;\n              DeserializationError error = deserializeJson(doc, id(calendar_json_${id}).state);\n\n              if (!error) {\n                  JsonVariant root = doc.as<JsonVariant>();\n                  JsonArray days;\n\n                  if (root.is<JsonObject>() && root[\"days\"].is<JsonArray>()) {\n                      days = root[\"days\"];\n                  } else if (root.is<JsonArray>()) {\n                      days = root;\n                  } else {\n                      ESP_LOGW(\"calendar\", \"Invalid JSON structure: neither object with 'days' nor array\");\n                      return;\n                  }\n\n                  if (days.isNull() || days.size() == 0) {\n                       ESP_LOGD(\"calendar\", \"No days found in JSON\");\n                       return; \n                  }\n                  ESP_LOGD(\"calendar\", \"Processing %d days\", days.size());\n\n                  int y_cursor = calendar_y_pos + (7 * cell_height) + 10;\n                  int max_y = ${y} + ${h} - 5;\n\n                  // Safety: Ensure we have enough space for at least one event\n                  if (y_cursor >= max_y) { ESP_LOGW(\"calendar\", \"Widget too small for events\"); return; }\n\n                  it.filled_rectangle(${x} + 20, y_cursor - 5, ${w} - 40, 2, color_content);\n\n                  for (JsonVariant dayEntry : days) {\n                      if (y_cursor > max_y) break;\n                      int currentDayNum = dayEntry[\"day\"].as<int>();\n\n                      auto draw_row = [&](JsonVariant event, bool is_all_day) {\n                          if (y_cursor > max_y) return;\n                          const char* summary = event[\"summary\"] | \"No Title\";\n                          const char* start = event[\"start\"] | \"\";\n\n                          it.printf(${x} + 20, y_cursor, id(font_event_day), color_content, TextAlign::TOP_LEFT, \"%d\", currentDayNum);\n                          it.printf(${x} + 60, y_cursor + 4, id(font_event), color_content, TextAlign::TOP_LEFT, \"%.25s\", summary);\n\n                          if (is_all_day) {\n                              it.printf(${x} + ${w} - 20, y_cursor + 4, id(font_event), color_content, TextAlign::TOP_RIGHT, \"All Day\");\n                          } else {\n                              std::string timeStr = extract_time(start);\n                              it.printf(${x} + ${w} - 20, y_cursor + 4, id(font_event), color_content, TextAlign::TOP_RIGHT, \"%s\", timeStr.c_str());\n                          }\n                          y_cursor += 25;\n                      };\n\n                      if (dayEntry[\"all_day\"].is<JsonArray>()) {\n                          for (JsonVariant event : dayEntry[\"all_day\"].as<JsonArray>()) {\n                              draw_row(event, true);\n                              if (y_cursor > max_y) break;\n                          }\n                      }\n                      if (dayEntry[\"other\"].is<JsonArray>()) {\n                          for (JsonVariant event : dayEntry[\"other\"].as<JsonArray>()) {\n                              draw_row(event, false);\n                              if (y_cursor > max_y) break;\n                          }\n                      }\n                  }\n              } else {\n                   ESP_LOGW(\"calendar\", \"JSON Parse Error: %s\", error.c_str());\n              }\n           }\n      }\n    `;\n\n    return {\n        sensors: sensors,\n        lambda: lambda,\n        instructions: userInstructions\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\datetime\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\graph\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'exportLVGL' is assigned a value but never used.","line":91,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":17,"suggestions":[{"messageId":"removeVar","data":{"varName":"exportLVGL"},"fix":{"range":[3497,4228],"text":""},"desc":"Remove unused variable 'exportLVGL'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Graph Plugin\r\n */\r\nimport { drawInternalGrid, generateMockData, drawSmartAxisLabels } from '../../js/utils/graph_helpers.js';\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const entityId = widget.entity_id || \"\";\r\n    const borderEnabled = props.border !== false;\r\n    const color = props.color || \"black\";\r\n    const colorStyle = getColorStyle(color);\r\n\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.backgroundColor = \"#ffffff\";\r\n    el.style.overflow = \"hidden\";\r\n\r\n    if (borderEnabled) {\r\n        el.style.border = \"2px solid \" + colorStyle;\r\n    }\r\n\r\n    const svgNS = \"http://www.w3.org/2000/svg\";\r\n    const svg = document.createElementNS(svgNS, \"svg\");\r\n    svg.setAttribute(\"width\", \"100%\");\r\n    svg.setAttribute(\"height\", \"100%\");\r\n    svg.setAttribute(\"viewBox\", `0 0 ${widget.width} ${widget.height}`);\r\n    svg.style.display = \"block\";\r\n\r\n    drawInternalGrid(svg, widget.width, widget.height, props.x_grid, props.y_grid);\r\n\r\n    const minVal = parseFloat(props.min_value) || 0;\r\n    const maxVal = parseFloat(props.max_value) || 100;\r\n    const points = generateMockData(widget.width, widget.height, minVal, maxVal);\r\n\r\n    const polyline = document.createElementNS(svgNS, \"polyline\");\r\n    const pointsStr = points.map(p => `${p.x},${p.y}`).join(\" \");\r\n    polyline.setAttribute(\"points\", pointsStr);\r\n    polyline.setAttribute(\"fill\", \"none\");\r\n    polyline.setAttribute(\"stroke\", colorStyle);\r\n    const thickness = parseInt(props.line_thickness || 3, 10);\r\n    polyline.setAttribute(\"stroke-width\", thickness);\r\n    polyline.setAttribute(\"stroke-linejoin\", \"round\");\r\n\r\n    const lineType = props.line_type || \"SOLID\";\r\n    if (lineType === \"DASHED\") {\r\n        polyline.setAttribute(\"stroke-dasharray\", \"5,5\");\r\n    } else if (lineType === \"DOTTED\") {\r\n        polyline.setAttribute(\"stroke-dasharray\", \"2,2\");\r\n    }\r\n\r\n    svg.appendChild(polyline);\r\n    el.appendChild(svg);\r\n\r\n    const widgetId = widget.id;\r\n    setTimeout(() => {\r\n        const canvas = document.getElementById(\"canvas\");\r\n        const widgetStillExists = canvas && canvas.querySelector(`[data-id=\"${widgetId}\"]`);\r\n        if (canvas && widgetStillExists) {\r\n            drawSmartAxisLabels(canvas, widget.x, widget.y, widget.width, widget.height, minVal, maxVal, props.duration);\r\n        }\r\n    }, 0);\r\n\r\n    if (widget.title) {\r\n        const label = document.createElement(\"div\");\r\n        label.style.position = \"absolute\";\r\n        label.style.top = \"2px\";\r\n        label.style.left = \"50%\";\r\n        label.style.transform = \"translateX(-50%)\";\r\n        label.style.fontSize = \"10px\";\r\n        label.style.color = colorStyle;\r\n        label.style.backgroundColor = \"rgba(255,255,255,0.7)\";\r\n        label.style.padding = \"0 4px\";\r\n        label.style.borderRadius = \"2px\";\r\n        label.style.whiteSpace = \"nowrap\";\r\n        label.textContent = widget.title;\r\n        el.appendChild(label);\r\n    } else if (!entityId) {\r\n        const label = document.createElement(\"div\");\r\n        label.style.position = \"absolute\";\r\n        label.style.top = \"50%\";\r\n        label.style.left = \"50%\";\r\n        label.style.transform = \"translate(-50%, -50%)\";\r\n        label.style.fontSize = \"10px\";\r\n        label.style.color = \"#999\";\r\n        label.style.backgroundColor = \"rgba(255,255,255,0.8)\";\r\n        label.style.padding = \"2px 6px\";\r\n        label.textContent = \"graph (No Entity)\";\r\n        el.appendChild(label);\r\n    }\r\n};\r\n\r\nconst exportLVGL = (w, { common, convertColor }) => {\r\n    const p = w.props || {};\r\n    const entityId = (w.entity_id || \"\").replace(/[^a-zA-Z0-9_]/g, \"_\");\r\n    return {\r\n        chart: {\r\n            ...common,\r\n            type: \"LINE\",\r\n            duration: p.duration || \"1h\",\r\n            bg_color: convertColor(p.bg_color || \"white\"),\r\n            traces: [\r\n                {\r\n                    sensor: entityId,\r\n                    color: convertColor(p.color || \"black\"),\r\n                    thickness: p.line_thickness || 2,\r\n                    line_type: p.line_type || \"SOLID\"\r\n                }\r\n            ],\r\n            y_min: p.min_value || 0,\r\n            y_max: p.max_value || 100\r\n        }\r\n    };\r\n};\r\n\r\nconst exportDoc = (w, context) => {\r\n    const {\r\n        lines, addFont, getColorConst, addDitherMask, getCondProps, getConditionCheck, isEpaper, sanitize\r\n    } = context;\r\n\r\n    const p = w.props || {};\r\n    const entityId = (w.entity_id || \"\").trim();\r\n    const title = sanitize(w.title || \"\");\r\n    const duration = p.duration || \"1h\";\r\n    const borderEnabled = p.border !== false;\r\n    const colorProp = p.color || \"black\";\r\n    const color = getColorConst(colorProp);\r\n    const lineType = p.line_type || \"SOLID\";\r\n    const lineThickness = parseInt(p.line_thickness || 3, 10);\r\n    const continuous = !!p.continuous;\r\n    const minValue = p.min_value || \"\";\r\n    const maxValue = p.max_value || \"\";\r\n    const minRange = p.min_range || \"\";\r\n    const maxRange = p.max_range || \"\";\r\n\r\n    const safeId = `graph_${w.id}`.replace(/-/g, \"_\");\r\n    const fontId = addFont(\"Roboto\", 400, 12);\r\n\r\n    const gridEnabled = p.grid !== false;\r\n    let xGrid = p.x_grid || \"\";\r\n    let yGrid = p.y_grid || \"\";\r\n\r\n    if (gridEnabled) {\r\n        if (!xGrid) {\r\n            const durationMatch = duration.match(/^(\\d+(?:\\.\\d+)?)(min|h|d)$/);\r\n            if (durationMatch) {\r\n                const val = parseFloat(durationMatch[1]);\r\n                const unit = durationMatch[2];\r\n                let gridVal = val / 4;\r\n                if (unit === \"h\") xGrid = gridVal >= 1 ? `${Math.round(gridVal)}h` : `${Math.round(gridVal * 60)}min`;\r\n                else if (unit === \"min\") xGrid = `${Math.round(gridVal)}min`;\r\n                else if (unit === \"d\") xGrid = `${Math.round(gridVal * 24)}h`;\r\n            } else {\r\n                xGrid = \"1h\";\r\n            }\r\n        }\r\n        if (!yGrid) {\r\n            const minVal = parseFloat(minValue) || 0;\r\n            const maxVal = parseFloat(maxValue) || 100;\r\n            const range = maxVal - minVal;\r\n            const step = range / 4;\r\n            const niceStep = Math.pow(10, Math.floor(Math.log10(step)));\r\n            const normalized = step / niceStep;\r\n            let yGridVal = normalized <= 1 ? niceStep : normalized <= 2 ? 2 * niceStep : normalized <= 5 ? 5 * niceStep : 10 * niceStep;\r\n            yGrid = String(yGridVal);\r\n        }\r\n    }\r\n\r\n    lines.push(`        // widget:graph id:${w.id} type:graph x:${w.x} y:${w.y} w:${w.width} h:${w.height} title:\"${title}\" entity:${entityId} local:${!!p.is_local_sensor} duration:${duration} border:${borderEnabled} color:${colorProp} x_grid:${xGrid} y_grid:${yGrid} line_type:${lineType} line_thickness:${lineThickness} continuous:${continuous} min_value:${minValue} max_value:${maxValue} min_range:${minRange} max_range:${maxRange} ${getCondProps(w)}`);\r\n\r\n    const cond = getConditionCheck(w);\r\n    if (cond) lines.push(`        ${cond}`);\r\n\r\n    if (entityId) {\r\n        lines.push(`        it.graph(${w.x}, ${w.y}, id(${safeId}));`);\r\n\r\n        if (borderEnabled) {\r\n            lines.push(`        for (int i = 0; i < ${lineThickness}; i++) {`);\r\n            lines.push(`          it.rectangle(${w.x} + i, ${w.y} + i, ${w.width} - 2 * i, ${w.height} - 2 * i, ${color});`);\r\n            lines.push(`        }`);\r\n            addDitherMask(lines, colorProp, isEpaper, w.x, w.y, w.width, w.height);\r\n        }\r\n\r\n        if (yGrid) {\r\n            const ySteps = 4;\r\n            for (let i = 1; i < ySteps; i++) {\r\n                const yOffset = Math.round(w.height * (i / ySteps));\r\n                lines.push(`        for (int i = 0; i < ${w.width}; i += 4) {`);\r\n                lines.push(`          it.draw_pixel_at(${w.x} + i, ${w.y + yOffset}, ${color});`);\r\n                lines.push(`        }`);\r\n            }\r\n        }\r\n\r\n        if (xGrid) {\r\n            const xSteps = 4;\r\n            for (let i = 1; i < xSteps; i++) {\r\n                const xOffset = Math.round(w.width * (i / xSteps));\r\n                lines.push(`        for (int i = 0; i < ${w.height}; i += 4) {`);\r\n                lines.push(`          it.draw_pixel_at(${w.x + xOffset}, ${w.y} + i, ${color});`);\r\n                lines.push(`        }`);\r\n            }\r\n        }\r\n\r\n        if (title) {\r\n            lines.push(`        it.printf(${w.x}+4, ${w.y}+2, id(${fontId}), ${color}, TextAlign::TOP_LEFT, \"${title}\");`);\r\n        }\r\n\r\n        const minY = parseFloat(minValue) || 0;\r\n        const maxY = parseFloat(maxValue) || 100;\r\n        const yRange = maxY - minY;\r\n        const ySteps = 4;\r\n        for (let i = 0; i <= ySteps; i++) {\r\n            const ratio = i / ySteps;\r\n            const val = minY + (yRange * ratio);\r\n            const yOffset = Math.round(w.height * (1 - ratio));\r\n            const fmt = yRange >= 10 ? \"%.0f\" : \"%.1f\";\r\n            lines.push(`        it.printf(${w.x} - 4, ${w.y} + ${yOffset} - 6, id(${fontId}), ${color}, TextAlign::TOP_RIGHT, \"${fmt}\", (float)${val});`);\r\n        }\r\n\r\n        let durationSec = 3600;\r\n        const durMatch = duration.match(/^(\\d+)([a-z]+)$/i);\r\n        if (durMatch) {\r\n            const v = parseInt(durMatch[1], 10);\r\n            const u = durMatch[2].toLowerCase();\r\n            if (u.startsWith(\"s\")) durationSec = v;\r\n            else if (u.startsWith(\"m\")) durationSec = v * 60;\r\n            else if (u.startsWith(\"h\")) durationSec = v * 3600;\r\n            else if (u.startsWith(\"d\")) durationSec = v * 86400;\r\n        }\r\n\r\n        const xLabelSteps = 2;\r\n        for (let i = 0; i <= xLabelSteps; i++) {\r\n            const ratio = i / xLabelSteps;\r\n            const xOffset = Math.round(w.width * ratio);\r\n            let align = \"TextAlign::TOP_CENTER\";\r\n            if (i === 0) align = \"TextAlign::TOP_LEFT\";\r\n            if (i === xLabelSteps) align = \"TextAlign::TOP_RIGHT\";\r\n\r\n            let labelText = i === xLabelSteps ? \"Now\" : \"\";\r\n            if (i !== xLabelSteps) {\r\n                const timeAgo = durationSec * (1 - ratio);\r\n                if (timeAgo >= 3600) labelText = `-${(timeAgo / 3600).toFixed(1)}h`;\r\n                else if (timeAgo >= 60) labelText = `-${(timeAgo / 60).toFixed(0)}m`;\r\n                else labelText = `-${timeAgo.toFixed(0)}s`;\r\n            }\r\n            lines.push(`        it.printf(${w.x} + ${xOffset}, ${w.y} + ${w.height} + 2, id(${fontId}), ${color}, ${align}, \"${labelText}\");`);\r\n        }\r\n    } else {\r\n        lines.push(`        it.printf(${w.x}+5, ${w.y}+5, id(${fontId}), ${color}, TextAlign::TOP_LEFT, \"Graph (no entity)\");`);\r\n    }\r\n\r\n    if (cond) lines.push(`        }`);\r\n};\r\n\r\nconst onExportComponents = (context) => {\r\n    const { lines, widgets } = context;\r\n    const graphWidgets = widgets.filter(w => w.type === 'graph');\r\n\r\n    if (graphWidgets.length > 0) {\r\n        lines.push(\"graph:\");\r\n        graphWidgets.forEach(w => {\r\n            const p = w.props || {};\r\n            const safeId = `graph_${w.id}`.replace(/-/g, \"_\");\r\n            const duration = p.duration || \"1h\";\r\n            const width = parseInt(w.width, 10);\r\n            const height = parseInt(w.height, 10);\r\n            const maxRange = p.max_range ? parseFloat(p.max_range) : null;\r\n            const minRange = p.min_range ? parseFloat(p.min_range) : null;\r\n\r\n            const gridEnabled = p.grid !== false;\r\n            let xGrid = p.x_grid || \"\";\r\n            let yGrid = p.y_grid || \"\";\r\n\r\n            if (gridEnabled) {\r\n                if (!xGrid) {\r\n                    const durationMatch = duration.match(/^(\\d+(?:\\.\\d+)?)(min|h|d)$/);\r\n                    if (durationMatch) {\r\n                        const val = parseFloat(durationMatch[1]);\r\n                        const unit = durationMatch[2];\r\n                        let gridVal = val / 4;\r\n                        if (unit === \"h\") xGrid = gridVal >= 1 ? `${Math.round(gridVal)}h` : `${Math.round(gridVal * 60)}min`;\r\n                        else if (unit === \"min\") xGrid = `${Math.round(gridVal)}min`;\r\n                        else if (unit === \"d\") xGrid = `${Math.round(gridVal * 24)}h`;\r\n                    } else xGrid = \"1h\";\r\n                }\r\n                if (!yGrid) {\r\n                    const minVal = parseFloat(p.min_value) || 0;\r\n                    const maxVal = parseFloat(p.max_value) || 100;\r\n                    const range = maxVal - minVal;\r\n                    const step = range / 4;\r\n                    const niceStep = Math.pow(10, Math.floor(Math.log10(step)));\r\n                    const normalized = step / niceStep;\r\n                    let yGridVal = normalized <= 1 ? niceStep : normalized <= 2 ? 2 * niceStep : normalized <= 5 ? 5 * niceStep : 10 * niceStep;\r\n                    yGrid = String(yGridVal);\r\n                }\r\n            }\r\n\r\n            const entityId = (w.entity_id || \"\").trim();\r\n            const localSensorId = entityId.replace(/[^a-zA-Z0-9_]/g, \"_\") || \"none\";\r\n            const lineType = (p.line_type || \"SOLID\").toUpperCase();\r\n            const lineThickness = parseInt(p.line_thickness || 3, 10);\r\n            const border = p.border !== false;\r\n            const continuous = !!p.continuous;\r\n\r\n            lines.push(`  - id: ${safeId}`);\r\n            lines.push(`    duration: ${duration}`);\r\n            lines.push(`    width: ${width}`);\r\n            lines.push(`    height: ${height}`);\r\n            lines.push(`    border: ${border}`);\r\n            if (gridEnabled && xGrid) lines.push(`    x_grid: ${xGrid}`);\r\n            if (gridEnabled && yGrid) lines.push(`    y_grid: ${yGrid}`);\r\n            lines.push(`    traces:`);\r\n            lines.push(`      - sensor: ${localSensorId}`);\r\n            lines.push(`        line_thickness: ${lineThickness}`);\r\n            if (lineType !== \"SOLID\") lines.push(`        line_type: ${lineType}`);\r\n            if (continuous) lines.push(`        continuous: true`);\r\n\r\n            if (p.min_value !== undefined && p.min_value !== null && String(p.min_value).trim() !== \"\") lines.push(`    min_value: ${p.min_value}`);\r\n            if (p.max_value !== undefined && p.max_value !== null && String(p.max_value).trim() !== \"\") lines.push(`    max_value: ${p.max_value}`);\r\n            if (maxRange !== null) lines.push(`    max_range: ${maxRange}`);\r\n            if (minRange !== null) lines.push(`    min_range: ${minRange}`);\r\n        });\r\n        lines.push(\"\");\r\n    }\r\n};\r\n\r\nexport default {\r\n    id: \"graph\",\r\n    name: \"Graph / Chart\",\r\n    category: \"Advanced\",\r\n    defaults: {\r\n        duration: \"1h\",\r\n        border: true,\r\n        grid: true,\r\n        color: \"black\",\r\n        title: \"\",\r\n        x_grid: \"\",\r\n        y_grid: \"\",\r\n        line_thickness: 3,\r\n        line_type: \"SOLID\",\r\n        continuous: true,\r\n        min_value: \"\",\r\n        max_value: \"\",\r\n        min_range: \"\",\r\n        max_range: \"\"\r\n    },\r\n    render,\r\n    export: exportDoc,\r\n    onExportComponents\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\icon\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\image\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getColorStyle' is defined but never used. Allowed unused args must match /^_/u.","line":7,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorStyle"},"fix":{"range":[149,168],"text":""},"desc":"Remove unused variable 'getColorStyle'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Image Plugin\r\n */\r\n\r\nconst isOffline = () => window.location.protocol === 'file:' || !window.location.hostname;\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const url = (props.url || \"\").trim();\r\n    const path = (props.path || \"\").replace(/^\"|\"$/g, '').trim();\r\n    const invert = !!props.invert;\r\n\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.backgroundColor = \"#f5f5f5\";\r\n    el.style.display = \"flex\";\r\n    el.style.alignItems = \"center\";\r\n    el.style.justifyContent = \"center\";\r\n    el.style.overflow = \"hidden\";\r\n    el.style.color = \"#666\";\r\n\r\n    el.innerText = \"\";\r\n    el.style.backgroundImage = \"\";\r\n\r\n    if (path) {\r\n        const filename = path.split(/[/\\\\]/).pop() || path;\r\n        el.innerHTML = \"\";\r\n\r\n        const img = document.createElement(\"img\");\r\n        img.style.maxWidth = \"100%\";\r\n        img.style.maxHeight = \"100%\";\r\n        img.style.objectFit = \"contain\";\r\n        img.draggable = false;\r\n\r\n        if (invert) {\r\n            img.style.filter = \"invert(1)\";\r\n        }\r\n\r\n        img.onerror = () => {\r\n            const offlineNote = isOffline() ? \"<br/><span style='color:#e67e22;font-size:8px;'>ÔÜá´©Å Offline mode - preview in HA</span>\" : \"\";\r\n            el.innerHTML = \"<div style='text-align:center;color:#666;font-size:11px;padding:8px;line-height:1.4;'>\" +\r\n                \"­ƒû╝´©Å<br/><strong>\" + filename + \"</strong><br/>\" +\r\n                \"<span style='color:#999;font-size:9px;'>\" +\r\n                (invert ? \"(inverted) \" : \"\") +\r\n                widget.width + \"├ù\" + widget.height + \"px</span>\" + offlineNote + \"</div>\";\r\n        };\r\n\r\n        img.onload = () => {\r\n            const overlay = document.createElement(\"div\");\r\n            overlay.style.position = \"absolute\";\r\n            overlay.style.bottom = \"2px\";\r\n            overlay.style.right = \"2px\";\r\n            overlay.style.background = \"rgba(0,0,0,0.6)\";\r\n            overlay.style.color = \"white\";\r\n            overlay.style.padding = \"2px 4px\";\r\n            overlay.style.fontSize = \"8px\";\r\n            overlay.style.borderRadius = \"2px\";\r\n            overlay.textContent = filename + \" ÔÇó \" + widget.width + \"├ù\" + widget.height + \"px\";\r\n            el.appendChild(overlay);\r\n        };\r\n\r\n        let imgSrc;\r\n        if (isOffline()) {\r\n            if (path.match(/^[A-Za-z]:\\\\/)) {\r\n                imgSrc = \"file:///\" + path.replace(/\\\\/g, '/');\r\n            } else if (path.startsWith('/config/')) {\r\n                imgSrc = null;\r\n            } else {\r\n                imgSrc = path;\r\n            }\r\n        } else {\r\n            imgSrc = \"/api/esphome_designer/image_proxy?path=\" + encodeURIComponent(path);\r\n        }\r\n\r\n        if (imgSrc) {\r\n            img.src = imgSrc;\r\n            el.appendChild(img);\r\n        } else {\r\n            el.innerHTML = \"<div style='text-align:center;color:#666;font-size:11px;padding:8px;line-height:1.4;'>\" +\r\n                \"­ƒû╝´©Å<br/><strong>\" + filename + \"</strong><br/>\" +\r\n                \"<span style='color:#999;font-size:9px;'>\" +\r\n                (invert ? \"(inverted) \" : \"\") +\r\n                widget.width + \"├ù\" + widget.height + \"px</span><br/>\" +\r\n                \"<span style='color:#e67e22;font-size:8px;'>ÔÜá´©Å Preview available in Home Assistant</span></div>\";\r\n        }\r\n        return;\r\n    }\r\n\r\n    if (url) {\r\n        const img = document.createElement(\"img\");\r\n        img.style.maxWidth = \"100%\";\r\n        img.style.maxHeight = \"100%\";\r\n        img.style.objectFit = \"contain\";\r\n        img.draggable = false;\r\n\r\n        if (invert) {\r\n            img.style.filter = \"invert(1)\";\r\n        }\r\n\r\n        img.onerror = () => {\r\n            el.innerHTML = \"<div style='text-align:center;color:#666;font-size:11px;padding:8px;line-height:1.4;'>\" +\r\n                \"­ƒû╝´©Å<br/><strong>Image</strong><br/>\" +\r\n                \"<span style='color:#999;font-size:9px;'>\" +\r\n                (invert ? \"(inverted) \" : \"\") +\r\n                \"Load Failed</span></div>\";\r\n        };\r\n\r\n        img.onload = () => {\r\n            const filename = url.split(\"/\").pop();\r\n            const overlay = document.createElement(\"div\");\r\n            overlay.style.position = \"absolute\";\r\n            overlay.style.bottom = \"2px\";\r\n            overlay.style.right = \"2px\";\r\n            overlay.style.background = \"rgba(0,0,0,0.6)\";\r\n            overlay.style.color = \"white\";\r\n            overlay.style.padding = \"2px 4px\";\r\n            overlay.style.fontSize = \"8px\";\r\n            overlay.style.borderRadius = \"2px\";\r\n            overlay.textContent = filename;\r\n            el.appendChild(overlay);\r\n        };\r\n\r\n        img.src = url;\r\n        el.appendChild(img);\r\n    } else {\r\n        const placeholder = document.createElement(\"div\");\r\n        placeholder.style.textAlign = \"center\";\r\n        placeholder.style.color = \"#aaa\";\r\n        placeholder.style.fontSize = \"11px\";\r\n        placeholder.innerHTML = \"­ƒû╝´©Å<br/>Image Widget<br/><span style='font-size:9px;color:#ccc;'>Enter path in properties ÔåÆ</span>\";\r\n        el.appendChild(placeholder);\r\n    }\r\n};\r\n\r\nexport default {\r\n    id: \"image\",\r\n    name: \"Image\",\r\n    category: \"Graphics\",\r\n    defaults: {\r\n        path: \"\",\r\n        url: \"\",\r\n        invert: false,\r\n        size: \"native\"\r\n    },\r\n    render\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\line\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_arc\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_bar\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_button\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_buttonmatrix\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getColorStyle' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorStyle"},"fix":{"range":[68,87],"text":""},"desc":"Remove unused variable 'getColorStyle'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * LVGL Button Matrix Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"grid\";\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.gap = \"2px\";\r\n    el.style.padding = \"2px\";\r\n    el.style.backgroundColor = \"#444\";\r\n\r\n    let rows = props.rows || [{ buttons: [\"Btn1\", \"Btn2\"] }, { buttons: [\"Btn3\", \"Btn4\"] }];\r\n    if (!Array.isArray(rows)) rows = [];\r\n    el.style.gridTemplateRows = `repeat(${rows.length || 1}, 1fr)`;\r\n\r\n    rows.forEach(rowObj => {\r\n        let buttons = [];\r\n        if (rowObj && typeof rowObj === 'object') {\r\n            buttons = rowObj.buttons || [];\r\n        } else if (typeof rowObj === 'string') {\r\n            buttons = [rowObj];\r\n        }\r\n\r\n        if (!Array.isArray(buttons)) buttons = [String(buttons)];\r\n\r\n        const rowDiv = document.createElement(\"div\");\r\n        rowDiv.style.display = \"grid\";\r\n        rowDiv.style.gridTemplateColumns = `repeat(${buttons.length}, 1fr)`;\r\n        rowDiv.style.gap = \"2px\";\r\n\r\n        buttons.forEach(btnText => {\r\n            const btn = document.createElement(\"div\");\r\n            btn.style.backgroundColor = \"#666\";\r\n            btn.style.display = \"flex\";\r\n            btn.style.alignItems = \"center\";\r\n            btn.style.justifyContent = \"center\";\r\n            btn.style.color = \"#fff\";\r\n            btn.style.fontSize = \"12px\";\r\n            btn.style.fontFamily = \"Roboto, sans-serif\";\r\n            btn.style.borderRadius = \"3px\";\r\n            btn.textContent = btnText;\r\n            rowDiv.appendChild(btn);\r\n        });\r\n        el.appendChild(rowDiv);\r\n    });\r\n};\r\n\r\nconst exportLVGL = (w, { common, convertColor, formatOpacity }) => {\r\n    const p = w.props || {};\r\n    let matrix = p.rows || [{ buttons: [\"1\", \"2\", \"3\"] }, { buttons: [\"4\", \"5\", \"6\"] }];\r\n    return {\r\n        buttonmatrix: {\r\n            ...common,\r\n            rows: matrix,\r\n            bg_color: convertColor(p.bg_color || \"#444\"),\r\n            text_color: convertColor(p.color || \"white\"),\r\n            opa: formatOpacity(p.opa)\r\n        }\r\n    };\r\n};\r\n\r\nexport default {\r\n    id: \"lvgl_buttonmatrix\",\r\n    name: \"Button Matrix\",\r\n    category: \"LVGL\",\r\n    defaults: {\r\n        rows: [\r\n            { buttons: [\"1\", \"2\", \"3\"] },\r\n            { buttons: [\"4\", \"5\", \"6\"] },\r\n            { buttons: [\"7\", \"8\", \"9\"] },\r\n            { buttons: [\"*\", \"0\", \"#\"] }\r\n        ],\r\n        bg_color: \"#444\",\r\n        color: \"white\",\r\n        opa: 255\r\n    },\r\n    render,\r\n    exportLVGL\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_chart\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_checkbox\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_dropdown\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getColorStyle' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorStyle"},"fix":{"range":[63,82],"text":""},"desc":"Remove unused variable 'getColorStyle'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * LVGL Dropdown Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"flex\";\r\n    el.style.alignItems = \"center\";\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.backgroundColor = \"#fff\";\r\n    el.style.border = \"1px solid #999\";\r\n    el.style.borderRadius = \"3px\";\r\n    el.style.padding = \"0 10px\";\r\n\r\n    let options = props.options || \"Option 1\\nOption 2\\nOption 3\";\r\n    if (typeof options === 'string') {\r\n        options = options.split(\"\\n\");\r\n    } else if (!Array.isArray(options)) {\r\n        options = [\"Option 1\", \"Option 2\", \"Option 3\"];\r\n    }\r\n    const idx = props.selected_index || 0;\r\n    const selectedText = options[Math.min(idx, options.length - 1)] || \"Select...\";\r\n\r\n    const text = document.createElement(\"span\");\r\n    text.textContent = selectedText;\r\n    text.style.flex = \"1\";\r\n    text.style.color = \"#000\";\r\n    text.style.fontSize = \"14px\";\r\n    text.style.fontFamily = \"Roboto, sans-serif\";\r\n    text.style.overflow = \"hidden\";\r\n    text.style.textOverflow = \"ellipsis\";\r\n    text.style.whiteSpace = \"nowrap\";\r\n    el.appendChild(text);\r\n\r\n    const arrow = document.createElement(\"span\");\r\n    arrow.textContent = \"Ôû╝\";\r\n    arrow.style.color = \"#000\";\r\n    arrow.style.fontSize = \"10px\";\r\n    arrow.style.marginLeft = \"10px\";\r\n    el.appendChild(arrow);\r\n};\r\n\r\nconst exportLVGL = (w, { common, convertColor, formatOpacity }) => {\r\n    const p = w.props || {};\r\n    let dropdownOptions = p.options || \"\";\r\n    if (Array.isArray(dropdownOptions)) dropdownOptions = dropdownOptions.map(String);\r\n    else dropdownOptions = String(dropdownOptions).split(\"\\n\").filter(o => o.trim() !== \"\");\r\n    return {\r\n        dropdown: {\r\n            ...common,\r\n            options: dropdownOptions,\r\n            selected_index: p.selected_index,\r\n            style: { text_color: convertColor(p.color) },\r\n            direction: p.direction || \"DOWN\",\r\n            max_height: p.max_height,\r\n            opa: formatOpacity(p.opa)\r\n        }\r\n    };\r\n};\r\n\r\nexport default {\r\n    id: \"lvgl_dropdown\",\r\n    name: \"Dropdown\",\r\n    category: \"LVGL\",\r\n    defaults: {\r\n        options: \"Option 1\\nOption 2\\nOption 3\",\r\n        selected_index: 0,\r\n        color: \"black\",\r\n        direction: \"DOWN\",\r\n        max_height: 200,\r\n        opa: 255\r\n    },\r\n    render,\r\n    exportLVGL\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_img\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_keyboard\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getColorStyle' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorStyle"},"fix":{"range":[63,82],"text":""},"desc":"Remove unused variable 'getColorStyle'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'props' is assigned a value but never used.","line":6,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"props"},"fix":{"range":[94,127],"text":""},"desc":"Remove unused variable 'props'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * LVGL Keyboard Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"grid\";\r\n    el.style.gridTemplateColumns = \"repeat(10, 1fr)\";\r\n    el.style.gridTemplateRows = \"repeat(4, 1fr)\";\r\n    el.style.gap = \"2px\";\r\n    el.style.padding = \"4px\";\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.backgroundColor = \"#333\";\r\n    el.style.borderRadius = \"5px\";\r\n\r\n    const keys = \"QWERTYUIOPASDFGHJKLZXCVBNM  ÔåÁÔåÉ\".split(\"\");\r\n    keys.forEach(key => {\r\n        const keyEl = document.createElement(\"div\");\r\n        keyEl.style.backgroundColor = \"#555\";\r\n        keyEl.style.display = \"flex\";\r\n        keyEl.style.alignItems = \"center\";\r\n        keyEl.style.justifyContent = \"center\";\r\n        keyEl.style.color = \"#fff\";\r\n        keyEl.style.fontSize = \"9px\";\r\n        keyEl.style.fontFamily = \"Roboto Mono, monospace\";\r\n        keyEl.style.borderRadius = \"2px\";\r\n        keyEl.textContent = key === \" \" ? \"\" : key;\r\n        el.appendChild(keyEl);\r\n    });\r\n};\r\n\r\nconst exportLVGL = (w, { common, formatOpacity }) => {\r\n    const p = w.props || {};\r\n    return {\r\n        keyboard: {\r\n            ...common,\r\n            mode: p.mode || \"TEXT_LOWER\",\r\n            opa: formatOpacity(p.opa)\r\n        }\r\n    };\r\n};\r\n\r\nexport default {\r\n    id: \"lvgl_keyboard\",\r\n    name: \"Keyboard\",\r\n    category: \"LVGL\",\r\n    defaults: {\r\n        mode: \"TEXT_LOWER\",\r\n        opa: 255\r\n    },\r\n    render,\r\n    exportLVGL\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_label\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_led\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_line\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_meter\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_obj\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_qrcode\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":40,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":40,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * LVGL QR Code Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const fgColor = getColorStyle(props.color || \"black\");\r\n    const bgColor = getColorStyle(props.bg_color || \"white\");\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.backgroundColor = bgColor;\r\n    el.style.display = \"flex\";\r\n    el.style.alignItems = \"center\";\r\n    el.style.justifyContent = \"center\";\r\n\r\n    const text = props.text || \"https://esphome.io\";\r\n\r\n    try {\r\n        if (window.qrcode) {\r\n            const typeNumber = 0;\r\n            const errorCorrectionLevel = 'L';\r\n            const qr = qrcode(typeNumber, errorCorrectionLevel);\r\n            qr.addData(text);\r\n            qr.make();\r\n\r\n            const svgString = qr.createSvgTag(widget.props.scale || 4, 0);\r\n            const helper = document.createElement('div');\r\n            helper.innerHTML = svgString;\r\n            const svg = helper.querySelector('svg');\r\n            if (svg) {\r\n                svg.style.width = \"100%\";\r\n                svg.style.height = \"100%\";\r\n                svg.style.fill = fgColor;\r\n            }\r\n            el.appendChild(helper.firstChild);\r\n        } else {\r\n            el.textContent = \"QR\";\r\n            el.style.outline = \"2px solid \" + fgColor;\r\n        }\r\n    } catch (e) {\r\n        el.textContent = \"QR Error\";\r\n    }\r\n};\r\n\r\nconst exportLVGL = (w, { common, convertColor }) => {\r\n    const p = w.props || {};\r\n    return {\r\n        qrcode: {\r\n            ...common,\r\n            text: `\"${p.text || 'https://esphome.io'}\"`,\r\n            size: Math.min(w.w, w.h),\r\n            dark_color: convertColor(p.color),\r\n            light_color: convertColor(p.bg_color || \"white\")\r\n        }\r\n    };\r\n};\r\n\r\nexport default {\r\n    id: \"lvgl_qrcode\",\r\n    name: \"QR Code (lv)\",\r\n    category: \"LVGL\",\r\n    defaults: {\r\n        text: \"https://esphome.io\",\r\n        color: \"black\",\r\n        bg_color: \"white\",\r\n        scale: 4\r\n    },\r\n    render,\r\n    exportLVGL\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_roller\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_slider\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_spinbox\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getColorStyle' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorStyle"},"fix":{"range":[62,81],"text":""},"desc":"Remove unused variable 'getColorStyle'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * LVGL Spinbox Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const value = props.value || 0;\r\n    const digits = props.digit_count || 4;\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"flex\";\r\n    el.style.alignItems = \"center\";\r\n    el.style.justifyContent = \"center\";\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.backgroundColor = \"#fff\";\r\n    el.style.border = \"1px solid #999\";\r\n    el.style.borderRadius = \"3px\";\r\n\r\n    const valueText = String(value).padStart(digits, \"0\");\r\n    const display = document.createElement(\"span\");\r\n    display.textContent = valueText;\r\n    display.style.fontFamily = \"Roboto Mono, monospace\";\r\n    display.style.fontSize = \"20px\";\r\n    display.style.color = \"#000\";\r\n    display.style.letterSpacing = \"2px\";\r\n    el.appendChild(display);\r\n\r\n    const cursor = document.createElement(\"div\");\r\n    cursor.style.position = \"absolute\";\r\n    cursor.style.bottom = \"8px\";\r\n    cursor.style.right = \"25%\";\r\n    cursor.style.width = \"10px\";\r\n    cursor.style.height = \"2px\";\r\n    cursor.style.backgroundColor = \"blue\";\r\n    el.style.position = \"relative\";\r\n    el.appendChild(cursor);\r\n};\r\n\r\nexport default {\r\n    id: \"lvgl_spinbox\",\r\n    name: \"Spinbox\",\r\n    category: \"LVGL\",\r\n    defaults: {\r\n        value: 0,\r\n        digit_count: 4,\r\n        step: 1\r\n    },\r\n    render\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_spinner\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_switch\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_tabview\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_textarea\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getColorStyle' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorStyle"},"fix":{"range":[63,82],"text":""},"desc":"Remove unused variable 'getColorStyle'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * LVGL Textarea Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const text = props.text || \"\";\r\n    const placeholder = props.placeholder || \"Enter text...\";\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"flex\";\r\n    el.style.flexDirection = \"column\";\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.backgroundColor = \"#fff\";\r\n    el.style.border = \"1px solid #999\";\r\n    el.style.borderRadius = \"3px\";\r\n    el.style.padding = \"5px\";\r\n    el.style.overflow = \"hidden\";\r\n\r\n    const content = document.createElement(\"div\");\r\n    content.style.flex = \"1\";\r\n    content.style.fontFamily = \"Roboto, sans-serif\";\r\n    content.style.fontSize = \"14px\";\r\n    content.style.overflow = \"hidden\";\r\n    content.style.textOverflow = \"ellipsis\";\r\n\r\n    if (text) {\r\n        content.textContent = text;\r\n        content.style.color = \"#000\";\r\n    } else {\r\n        content.textContent = placeholder;\r\n        content.style.color = \"#ccc\";\r\n    }\r\n\r\n    el.appendChild(content);\r\n\r\n    const cursor = document.createElement(\"div\");\r\n    cursor.style.width = \"1px\";\r\n    cursor.style.height = \"14px\";\r\n    cursor.style.backgroundColor = \"#000\";\r\n    cursor.style.position = \"absolute\";\r\n    cursor.style.left = \"6px\";\r\n    cursor.style.top = \"6px\";\r\n    el.style.position = \"relative\";\r\n    el.appendChild(cursor);\r\n};\r\n\r\nexport default {\r\n    id: \"lvgl_textarea\",\r\n    name: \"Textarea\",\r\n    category: \"LVGL\",\r\n    defaults: {\r\n        text: \"\",\r\n        placeholder: \"Enter text...\",\r\n        max_length: 128\r\n    },\r\n    render\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\lvgl_tileview\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\ondevice_humidity\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\ondevice_temperature\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\online_image\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getColorStyle' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorStyle"},"fix":{"range":[62,81],"text":""},"desc":"Remove unused variable 'getColorStyle'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'getColorConst' is assigned a value but never used.","line":85,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":85,"endColumn":29,"suggestions":[{"messageId":"removeVar","data":{"varName":"getColorConst"},"fix":{"range":[2813,2828],"text":""},"desc":"Remove unused variable 'getColorConst'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'profile' is assigned a value but never used.","line":85,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":85,"endColumn":71,"suggestions":[{"messageId":"removeVar","data":{"varName":"profile"},"fix":{"range":[2861,2870],"text":""},"desc":"Remove unused variable 'profile'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Online Image Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const url = props.url || props.path || \"\";\r\n    const invert = !!props.invert;\r\n\r\n    el.style.boxSizing = \"border-box\";\r\n    el.style.backgroundColor = \"#f5f5f5\";\r\n    el.style.display = \"flex\";\r\n    el.style.alignItems = \"center\";\r\n    el.style.justifyContent = \"center\";\r\n    el.style.overflow = \"hidden\";\r\n    el.style.color = \"#666\";\r\n\r\n    el.innerText = \"\";\r\n    el.style.backgroundImage = \"\";\r\n\r\n    if (url) {\r\n        const img = document.createElement(\"img\");\r\n        img.style.maxWidth = \"100%\";\r\n        img.style.maxHeight = \"100%\";\r\n        img.style.objectFit = \"contain\";\r\n        img.draggable = false;\r\n\r\n        if (invert) {\r\n            img.style.filter = \"invert(1)\";\r\n        }\r\n\r\n        img.onerror = () => {\r\n            el.innerHTML = \"<div style='text-align:center;color:#666;font-size:11px;padding:8px;line-height:1.4;'>\" +\r\n                \"­ƒû╝´©Å<br/><strong>Online Image</strong><br/>\" +\r\n                \"<span style='color:#999;font-size:9px;'>\" +\r\n                (invert ? \"(inverted) \" : \"\") +\r\n                \"Load Failed</span></div>\";\r\n        };\r\n\r\n        img.onload = () => {\r\n            const filename = url.split(\"/\").pop();\r\n            const overlay = document.createElement(\"div\");\r\n            overlay.style.position = \"absolute\";\r\n            overlay.style.bottom = \"2px\";\r\n            overlay.style.right = \"2px\";\r\n            overlay.style.background = \"rgba(0,0,0,0.6)\";\r\n            overlay.style.color = \"white\";\r\n            overlay.style.padding = \"2px 4px\";\r\n            overlay.style.fontSize = \"8px\";\r\n            overlay.style.borderRadius = \"2px\";\r\n            overlay.textContent = filename;\r\n            el.appendChild(overlay);\r\n        };\r\n\r\n        img.src = url;\r\n        el.appendChild(img);\r\n    } else {\r\n        const placeholder = document.createElement(\"div\");\r\n        placeholder.style.textAlign = \"center\";\r\n        placeholder.style.color = \"#aaa\";\r\n        placeholder.style.fontSize = \"11px\";\r\n        placeholder.innerHTML = \"­ƒû╝´©Å<br/>Online Image<br/><span style='font-size:9px;color:#ccc;'>Enter URL in properties ÔåÆ</span>\";\r\n        el.appendChild(placeholder);\r\n    }\r\n};\r\n\r\nconst exportLVGL = (w, { common, convertColor }) => {\r\n    const p = w.props || {};\r\n    let src = (p.src || p.path || p.url || \"symbol_image\");\r\n    return {\r\n        img: {\r\n            ...common,\r\n            src: src,\r\n            angle: (p.rotation || 0),\r\n            pivot_x: (p.pivot_x || 0),\r\n            pivot_y: (p.pivot_y || 0),\r\n            image_recolor: convertColor(p.color),\r\n            image_recolor_opa: \"COVER\"\r\n        }\r\n    };\r\n};\r\n\r\nconst exportDoc = (w, context) => {\r\n    const {\r\n        lines, getColorConst, getCondProps, getConditionCheck, profile\r\n    } = context;\r\n\r\n    const p = w.props || {};\r\n    const url = (p.url || \"\").trim();\r\n    const invert = !!p.invert;\r\n    const renderMode = p.render_mode || \"Auto\";\r\n\r\n    const safeId = `online_image_${w.id.replace(/-/g, \"_\")}`;\r\n\r\n    lines.push(`        // widget:online_image id:${w.id} type:online_image x:${w.x} y:${w.y} w:${w.width} h:${w.height} url:\"${url}\" invert:${invert} render_mode:\"${renderMode}\" ${getCondProps(w)}`);\r\n\r\n    const cond = getConditionCheck(w);\r\n    if (cond) lines.push(`        ${cond}`);\r\n\r\n    if (invert) {\r\n        lines.push(`        it.image(${w.x}, ${w.y}, id(${safeId}), color_off, color_on);`);\r\n    } else {\r\n        lines.push(`        it.image(${w.x}, ${w.y}, id(${safeId}));`);\r\n    }\r\n\r\n    if (cond) lines.push(`        }`);\r\n};\r\n\r\nconst onExportComponents = (context) => {\r\n    const { lines, widgets, profile } = context;\r\n    const targets = widgets.filter(w => w.type === 'online_image');\r\n\r\n    if (targets.length > 0) {\r\n        lines.push(\"online_image:\");\r\n        targets.forEach(w => {\r\n            const p = w.props || {};\r\n            const url = (p.url || \"\").trim();\r\n            const safeId = `online_image_${w.id.replace(/-/g, \"_\")}`;\r\n\r\n            let format = (p.format || \"PNG\").toUpperCase();\r\n            if (format === \"JPG\") format = \"JPEG\";\r\n\r\n            const renderMode = p.render_mode || \"Auto\";\r\n            let imgType = \"GRAYSCALE\";\r\n\r\n            if (renderMode === \"Binary\") {\r\n                imgType = \"BINARY\";\r\n            } else if (renderMode === \"Grayscale\") {\r\n                imgType = \"GRAYSCALE\";\r\n            } else if (renderMode === \"Color (RGB565)\") {\r\n                imgType = \"RGB565\";\r\n            } else {\r\n                const isColor = profile.features?.lcd || (profile.name && (profile.name.includes(\"6-Color\") || profile.name.includes(\"Color\")));\r\n                imgType = isColor ? \"RGB565\" : \"BINARY\";\r\n            }\r\n\r\n            let updateInterval = p.update_interval || \"never\";\r\n            if (p.interval_s && p.interval_s > 0) {\r\n                updateInterval = `${p.interval_s}s`;\r\n            }\r\n\r\n            lines.push(`  - id: ${safeId}`);\r\n            lines.push(`    url: \"${url}\"`);\r\n            lines.push(`    format: ${format}`);\r\n            lines.push(`    type: ${imgType}`);\r\n\r\n            if (imgType !== \"BINARY\") {\r\n                const rW = parseInt(w.width, 10);\r\n                const rH = parseInt(w.height, 10);\r\n                lines.push(`    resize: ${rW}x${rH}`);\r\n            }\r\n\r\n            lines.push(`    update_interval: ${updateInterval}`);\r\n\r\n            if (imgType === \"BINARY\" || imgType === \"GRAYSCALE\") {\r\n                lines.push(`    dither: FLOYDSTEINBERG`);\r\n            }\r\n\r\n            const displayId = profile.features?.lcd ? \"my_display\" : \"epaper_display\";\r\n            lines.push(`    on_download_finished:`);\r\n            lines.push(`      then:`);\r\n            lines.push(`        - component.update: ${displayId}`);\r\n            lines.push(`    on_error:`);\r\n            lines.push(`      then:`);\r\n            lines.push(`        - component.update: ${displayId}`);\r\n        });\r\n        lines.push(\"\");\r\n    }\r\n};\r\n\r\nexport default {\r\n    id: \"online_image\",\r\n    name: \"Online Image\",\r\n    category: \"Graphics\",\r\n    defaults: {\r\n        url: \"\",\r\n        invert: false,\r\n        update_interval: \"1h\",\r\n        rotation: 0,\r\n        color: \"black\"\r\n    },\r\n    render,\r\n    exportLVGL,\r\n    export: exportDoc,\r\n    onExportComponents\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\progress_bar\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\qr_code\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'helpers' is defined but never used. Allowed unused args must match /^_/u.","line":18,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":41,"suggestions":[{"messageId":"removeVar","data":{"varName":"helpers"},"fix":{"range":[456,465],"text":""},"desc":"Remove unused variable 'helpers'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * QR Code Plugin\r\n */\r\n\r\nconst exportLVGL = (w, { common, convertColor }) => {\r\n    const p = w.props || {};\r\n    return {\r\n        qrcode: {\r\n            ...common,\r\n            text: `\"${p.text || p.value || 'https://esphome.io'}\"`,\r\n            size: Math.min(w.width, w.height),\r\n            dark_color: convertColor(p.color),\r\n            light_color: convertColor(p.bg_color || \"white\")\r\n        }\r\n    };\r\n};\r\n\r\nconst render = (element, widget, helpers) => {\r\n    const props = widget.props || {};\r\n    const value = props.value || \"https://esphome.io\";\r\n    const color = props.color || \"black\";\r\n    const ecc = props.ecc || \"LOW\";\r\n\r\n    element.style.boxSizing = \"border-box\";\r\n    element.style.display = \"flex\";\r\n    element.style.alignItems = \"flex-start\";\r\n    element.style.justifyContent = \"flex-start\";\r\n    element.style.overflow = \"hidden\";\r\n    element.style.padding = \"0\";\r\n    element.innerHTML = \"\";\r\n\r\n    const eccMap = { \"LOW\": \"L\", \"MEDIUM\": \"M\", \"QUARTILE\": \"Q\", \"HIGH\": \"H\" };\r\n    const eccLevel = eccMap[ecc] || \"L\";\r\n\r\n    if (typeof qrcode === \"undefined\") {\r\n        element.innerHTML = '<div style=\"color:#999;font-size:10px;text-align:center;\">QR Library<br>Loading...</div>';\r\n        return;\r\n    }\r\n\r\n    try {\r\n        const qr = qrcode(0, eccLevel);\r\n        qr.addData(value);\r\n        qr.make();\r\n\r\n        const moduleCount = qr.getModuleCount();\r\n        const availableSize = Math.min(widget.width, widget.height);\r\n        const cellSize = Math.max(1, Math.floor(availableSize / moduleCount));\r\n        const qrSize = cellSize * moduleCount;\r\n\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.width = qrSize;\r\n        canvas.height = qrSize;\r\n        canvas.style.imageRendering = \"pixelated\";\r\n\r\n        const ctx = canvas.getContext(\"2d\");\r\n        const fillColor = color === \"white\" ? \"#fff\" : \"#000\";\r\n        ctx.fillStyle = fillColor;\r\n\r\n        for (let row = 0; row < moduleCount; row++) {\r\n            for (let col = 0; col < moduleCount; col++) {\r\n                if (qr.isDark(row, col)) {\r\n                    ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\r\n                }\r\n            }\r\n        }\r\n\r\n        element.appendChild(canvas);\r\n        widget.props._calculatedScale = cellSize;\r\n\r\n    } catch (e) {\r\n        element.innerHTML = '<div style=\"color:#c00;font-size:10px;text-align:center;\">QR Error:<br>' + e.message + '</div>';\r\n    }\r\n};\r\n\r\nconst exportDoc = (w, context) => {\r\n    const {\r\n        lines, getColorConst, addDitherMask, sanitize, getCondProps, getConditionCheck, isEpaper\r\n    } = context;\r\n\r\n    const p = w.props || {};\r\n    const value = sanitize(p.value || \"https://esphome.io\");\r\n    const ecc = p.ecc || \"LOW\";\r\n    const colorProp = p.color || \"black\";\r\n\r\n    const color = getColorConst(colorProp);\r\n    const safeId = `qr_${w.id}`.replace(/-/g, \"_\");\r\n\r\n    const availableSize = Math.min(w.width, w.height);\r\n    const contentLen = value.length;\r\n    const estimatedModules = Math.min(177, 21 + Math.ceil(contentLen / 10) * 2);\r\n    const scale = Math.max(1, Math.floor(availableSize / estimatedModules));\r\n\r\n    lines.push(`        // widget:qr_code id:${w.id} type:qr_code x:${w.x} y:${w.y} w:${w.width} h:${w.height} value:\"${value}\" scale:${scale} ecc:${ecc} color:${colorProp} ${getCondProps(w)}`);\r\n\r\n    const cond = getConditionCheck(w);\r\n    if (cond) lines.push(`        ${cond}`);\r\n\r\n    lines.push(`        it.qr_code(${w.x}, ${w.y}, id(${safeId}), ${color}, ${scale});`);\r\n    addDitherMask(lines, colorProp, isEpaper, w.x, w.y, w.width, w.height);\r\n\r\n    if (cond) lines.push(`        }`);\r\n};\r\n\r\nconst onExportComponents = (context) => {\r\n    const { lines, widgets } = context;\r\n    const qrCodeWidgets = widgets.filter(w => w.type === 'qr_code');\r\n\r\n    if (qrCodeWidgets.length > 0) {\r\n        lines.push(\"qr_code:\");\r\n        qrCodeWidgets.forEach(w => {\r\n            const p = w.props || {};\r\n            const safeId = `qr_${w.id}`.replace(/-/g, \"_\");\r\n            const value = (p.value || \"https://esphome.io\").replace(/\"/g, '\\\\\"');\r\n            const ecc = p.ecc || \"LOW\";\r\n\r\n            lines.push(`  - id: ${safeId}`);\r\n            lines.push(`    value: \"${value}\"`);\r\n            lines.push(`    ecc: ${ecc}`);\r\n        });\r\n        lines.push(\"\");\r\n    }\r\n};\r\n\r\nexport default {\r\n    id: \"qr_code\",\r\n    name: \"QR Code\",\r\n    category: \"Graphics\",\r\n    defaults: {\r\n        value: \"https://esphome.io\",\r\n        ecc: \"LOW\",\r\n        color: \"black\",\r\n        bg_color: \"white\",\r\n        width: 130,\r\n        height: 130\r\n    },\r\n    render,\r\n    exportLVGL,\r\n    export: exportDoc,\r\n    onExportComponents\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\quote_rss\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\rounded_rect\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\sensor_text\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'rawState' is assigned a value but never used.","line":34,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"rawState"},"fix":{"range":[1485,1518],"text":""},"desc":"Remove unused variable 'rawState'."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":66,"column":61,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":66,"endColumn":62,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3183,3184],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3183,3183],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'Utils' is assigned a value but never used.","line":229,"column":77,"nodeType":"Identifier","messageId":"unusedVar","endLine":229,"endColumn":82,"suggestions":[{"messageId":"removeVar","data":{"varName":"Utils"},"fix":{"range":[9200,9207],"text":""},"desc":"Remove unused variable 'Utils'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'baseAlign' is assigned a value but never used.","line":293,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":293,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"baseAlign"},"fix":{"range":[11822,11860],"text":""},"desc":"Remove unused variable 'baseAlign'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Sensor Text Plugin\r\n * @description Displays a single or double sensor value with optional label and unit.\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const entityId = widget.entity_id || \"\";\r\n    const title = widget.title || \"\";\r\n    const format = props.value_format || \"label_value\";\r\n    let precision = parseInt(props.precision, 10);\r\n    if (isNaN(precision)) precision = 2;\r\n    const unitProp = props.unit || \"\";\r\n    const labelFontSize = props.label_font_size || 14;\r\n    const valueFontSize = props.value_font_size || 20;\r\n    const fontFamily = (props.font_family || \"Roboto\") + \", sans-serif\";\r\n    const fontWeight = String(props.font_weight || 400);\r\n    const fontStyle = props.italic ? \"italic\" : \"normal\";\r\n    const colorStyle = getColorStyle(props.color);\r\n\r\n    const entityId2 = widget.entity_id_2 || \"\";\r\n    const separator = props.separator || \" ~ \";\r\n\r\n    let displayValue = \"--\";\r\n    const isNoUnit = format && format.endsWith(\"_no_unit\");\r\n    let displayUnit = (props.hide_unit || isNoUnit) ? \"\" : unitProp;\r\n\r\n    // Helper to format a single value\r\n    const formatValue = (eId) => {\r\n        if (window.AppState && window.AppState.entityStates && eId) {\r\n            const entityObj = window.AppState.entityStates[eId];\r\n            if (entityObj && entityObj.state !== undefined) {\r\n                const strState = entityObj.formatted || String(entityObj.state);\r\n                const rawState = entityObj.state;\r\n\r\n                const match = strState.match(/^([-+]?\\d*[.,]?\\d+)(.*)$/);\r\n                if (match) {\r\n                    const val = parseFloat(match[1].replace(',', '.'));\r\n                    const extractedUnit = match[2] ? match[2].trim() : \"\";\r\n\r\n                    if (eId === entityId && (unitProp === undefined || unitProp === \"\") && !props.hide_unit && !isNoUnit) {\r\n                        displayUnit = extractedUnit;\r\n                    }\r\n                    if (!isNaN(val)) {\r\n                        if (!isNaN(precision) && precision >= 0) {\r\n                            return val.toFixed(precision);\r\n                        }\r\n                        return val.toString();\r\n                    }\r\n                }\r\n                if (eId === entityId && (unitProp === undefined || unitProp === \"\") && entityObj.attributes && entityObj.attributes.unit_of_measurement && !props.hide_unit && !isNoUnit) {\r\n                    displayUnit = entityObj.attributes.unit_of_measurement;\r\n                }\r\n\r\n                if (isNoUnit || props.hide_unit) {\r\n                    const numMatch = strState.match(/^([-+]?\\d*[.,]?\\d+)/);\r\n                    if (numMatch) {\r\n                        const numVal = parseFloat(numMatch[1].replace(',', '.'));\r\n                        if (!isNaN(numVal)) {\r\n                            if (!isNaN(precision) && precision >= 0) {\r\n                                return numVal.toFixed(precision);\r\n                            }\r\n                            return numVal.toString();\r\n                        }\r\n                    }\r\n                    return strState.replace(/\\s*[┬░%]?[A-Za-z\\/┬▓┬│]+\\s*$/, '').trim() || strState;\r\n                }\r\n                return strState;\r\n            }\r\n        }\r\n        return \"--\";\r\n    };\r\n\r\n    const val1 = formatValue(entityId);\r\n    let val2 = null;\r\n    if (entityId2) {\r\n        val2 = formatValue(entityId2);\r\n    }\r\n\r\n    displayValue = val1;\r\n    if (val2 !== null) {\r\n        displayValue = `${val1}${separator}${val2}`;\r\n    }\r\n\r\n    if (displayUnit && displayValue.endsWith(displayUnit)) {\r\n        displayUnit = \"\";\r\n    }\r\n\r\n    let effectiveTitle = title;\r\n    if (!effectiveTitle && (format.startsWith(\"label_\") || format === \"value_label\")) {\r\n        if (window.AppState && window.AppState.entityStates && entityId) {\r\n            const eObj = window.AppState.entityStates[entityId];\r\n            if (eObj && eObj.attributes && eObj.attributes.friendly_name) {\r\n                effectiveTitle = eObj.attributes.friendly_name;\r\n            } else if (entityId) {\r\n                effectiveTitle = entityId.split('.').pop().replace(/_/g, ' ');\r\n            }\r\n        }\r\n    }\r\n\r\n    const prefix = props.prefix || \"\";\r\n    const postfix = props.postfix || \"\";\r\n    const fullValue = `${prefix}${displayValue}${displayUnit ? \" \" + displayUnit : \"\"}${postfix}`.trim();\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"flex\";\r\n\r\n    const applyAlign = (align, element) => {\r\n        if (!align) return;\r\n        if (align.includes(\"LEFT\")) element.style.textAlign = \"left\";\r\n        else if (align.includes(\"RIGHT\")) element.style.textAlign = \"right\";\r\n        else element.style.textAlign = \"center\";\r\n    };\r\n\r\n    const applyFlexAlign = (align, element) => {\r\n        if (!align) return;\r\n        if (align.includes(\"LEFT\")) element.style.justifyContent = \"flex-start\";\r\n        else if (align.includes(\"RIGHT\")) element.style.justifyContent = \"flex-end\";\r\n        else element.style.justifyContent = \"center\";\r\n\r\n        if (align.includes(\"TOP\")) element.style.alignItems = \"flex-start\";\r\n        else if (align.includes(\"BOTTOM\")) element.style.alignItems = \"flex-end\";\r\n        else element.style.alignItems = \"center\";\r\n    };\r\n\r\n    applyFlexAlign(props.text_align || \"TOP_LEFT\", el);\r\n\r\n    const body = document.createElement(\"div\");\r\n    body.style.color = colorStyle;\r\n    body.style.fontFamily = fontFamily;\r\n    body.style.fontWeight = fontWeight;\r\n    body.style.fontStyle = fontStyle;\r\n\r\n    if ((format === \"label_value\" || format === \"label_value_no_unit\") && effectiveTitle) {\r\n        body.style.display = \"flex\";\r\n        body.style.alignItems = \"baseline\";\r\n        body.style.gap = \"4px\";\r\n\r\n        const labelSpan = document.createElement(\"span\");\r\n        labelSpan.style.fontSize = `${labelFontSize}px`;\r\n        labelSpan.textContent = effectiveTitle + \":\";\r\n\r\n        const valueSpan = document.createElement(\"span\");\r\n        valueSpan.style.fontSize = `${valueFontSize}px`;\r\n        valueSpan.textContent = fullValue;\r\n\r\n        const align = props.label_align || props.text_align || \"TOP_LEFT\";\r\n        if (align.includes(\"CENTER\")) body.style.justifyContent = \"center\";\r\n        else if (align.includes(\"RIGHT\")) body.style.justifyContent = \"flex-end\";\r\n        else body.style.justifyContent = \"flex-start\";\r\n\r\n        body.appendChild(labelSpan);\r\n        body.appendChild(valueSpan);\r\n    } else if ((format === \"label_newline_value\" || format === \"label_newline_value_no_unit\") && effectiveTitle) {\r\n        body.style.display = \"flex\";\r\n        body.style.flexDirection = \"column\";\r\n        body.style.gap = \"2px\";\r\n        body.style.width = \"100%\";\r\n\r\n        const labelDiv = document.createElement(\"div\");\r\n        labelDiv.style.fontSize = `${labelFontSize}px`;\r\n        labelDiv.textContent = effectiveTitle;\r\n        applyAlign(props.label_align || props.text_align || \"TOP_LEFT\", labelDiv);\r\n\r\n        const valueDiv = document.createElement(\"div\");\r\n        valueDiv.style.fontSize = `${valueFontSize}px`;\r\n        valueDiv.textContent = fullValue;\r\n        applyAlign(props.value_align || props.text_align || \"TOP_LEFT\", valueDiv);\r\n\r\n        body.appendChild(labelDiv);\r\n        body.appendChild(valueDiv);\r\n    } else if (format === \"value_label\" && effectiveTitle) {\r\n        body.style.display = \"flex\";\r\n        body.style.alignItems = \"baseline\";\r\n        body.style.gap = \"4px\";\r\n\r\n        const valueSpan = document.createElement(\"span\");\r\n        valueSpan.style.fontSize = `${valueFontSize}px`;\r\n        valueSpan.textContent = fullValue;\r\n\r\n        const labelSpan = document.createElement(\"span\");\r\n        labelSpan.style.fontSize = `${labelFontSize}px`;\r\n        labelSpan.textContent = effectiveTitle;\r\n\r\n        body.appendChild(valueSpan);\r\n        body.appendChild(labelSpan);\r\n    } else if (format === \"label_only\") {\r\n        body.style.fontSize = `${labelFontSize}px`;\r\n        body.textContent = effectiveTitle;\r\n        applyAlign(props.text_align || \"TOP_LEFT\", body);\r\n    } else {\r\n        body.style.fontSize = `${valueFontSize}px`;\r\n        body.textContent = fullValue;\r\n        applyAlign(props.value_align || props.text_align || \"TOP_LEFT\", body);\r\n    }\r\n\r\n    el.appendChild(body);\r\n};\r\n\r\nexport default {\r\n    id: \"sensor_text\",\r\n    name: \"Sensor Text\",\r\n    category: \"Sensors\",\r\n    defaults: {\r\n        entity_id: \"\",\r\n        title: \"Sensor\",\r\n        value_format: \"label_value\",\r\n        label_font_size: 14,\r\n        value_font_size: 20,\r\n        unit: \"\",\r\n        precision: 2,\r\n        text_align: \"TOP_LEFT\",\r\n        font_family: \"Roboto\"\r\n    },\r\n\r\n    render,\r\n\r\n    collectRequirements: (w, { addFont }) => {\r\n        const p = w.props || {};\r\n        const family = p.font_family || \"Roboto\";\r\n        const weight = p.font_weight || 400;\r\n        const italic = !!p.italic;\r\n        addFont(family, weight, p.label_font_size || 14, italic);\r\n        addFont(family, weight, p.value_font_size || 20, italic);\r\n    },\r\n\r\n    export: (w, context) => {\r\n        const {\r\n            lines, getColorConst, addFont, getCondProps, getConditionCheck, Utils\r\n        } = context;\r\n\r\n        const p = w.props || {};\r\n        const entityId = (w.entity_id || \"\").trim();\r\n        const entityId2 = (w.entity_id_2 || \"\").trim();\r\n\r\n        const format = p.value_format || \"label_value\";\r\n        const unit = p.unit || \"\";\r\n        const labelFS = p.label_font_size || 14;\r\n        const valueFS = p.value_font_size || 20;\r\n        const family = p.font_family || \"Roboto\";\r\n        const weight = p.font_weight || 400;\r\n        const italic = !!p.italic;\r\n        const color = getColorConst(p.color || (context.isDark ? \"white\" : \"black\"));\r\n        const textAlign = p.text_align || \"TOP_LEFT\";\r\n        const separator = p.separator || \" ~ \";\r\n        const prefix = p.prefix || \"\";\r\n        const postfix = p.postfix || \"\";\r\n        let precision = parseInt(p.precision, 10);\r\n        if (isNaN(precision) || precision < 0) precision = 2;\r\n\r\n        lines.push(`        // widget:sensor_text id:${w.id} type:sensor_text x:${w.x} y:${w.y} w:${w.width} h:${w.height} ent:${entityId} fmt:${format} ${getCondProps(w)}`);\r\n\r\n        if (!entityId) {\r\n            lines.push(`        // Sensor ID missing for this widget`);\r\n            return;\r\n        }\r\n\r\n        const labelFontId = addFont(family, weight, labelFS, italic);\r\n        const valueFontId = addFont(family, weight, valueFS, italic);\r\n\r\n        const cond = getConditionCheck(w);\r\n        if (cond) lines.push(`        ${cond}`);\r\n\r\n        // Helper to get ESPHome variable name for an entity\r\n        const getVarName = (eid, isText) => {\r\n            const safe = eid.replace(/[^a-zA-Z0-9_]/g, \"_\");\r\n            if (isText || p.is_text_sensor || eid.startsWith(\"text_sensor.\")) return `id(${safe}_txt)`;\r\n            return `id(${safe})`;\r\n        };\r\n\r\n        const v1 = getVarName(entityId);\r\n        const v2 = entityId2 ? getVarName(entityId2) : null;\r\n\r\n        // Determine format string for values\r\n        const isText = p.is_text_sensor || entityId.startsWith(\"text_sensor.\");\r\n        const valFmt = isText ? \"%s\" : `%.${precision}f`;\r\n\r\n        // Format parts\r\n        let title = p.title || w.title || \"\";\r\n        if (!title && (format.startsWith(\"label_\"))) {\r\n            title = entityId.split('.').pop().replace(/_/g, ' '); // Minimal fallback\r\n        }\r\n\r\n        const displayUnit = (p.hide_unit || format.endsWith(\"_no_unit\")) ? \"\" : unit;\r\n\r\n        // Alignment Mapping\r\n        const getAlign = (a) => {\r\n            if (!a) return \"TextAlign::TOP_LEFT\";\r\n            if (a === \"CENTER\") return \"TextAlign::CENTER\";\r\n            return `TextAlign::${a}`;\r\n        };\r\n\r\n        const baseAlign = getAlign(textAlign);\r\n        const labelAlign = getAlign(p.label_align || textAlign);\r\n        const valueAlign = getAlign(p.value_align || textAlign);\r\n\r\n        // Positioning Helpers\r\n        let x = w.x;\r\n        let y = w.y;\r\n\r\n        const isCentered = textAlign.includes(\"CENTER\");\r\n        const isRight = textAlign.includes(\"RIGHT\");\r\n\r\n        if (isCentered) x = Math.round(w.x + w.width / 2);\r\n        else if (isRight) x = Math.round(w.x + w.width);\r\n\r\n        if (textAlign.includes(\"BOTTOM\")) y = Math.round(w.y + w.height);\r\n        else if (!textAlign.includes(\"TOP\")) y = Math.round(w.y + w.height / 2); // Middle\r\n\r\n        if (format === \"label_only\") {\r\n            lines.push(`        it.printf(${x}, ${y}, id(${labelFontId}), ${color}, ${labelAlign}, \"${title}\");`);\r\n        } else if (format === \"value_only\" || format === \"value_only_no_unit\" || !title) {\r\n            const finalFmt = `${prefix}${valFmt}${v2 ? separator + valFmt : \"\"}${displayUnit ? \" \" + displayUnit : \"\"}${postfix}`;\r\n            const args = v2 ? `${v1}.state, ${v2}.state` : `${v1}.state`;\r\n            lines.push(`        it.printf(${x}, ${y}, id(${valueFontId}), ${color}, ${valueAlign}, \"${finalFmt}\", ${args});`);\r\n        } else if (format === \"label_value\" || format === \"label_value_no_unit\") {\r\n            // Horizontal layout: [Label:] [Value]\r\n            // We'll use a small offset for the value if left aligned, or just print together if possible.\r\n            // Simplified: print as one string if same font, but they use different fonts often.\r\n            // For now, we print them separately with a heuristic offset.\r\n            const labelStr = `${title}${title.endsWith(\":\") ? \"\" : \":\"}`;\r\n            lines.push(`        it.printf(${x}, ${y}, id(${labelFontId}), ${color}, ${labelAlign}, \"${labelStr}\");`);\r\n\r\n            // Heuristic for value position (label size + some gap)\r\n            // Ideally we'd measure text, but we can't in lambda easily.\r\n            const offset = Math.round(labelFS * 0.6 * labelStr.length) + 10;\r\n            const valFmtFull = `${prefix}${valFmt}${v2 ? separator + valFmt : \"\"}${displayUnit ? \" \" + displayUnit : \"\"}${postfix}`;\r\n            const args = v2 ? `${v1}.state, ${v2}.state` : `${v1}.state`;\r\n\r\n            let valX = x + offset;\r\n            if (isCentered) valX = x + offset / 2; // Rough adjustment\r\n            else if (isRight) valX = x; // Overlap? Better to just use label_newline_value for cleanliness\r\n\r\n            lines.push(`        it.printf(${valX}, ${y}, id(${valueFontId}), ${color}, ${valueAlign}, \"${valFmtFull}\", ${args});`);\r\n        } else if (format === \"label_newline_value\" || format === \"label_newline_value_no_unit\") {\r\n            // Vertical layout\r\n            lines.push(`        it.printf(${x}, ${y}, id(${labelFontId}), ${color}, ${labelAlign}, \"${title}\");`);\r\n            const valFmtFull = `${prefix}${valFmt}${v2 ? separator + valFmt : \"\"}${displayUnit ? \" \" + displayUnit : \"\"}${postfix}`;\r\n            const args = v2 ? `${v1}.state, ${v2}.state` : `${v1}.state`;\r\n            lines.push(`        it.printf(${x}, ${y} + ${labelFS + 4}, id(${valueFontId}), ${color}, ${valueAlign}, \"${valFmtFull}\", ${args});`);\r\n        } else if (format === \"value_label\") {\r\n            const valFmtFull = `${prefix}${valFmt}${v2 ? separator + valFmt : \"\"}${displayUnit ? \" \" + displayUnit : \"\"}${postfix}`;\r\n            const args = v2 ? `${v1}.state, ${v2}.state` : `${v1}.state`;\r\n            lines.push(`        it.printf(${x}, ${y}, id(${valueFontId}), ${color}, ${valueAlign}, \"${valFmtFull}\", ${args});`);\r\n\r\n            const offset = Math.round(valueFS * 0.6 * 6) + 10; // Guessed value width\r\n            lines.push(`        it.printf(${x} + ${offset}, ${y}, id(${labelFontId}), ${color}, ${labelAlign}, \"${title}\");`);\r\n        }\r\n\r\n        if (cond) lines.push(`        }`);\r\n    },\r\n\r\n    onExportTextSensors: (context) => {\r\n        const { lines, widgets } = context;\r\n        if (!widgets) return;\r\n\r\n        const weatherEntities = new Set();\r\n        const textEntities = new Set();\r\n\r\n        for (const w of widgets) {\r\n            if (w.type !== \"sensor_text\") continue;\r\n\r\n            const p = w.props || {};\r\n            const entityId = (w.entity_id || \"\").trim();\r\n            if (entityId.startsWith(\"weather.\")) weatherEntities.add(entityId);\r\n            else if (p.is_text_sensor || entityId.startsWith(\"text_sensor.\")) textEntities.add(entityId);\r\n\r\n            const entityId2 = (w.entity_id_2 || p.entity_id_2 || \"\").trim();\r\n            if (entityId2) {\r\n                if (entityId2.startsWith(\"weather.\")) weatherEntities.add(entityId2);\r\n                else if (p.is_text_sensor || entityId2.startsWith(\"text_sensor.\")) textEntities.add(entityId2);\r\n            }\r\n        }\r\n\r\n        if (weatherEntities.size > 0) {\r\n            lines.push(\"# Weather Entity Sensors (Detected from Sensor Text)\");\r\n            for (const entityId of weatherEntities) {\r\n                const safeId = entityId.replace(/^weather\\./, \"\").replace(/\\./g, \"_\").replace(/-/g, \"_\");\r\n                lines.push(\"- platform: homeassistant\", `  id: ${safeId}`, `  entity_id: ${entityId}`, \"  internal: true\");\r\n            }\r\n        }\r\n\r\n        if (textEntities.size > 0) {\r\n            lines.push(\"# Text Sensors (Detected from Sensor Text)\");\r\n            for (const entityId of textEntities) {\r\n                const safeId = entityId.replace(/[^a-zA-Z0-9_]/g, \"_\") + \"_txt\";\r\n                lines.push(\"- platform: homeassistant\", `  id: ${safeId}`, `  entity_id: ${entityId}`, \"  internal: true\");\r\n            }\r\n        }\r\n    },\r\n\r\n    onExportNumericSensors: (context) => {\r\n        const { lines, widgets } = context;\r\n        if (!widgets) return;\r\n\r\n        const processed = new Set();\r\n        for (const w of widgets) {\r\n            if (w.type !== \"sensor_text\") continue;\r\n\r\n            const entityId = (w.entity_id || \"\").trim();\r\n            const p = w.props || {};\r\n            if (!entityId || p.is_local_sensor || p.is_text_sensor || entityId.startsWith(\"weather.\") || entityId.startsWith(\"text_sensor.\")) continue;\r\n\r\n            if (!processed.has(entityId)) {\r\n                processed.add(entityId);\r\n                const safeId = entityId.replace(/[^a-zA-Z0-9_]/g, \"_\");\r\n                lines.push(\"- platform: homeassistant\", `  id: ${safeId}`, `  entity_id: ${entityId}`, \"  internal: true\");\r\n            }\r\n        }\r\n    }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\shape_circle\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\shape_rect\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\template_nav_bar\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\template_sensor_bar\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\text\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getAlignX' is assigned a value but never used.","line":69,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":53,"suggestions":[{"messageId":"removeVar","data":{"varName":"getAlignX"},"fix":{"range":[2342,2353],"text":""},"desc":"Remove unused variable 'getAlignX'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'getAlignY' is assigned a value but never used.","line":69,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":64,"suggestions":[{"messageId":"removeVar","data":{"varName":"getAlignY"},"fix":{"range":[2353,2364],"text":""},"desc":"Remove unused variable 'getAlignY'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Text / Label Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"flex\";\r\n\r\n    const applyAlign = (align, element = el) => {\r\n        if (!align) return;\r\n        if (align.includes(\"LEFT\")) element.style.justifyContent = \"flex-start\";\r\n        else if (align.includes(\"RIGHT\")) element.style.justifyContent = \"flex-end\";\r\n        else element.style.justifyContent = \"center\";\r\n\r\n        if (align.includes(\"TOP\")) element.style.alignItems = \"flex-start\";\r\n        else if (align.includes(\"BOTTOM\")) element.style.alignItems = \"flex-end\";\r\n        else element.style.alignItems = \"center\";\r\n    };\r\n\r\n    applyAlign(props.text_align || \"TOP_LEFT\");\r\n\r\n    const body = document.createElement(\"div\");\r\n    body.style.color = getColorStyle(props.color);\r\n    body.style.fontSize = `${props.font_size || props.value_font_size || 20}px`;\r\n    body.style.fontFamily = (props.font_family || \"Roboto\") + \", sans-serif\";\r\n    body.style.fontWeight = String(props.font_weight || 400);\r\n    body.style.fontStyle = props.italic ? \"italic\" : \"normal\";\r\n    body.textContent = props.text || widget.title || \"Text\";\r\n\r\n    el.appendChild(body);\r\n};\r\n\r\nconst exportLVGL = (w, { common, convertColor, convertAlign, getLVGLFont, formatOpacity }) => {\r\n    const p = w.props || {};\r\n    return {\r\n        label: {\r\n            ...common,\r\n            text: `\"${p.text || 'Text'}\"`,\r\n            text_font: getLVGLFont(p.font_family, p.font_size, p.font_weight, p.italic),\r\n            text_color: convertColor(p.color || p.text_color),\r\n            text_align: convertAlign(p.text_align),\r\n            bg_color: p.bg_color === \"transparent\" ? undefined : convertColor(p.bg_color),\r\n            opa: formatOpacity(p.opa)\r\n        }\r\n    };\r\n};\r\n\r\nexport default {\r\n    id: \"text\", // also used for 'label'\r\n    name: \"Text\",\r\n    category: \"Core\",\r\n    defaults: {\r\n        text: \"Text\",\r\n        font_size: 20,\r\n        font_family: \"Roboto\",\r\n        color: \"black\",\r\n        font_weight: 400,\r\n        italic: false,\r\n        bpp: 1,\r\n        text_align: \"TOP_LEFT\",\r\n        bg_color: \"transparent\",\r\n        opa: 255\r\n    },\r\n    render,\r\n    exportLVGL,\r\n    export: (w, context) => {\r\n        const {\r\n            lines, getColorConst, addFont, getAlignX, getAlignY, getCondProps, getConditionCheck\r\n        } = context;\r\n\r\n        const p = w.props || {};\r\n        const color = getColorConst(p.color || \"black\");\r\n        const fontSize = p.font_size || p.value_font_size || 20;\r\n        const fontId = addFont(p.font_family || \"Roboto\", p.font_weight || 400, fontSize, p.italic);\r\n        const text = p.text || w.title || \"Text\";\r\n        const textAlign = p.text_align || \"TOP_LEFT\";\r\n\r\n        lines.push(`        // widget:text id:${w.id} type:text x:${w.x} y:${w.y} w:${w.width} h:${w.height} text:\"${text}\" ${getCondProps(w)}`);\r\n\r\n        const cond = getConditionCheck(w);\r\n        if (cond) lines.push(`        ${cond}`);\r\n\r\n        // Handle simple alignment for printf\r\n        let x = w.x;\r\n        let y = w.y;\r\n        let align = \"TextAlign::TOP_LEFT\";\r\n\r\n        if (textAlign.includes(\"CENTER\")) {\r\n            x = Math.round(w.x + w.width / 2);\r\n            align = \"TextAlign::TOP_CENTER\";\r\n        } else if (textAlign.includes(\"RIGHT\")) {\r\n            x = Math.round(w.x + w.width);\r\n            align = \"TextAlign::TOP_RIGHT\";\r\n        }\r\n\r\n        if (textAlign.includes(\"BOTTOM\")) {\r\n            y = Math.round(w.y + w.height);\r\n            align = align.replace(\"TOP_\", \"BOTTOM_\");\r\n        } else if (!textAlign.includes(\"TOP\")) {\r\n            // V-Center\r\n            y = Math.round(w.y + w.height / 2);\r\n            align = align.replace(\"TOP_\", \"CENTER_\");\r\n        }\r\n\r\n        lines.push(`        it.printf(${x}, ${y}, id(${fontId}), ${color}, ${align}, \"${text.replace(/\"/g, '\\\\\"')}\");`);\r\n\r\n        if (cond) lines.push(`        }`);\r\n    }\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\touch_area\\plugin.js","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":54,"column":76,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":54,"endColumn":77,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2363,2364],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2363,2363],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Touch Area Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n\r\n    el.style.backgroundColor = props.color || \"rgba(0, 0, 255, 0.2)\";\r\n    el.style.border = `1px dashed ${props.border_color || \"#0000ff\"}`;\r\n    el.style.display = \"flex\";\r\n    el.style.flexDirection = \"column\";\r\n    el.style.alignItems = \"center\";\r\n    el.style.justifyContent = \"center\";\r\n    el.style.color = props.icon_color ? getColorStyle(props.icon_color) : (props.border_color || \"#0000ff\");\r\n    el.style.fontSize = \"12px\";\r\n    el.style.fontWeight = \"bold\";\r\n    el.style.overflow = \"hidden\";\r\n\r\n    if (props.icon) {\r\n        const getChar = (code) => {\r\n            const c = (code || \"\").trim().replace(\"mdi:\", \"\").toUpperCase();\r\n            if (/^F[0-9A-F]{4}$/i.test(c)) {\r\n                const cp = 0xf0000 + parseInt(c.slice(1), 16);\r\n                return String.fromCodePoint(cp);\r\n            }\r\n            if (window.iconPickerData) {\r\n                const iconName = (code || \"\").trim().replace(\"mdi:\", \"\").toLowerCase();\r\n                const iconData = window.iconPickerData.find(idx => idx.name === iconName);\r\n                if (iconData) {\r\n                    const cp = 0xf0000 + parseInt(iconData.code.slice(1), 16);\r\n                    return String.fromCodePoint(cp);\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n\r\n        const normalChar = getChar(props.icon);\r\n        const pressedChar = props.icon_pressed ? getChar(props.icon_pressed) : null;\r\n\r\n        if (normalChar) {\r\n            const iconEl = document.createElement(\"span\");\r\n            iconEl.innerText = normalChar;\r\n            iconEl.style.fontFamily = \"MDI, system-ui, sans-serif\";\r\n            iconEl.style.fontSize = (props.icon_size || 40) + \"px\";\r\n            iconEl.style.lineHeight = \"1\";\r\n            iconEl.style.color = props.icon_color ? getColorStyle(props.icon_color) : (props.border_color || \"#0000ff\");\r\n            el.appendChild(iconEl);\r\n\r\n            if (pressedChar) {\r\n                el.style.cursor = \"pointer\";\r\n                el.addEventListener(\"mouseenter\", () => {\r\n                    iconEl.innerText = pressedChar;\r\n                    if (props.color && props.color.startsWith(\"rgba\")) {\r\n                        el.style.backgroundColor = props.color.replace(/[\\d\\.]+\\)$/, \"0.4)\");\r\n                    } else {\r\n                        el.style.backgroundColor = \"rgba(0, 0, 255, 0.4)\";\r\n                    }\r\n                });\r\n                el.addEventListener(\"mouseleave\", () => {\r\n                    iconEl.innerText = normalChar;\r\n                    el.style.backgroundColor = props.color || \"rgba(0, 0, 255, 0.2)\";\r\n                });\r\n            }\r\n\r\n            if (props.title && widget.height > (props.icon_size || 40) + 20) {\r\n                const lbl = document.createElement(\"div\");\r\n                lbl.innerText = props.title;\r\n                lbl.style.fontSize = \"10px\";\r\n                lbl.style.marginTop = \"2px\";\r\n                el.appendChild(lbl);\r\n            }\r\n        } else {\r\n            el.innerText = props.title || \"Touch Area\";\r\n        }\r\n    } else {\r\n        el.innerText = props.title || widget.entity_id || \"Touch Area\";\r\n    }\r\n};\r\n\r\nexport default {\r\n    id: \"touch_area\",\r\n    name: \"Touch Area\",\r\n    category: \"Controls\",\r\n    defaults: {\r\n        title: \"\",\r\n        icon: \"\",\r\n        icon_pressed: \"\",\r\n        icon_size: 40,\r\n        icon_color: \"\",\r\n        color: \"rgba(0, 0, 255, 0.15)\",\r\n        border_color: \"#0000ff\",\r\n        on_click: \"\"\r\n    },\r\n    render\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\weather_forecast\\plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'sanitize' is assigned a value but never used.","line":116,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":116,"endColumn":63,"suggestions":[{"messageId":"removeVar","data":{"varName":"sanitize"},"fix":{"range":[4835,4845],"text":""},"desc":"Remove unused variable 'sanitize'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Weather Forecast Plugin\r\n */\r\n\r\nconst render = (el, widget, { getColorStyle }) => {\r\n    const props = widget.props || {};\r\n    const layout = props.layout || \"horizontal\";\r\n    const days = Math.min(7, Math.max(1, parseInt(props.days, 10) || 5));\r\n    const iconSize = parseInt(props.icon_size, 10) || 32;\r\n    const tempFontSize = parseInt(props.temp_font_size, 10) || 14;\r\n    const dayFontSize = parseInt(props.day_font_size, 10) || 12;\r\n    const showHighLow = props.show_high_low !== false;\r\n    const colorStyle = getColorStyle(props.color || \"black\");\r\n    const fontFamily = (props.font_family || \"Roboto\") + \", sans-serif\";\r\n\r\n    const weatherIcons = [\r\n        { code: \"F0599\", condition: \"sunny\" },\r\n        { code: \"F0595\", condition: \"partlycloudy\" },\r\n        { code: \"F0597\", condition: \"rainy\" },\r\n        { code: \"F0590\", condition: \"cloudy\" },\r\n        { code: \"F0595\", condition: \"partlycloudy\" }\r\n    ];\r\n\r\n    const dayNames = [\"Today\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\r\n    const mockTemps = [\r\n        { high: 24, low: 18 },\r\n        { high: 20, low: 14 },\r\n        { high: 22, low: 15 },\r\n        { high: 19, low: 13 },\r\n        { high: 18, low: 12 },\r\n        { high: 21, low: 15 },\r\n        { high: 23, low: 16 }\r\n    ];\r\n\r\n    el.innerHTML = \"\";\r\n    el.style.display = \"flex\";\r\n    el.style.flexDirection = layout === \"vertical\" ? \"column\" : \"row\";\r\n    el.style.alignItems = \"flex-start\";\r\n    el.style.justifyContent = \"flex-start\";\r\n    el.style.gap = layout === \"vertical\" ? \"4px\" : \"0px\";\r\n    el.style.overflow = \"hidden\";\r\n    el.style.padding = \"4px\";\r\n    el.style.boxSizing = \"border-box\";\r\n\r\n    // Border and Background\r\n    el.style.backgroundColor = getColorStyle(props.background_color || \"transparent\");\r\n    if (props.show_border !== false) {\r\n        const borderW = props.border_width !== undefined ? props.border_width : 1;\r\n        const borderColor = getColorStyle(props.border_color || props.color || \"black\");\r\n        el.style.border = `${borderW}px solid ${borderColor}`;\r\n    } else {\r\n        el.style.border = \"none\";\r\n    }\r\n\r\n    const availableWidth = widget.width - (el.style.border !== \"none\" ? (parseInt(props.border_width || 1) * 2) : 0) - 8; // -8 for 4px padding on both sides\r\n    const availableHeight = widget.height - (el.style.border !== \"none\" ? (parseInt(props.border_width || 1) * 2) : 0) - 8;\r\n\r\n    const itemWidth = layout === \"horizontal\" ? Math.floor(availableWidth / days) : availableWidth;\r\n    const itemHeight = layout === \"vertical\" ? Math.floor(availableHeight / days) : availableHeight;\r\n\r\n    for (let i = 0; i < days; i++) {\r\n        const dayDiv = document.createElement(\"div\");\r\n        dayDiv.style.display = \"flex\";\r\n        dayDiv.style.flexDirection = \"column\";\r\n        dayDiv.style.alignItems = \"center\";\r\n        dayDiv.style.justifyContent = \"flex-start\";\r\n        dayDiv.style.width = `${itemWidth}px`;\r\n        dayDiv.style.minHeight = layout === \"vertical\" ? `${itemHeight}px` : \"auto\";\r\n        dayDiv.style.color = colorStyle;\r\n        dayDiv.style.fontFamily = fontFamily;\r\n\r\n        const dayLabel = document.createElement(\"div\");\r\n        dayLabel.style.fontSize = `${dayFontSize}px`;\r\n        dayLabel.style.fontWeight = \"400\";\r\n        dayLabel.style.marginBottom = \"2px\";\r\n        dayLabel.textContent = dayNames[i] || `D${i}`;\r\n        dayDiv.appendChild(dayLabel);\r\n\r\n        const iconDiv = document.createElement(\"div\");\r\n        const iconData = weatherIcons[i % weatherIcons.length];\r\n        const cp = 0xf0000 + parseInt(iconData.code.slice(1), 16);\r\n        iconDiv.innerText = String.fromCodePoint(cp);\r\n        iconDiv.style.fontSize = `${iconSize}px`;\r\n        iconDiv.style.fontFamily = \"MDI, system-ui, -apple-system, BlinkMacSystemFont, sans-serif\";\r\n        iconDiv.style.lineHeight = \"1.1\";\r\n        dayDiv.appendChild(iconDiv);\r\n\r\n        const tempDiv = document.createElement(\"div\");\r\n        tempDiv.style.fontSize = `${tempFontSize}px`;\r\n        tempDiv.style.fontWeight = \"400\";\r\n        const temp = mockTemps[i % mockTemps.length];\r\n        if (showHighLow) {\r\n            tempDiv.textContent = `${temp.high}┬░/${temp.low}┬░`;\r\n        } else {\r\n            tempDiv.textContent = `${temp.high}┬░`;\r\n        }\r\n        dayDiv.appendChild(tempDiv);\r\n\r\n        el.appendChild(dayDiv);\r\n    }\r\n\r\n    if (!widget.entity_id) {\r\n        const warning = document.createElement(\"div\");\r\n        warning.style.position = \"absolute\";\r\n        warning.style.bottom = \"2px\";\r\n        warning.style.right = \"4px\";\r\n        warning.style.fontSize = \"9px\";\r\n        warning.style.color = \"#888\";\r\n        warning.textContent = \"ÔÜá No weather entity\";\r\n        el.appendChild(warning);\r\n    }\r\n};\r\n\r\nconst exportDoc = (w, context) => {\r\n    const {\r\n        lines, addFont, getColorConst, addDitherMask, sanitize, getCondProps, getConditionCheck, isEpaper\r\n    } = context;\r\n\r\n    const p = w.props || {};\r\n    const weatherEntity = w.entity_id || p.weather_entity || \"weather.forecast_home\";\r\n    const layout = p.layout || \"horizontal\";\r\n    const showHighLow = p.show_high_low !== false;\r\n    const dayFontSize = parseInt(String(p.day_font_size || 12), 10);\r\n    const tempFontSize = parseInt(String(p.temp_font_size || 14), 10);\r\n    const iconSize = parseInt(String(p.icon_size || 32), 10);\r\n    const fontFamily = p.font_family || \"Roboto\";\r\n    const colorProp = p.color || \"black\";\r\n    const color = getColorConst(colorProp);\r\n\r\n    const dayFontId = addFont(fontFamily, 700, dayFontSize);\r\n    const tempFontId = addFont(fontFamily, 400, tempFontSize);\r\n    const iconFontId = addFont(\"Material Design Icons\", 400, iconSize);\r\n\r\n    lines.push(`        // widget:weather_forecast id:${w.id} type:weather_forecast x:${w.x} y:${w.y} w:${w.width} h:${w.height} weather_entity:\"${weatherEntity}\" layout:${layout} show_high_low:${showHighLow} day_font_size:${dayFontSize} temp_font_size:${tempFontSize} icon_size:${iconSize} font_family:\"${fontFamily}\" color:${colorProp} ${getCondProps(w)}`);\r\n\r\n    const condFore = getConditionCheck(w);\r\n    if (condFore) lines.push(`        ${condFore}`);\r\n\r\n    lines.push(`        {`);\r\n    lines.push(`          static std::map<std::string, const char*> weather_icons = {`);\r\n    lines.push(`            {\"clear-night\", \"\\\\U000F0594\"}, {\"cloudy\", \"\\\\U000F0590\"},`);\r\n    lines.push(`            {\"exceptional\", \"\\\\U000F0026\"}, {\"fog\", \"\\\\U000F0591\"},`);\r\n    lines.push(`            {\"hail\", \"\\\\U000F0592\"}, {\"lightning\", \"\\\\U000F0593\"},`);\r\n    lines.push(`            {\"lightning-rainy\", \"\\\\U000F067E\"}, {\"partlycloudy\", \"\\\\U000F0595\"},`);\r\n    lines.push(`            {\"pouring\", \"\\\\U000F0596\"}, {\"rainy\", \"\\\\U000F0597\"},`);\r\n    lines.push(`            {\"snowy\", \"\\\\U000F0598\"}, {\"snowy-rainy\", \"\\\\U000F067F\"},`);\r\n    lines.push(`            {\"sunny\", \"\\\\U000F0599\"}, {\"windy\", \"\\\\U000F059D\"},`);\r\n    lines.push(`            {\"windy-variant\", \"\\\\U000F059E\"}`);\r\n    lines.push(`          };`);\r\n    lines.push(`          auto get_icon = [&](const std::string& cond_val) -> const char* {`);\r\n    lines.push(`            return weather_icons.count(cond_val) ? weather_icons[cond_val] : \"\\\\U000F0590\";`);\r\n    lines.push(`          };`);\r\n    lines.push(`          auto get_day_name = [](int offset) -> std::string {`);\r\n    lines.push(`            if (offset == 0) return \"Today\";`);\r\n    lines.push(`            auto t = id(ha_time).now();`);\r\n    lines.push(`            if (!t.is_valid()) return \"---\";`);\r\n    lines.push(`            ESPTime future = ESPTime::from_epoch_local(t.timestamp + (offset * 86400));`);\r\n    lines.push(`            char buf[8]; future.strftime(buf, sizeof(buf), \"%a\");`);\r\n    lines.push(`            return std::string(buf);`);\r\n    lines.push(`          };`);\r\n\r\n    const isHorizontal = layout === \"horizontal\";\r\n    const xInc = isHorizontal ? Math.floor(w.width / 5) : 0;\r\n    const yInc = isHorizontal ? 0 : Math.floor(w.height / 5);\r\n    const centerOffset = isHorizontal ? Math.floor(xInc / 2) : Math.floor(w.width / 2);\r\n\r\n    for (let day = 0; day < 5; day++) {\r\n        const condSensorId = `weather_cond_day${day}`;\r\n        const highSensorId = `weather_high_day${day}`;\r\n        const lowSensorId = `weather_low_day${day}`;\r\n        const dayX = w.x + day * xInc;\r\n        const dayY = w.y + day * yInc;\r\n\r\n        lines.push(`          {`);\r\n        lines.push(`            int dx = ${dayX}; int dy = ${dayY};`);\r\n        lines.push(`            it.printf(dx + ${centerOffset}, dy, id(${dayFontId}), ${color}, TextAlign::TOP_CENTER, \"%s\", get_day_name(${day}).c_str());`);\r\n        lines.push(`            std::string cond_day = id(${condSensorId}).state;`);\r\n        lines.push(`            it.printf(dx + ${centerOffset}, dy + ${dayFontSize + 4}, id(${iconFontId}), ${color}, TextAlign::TOP_CENTER, \"%s\", get_icon(cond_day));`);\r\n        if (showHighLow) {\r\n            lines.push(`            float high = id(${highSensorId}).state; float low = id(${lowSensorId}).state;`);\r\n            lines.push(`            if (!std::isnan(high) && !std::isnan(low)) {`);\r\n            lines.push(`              it.printf(dx + ${centerOffset}, dy + ${dayFontSize + iconSize + 8}, id(${tempFontId}), ${color}, TextAlign::TOP_CENTER, \"%.0f/%.0f\", high, low);`);\r\n            lines.push(`            }`);\r\n        }\r\n        lines.push(`          }`);\r\n    }\r\n\r\n    addDitherMask(lines, colorProp, isEpaper, w.x, w.y, w.width, w.height);\r\n    lines.push(`        }`);\r\n    if (condFore) lines.push(`        }`);\r\n};\r\n\r\nconst onExportNumericSensors = (context) => {\r\n    const { lines, widgets } = context;\r\n    const hasWeather = widgets.some(w => w.type === \"weather_forecast\");\r\n\r\n    if (hasWeather) {\r\n        lines.push(\"\");\r\n        lines.push(\"  # Weather Forecast High/Low Sensors\");\r\n        for (let day = 0; day < 5; day++) {\r\n            lines.push(`  - platform: homeassistant`);\r\n            lines.push(`    id: weather_high_day${day}`);\r\n            lines.push(`    entity_id: sensor.weather_forecast_day_${day}_high`);\r\n            lines.push(`    internal: true`);\r\n            lines.push(`  - platform: homeassistant`);\r\n            lines.push(`    id: weather_low_day${day}`);\r\n            lines.push(`    entity_id: sensor.weather_forecast_day_${day}_low`);\r\n            lines.push(`    internal: true`);\r\n        }\r\n    }\r\n};\r\n\r\nconst onExportTextSensors = (context) => {\r\n    const { lines, widgets } = context;\r\n    const targets = widgets.filter(w => w.type === \"weather_forecast\");\r\n    if (targets.length === 0) return;\r\n\r\n    const weatherEntity = targets[0].entity_id || targets[0].props?.weather_entity || \"weather.forecast_home\";\r\n\r\n    lines.push(\"\");\r\n    lines.push(\"  # Weather Forecast Condition Sensors\");\r\n    for (let day = 0; day < 5; day++) {\r\n        lines.push(`  - platform: homeassistant`);\r\n        lines.push(`    id: weather_cond_day${day}`);\r\n        lines.push(`    entity_id: sensor.weather_forecast_day_${day}_condition`);\r\n        lines.push(`    internal: true`);\r\n    }\r\n\r\n    lines.push(\"\");\r\n    lines.push(\"# ============================================================================\");\r\n    lines.push(\"# HOME ASSISTANT TEMPLATE SENSORS\");\r\n    lines.push(\"# Add these template sensors to your Home Assistant configuration.yaml:\");\r\n    lines.push(\"# ============================================================================\");\r\n    lines.push(\"#\");\r\n    lines.push(\"# template:\");\r\n    lines.push(\"#   - trigger:\");\r\n    lines.push(\"#       - trigger: state\");\r\n    lines.push(`#         entity_id: ${weatherEntity}`);\r\n    lines.push(\"#       - trigger: time_pattern\");\r\n    lines.push(\"#         hours: \\\"/1\\\"\");\r\n    lines.push(\"#     action:\");\r\n    lines.push(\"#       - action: weather.get_forecasts\");\r\n    lines.push(\"#         target:\");\r\n    lines.push(`#           entity_id: ${weatherEntity}`);\r\n    lines.push(\"#         data:\");\r\n    lines.push(\"#           type: daily\");\r\n    lines.push(\"#         response_variable: forecast_data\");\r\n    lines.push(\"#     sensor:\");\r\n    for (let day = 0; day < 5; day++) {\r\n        lines.push(`#       - name: 'Weather Forecast Day ${day} High'`);\r\n        lines.push(`#         unique_id: weather_forecast_day_${day}_high`);\r\n        lines.push(`#         unit_of_measurement: '┬░C'`);\r\n        lines.push(`#         state: '{{ forecast_data[\"${weatherEntity}\"].forecast[${day}].temperature | default(\"N/A\") }}'`);\r\n        lines.push(`#       - name: 'Weather Forecast Day ${day} Low'`);\r\n        lines.push(`#         unique_id: weather_forecast_day_${day}_low`);\r\n        lines.push(`#         unit_of_measurement: '┬░C'`);\r\n        lines.push(`#         state: '{{ forecast_data[\"${weatherEntity}\"].forecast[${day}].templow | default(\"N/A\") }}'`);\r\n        lines.push(`#       - name: 'Weather Forecast Day ${day} Condition'`);\r\n        lines.push(`#         unique_id: weather_forecast_day_${day}_condition`);\r\n        lines.push(`#         state: '{{ forecast_data[\"${weatherEntity}\"].forecast[${day}].condition | default(\"cloudy\") }}'`);\r\n    }\r\n    lines.push(\"#\");\r\n    lines.push(\"# ============================================================================\");\r\n};\r\n\r\nexport default {\r\n    id: \"weather_forecast\",\r\n    name: \"Weather Forecast\",\r\n    category: \"Sensors\",\r\n    defaults: {\r\n        days: 5,\r\n        layout: \"horizontal\",\r\n        icon_size: 32,\r\n        temp_font_size: 14,\r\n        day_font_size: 12,\r\n        color: \"black\",\r\n        font_family: \"Roboto\",\r\n        show_high_low: true,\r\n        show_border: false,\r\n        border_width: 1,\r\n        border_color: \"black\",\r\n        background_color: \"white\",\r\n        width: 370,\r\n        height: 90\r\n    },\r\n    render,\r\n    export: exportDoc,\r\n    onExportNumericSensors,\r\n    onExportTextSensors\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\weather_icon\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\features\\wifi_signal\\plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\canvas.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'clearSnapGuides' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":25,"suggestions":[{"messageId":"removeVar","data":{"varName":"clearSnapGuides"},"fix":{"range":[373,389],"text":""},"desc":"Remove unused variable 'clearSnapGuides'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'addSnapGuideVertical' is defined but never used.","line":6,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"addSnapGuideVertical"},"fix":{"range":[388,410],"text":""},"desc":"Remove unused variable 'addSnapGuideVertical'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'addSnapGuideHorizontal' is defined but never used.","line":6,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":71,"suggestions":[{"messageId":"removeVar","data":{"varName":"addSnapGuideHorizontal"},"fix":{"range":[410,434],"text":""},"desc":"Remove unused variable 'addSnapGuideHorizontal'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'getSnapLines' is defined but never used.","line":6,"column":73,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":85,"suggestions":[{"messageId":"removeVar","data":{"varName":"getSnapLines"},"fix":{"range":[434,448],"text":""},"desc":"Remove unused variable 'getSnapLines'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'applySnapToPosition' is defined but never used.","line":6,"column":87,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":106,"suggestions":[{"messageId":"removeVar","data":{"varName":"applySnapToPosition"},"fix":{"range":[448,469],"text":""},"desc":"Remove unused variable 'applySnapToPosition'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from './state.js';\nimport { on, EVENTS } from './events.js';\nimport { render, applyZoom } from './canvas_renderer.js';\nimport { setupInteractions, setupPanning, setupZoomControls, setupDragAndDrop, zoomIn, zoomOut, zoomReset, onMouseMove, onMouseUp } from './canvas_interactions.js';\nimport { setupTouchInteractions } from './canvas_touch.js';\nimport { clearSnapGuides, addSnapGuideVertical, addSnapGuideHorizontal, getSnapLines, applySnapToPosition } from './canvas_snap.js';\n\nexport class Canvas {\n    constructor() {\n        this.canvas = document.getElementById(\"canvas\");\n        this.canvasContainer = document.getElementById(\"canvasContainer\");\n        this.viewport = document.querySelector(\".canvas-viewport\");\n        this.dragState = null;\n        this.panX = 0;\n        this.panY = 0;\n\n        // Touch state for mobile devices\n        this.touchState = null;    // Single-touch widget drag state\n        this.pinchState = null;    // Two-finger pinch/pan state\n        this.lastTapTime = 0;      // Double-tap detection\n\n        // Helper bindings for listeners that need removal reference\n        // (Though interactions module manages them via direct reference or stored props)\n        this._boundMouseMove = (ev) => onMouseMove(ev, this);\n        this._boundMouseUp = (ev) => onMouseUp(ev, this);\n\n        this.init();\n    }\n\n    init() {\n        // Subscribe to events\n        on(EVENTS.STATE_CHANGED, () => this.render());\n        on(EVENTS.PAGE_CHANGED, () => this.render());\n        on(EVENTS.SELECTION_CHANGED, () => this.render());\n        on(EVENTS.SETTINGS_CHANGED, () => {\n            this.render();\n            this.applyZoom();\n        });\n        on(EVENTS.ZOOM_CHANGED, () => this.applyZoom());\n\n        this.setupInteractions();\n        this.render();\n        this.applyZoom();\n\n        // Start a 1-second interval to update time-dependent widgets (like datetime)\n        if (this.updateInterval) clearInterval(this.updateInterval);\n        this.updateInterval = setInterval(() => {\n            // SKIP auto-render during active interaction to prevent DOM detachment\n            if (this.touchState || this.pinchState || this.dragState || this.panState) return;\n\n            // Only re-render if there is a datetime widget on the current page to avoid unnecessary overhead\n            const page = AppState.getCurrentPage();\n            if (page && page.widgets.some(w => w.type === 'datetime')) {\n                this.render();\n            }\n        }, 1000);\n    }\n\n    // --- Delegation Methods ---\n\n    render() {\n        render(this);\n    }\n\n    applyZoom() {\n        applyZoom(this);\n    }\n\n    setupInteractions() {\n        setupPanning(this);\n        setupInteractions(this);\n        setupZoomControls(this);\n        setupDragAndDrop(this);\n        setupTouchInteractions(this);\n    }\n\n    // Exposed methods for external callers (if any) or internal use\n    zoomIn() { zoomIn(); }\n    zoomOut() { zoomOut(); }\n    zoomReset() { zoomReset(this); }\n\n    /**\n     * Clean up resources when destroying the canvas.\n     */\n    destroy() {\n        // Stop the update interval\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n\n        // Remove event subscriptions if they were stored...\n        // Note: The current event system (mitt-like) might not return unsubscribe functions directly\n        // in the simple `on()` wrapper unless verified.\n        // Assuming we rely on page refresh for now, but good practice to clear timers.\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\canvas_interactions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\canvas_renderer.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":222,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":222,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from './state.js';\r\nimport { registry as FeatureRegistry } from './plugin_registry.js';\r\nimport { Logger } from '../utils/logger.js';\r\nimport { getColorStyle } from '../utils/device.js';\r\n\r\nexport function render(canvasInstance) {\r\n    if (!canvasInstance.canvas) return;\r\n\r\n    const page = AppState.getCurrentPage();\r\n    const existingGrid = canvasInstance.canvas.querySelector(\".canvas-grid\");\r\n    const existingGuides = canvasInstance.canvas.querySelectorAll(\".snap-guide\");\r\n    const existingLasso = canvasInstance.canvas.querySelector(\".lasso-selection\");\r\n\r\n    canvasInstance.canvas.innerHTML = \"\";\r\n\r\n    // Ensure grid exists if enabled\r\n    if (AppState.showGrid) {\r\n        let grid = existingGrid;\r\n        if (!grid) {\r\n            grid = document.createElement(\"div\");\r\n            grid.className = \"canvas-grid\";\r\n        }\r\n        canvasInstance.canvas.appendChild(grid);\r\n    }\r\n\r\n    existingGuides.forEach((g) => canvasInstance.canvas.appendChild(g));\r\n    if (existingLasso) canvasInstance.canvas.appendChild(existingLasso);\r\n\r\n    // Apply orientation/size\r\n    const dims = AppState.getCanvasDimensions();\r\n    canvasInstance.canvas.style.width = `${dims.width}px`;\r\n    canvasInstance.canvas.style.height = `${dims.height}px`;\r\n\r\n    // Apply device shape (e.g. round)\r\n    const shape = AppState.getCanvasShape();\r\n\r\n    if (shape === \"round\") {\r\n        canvasInstance.canvas.style.borderRadius = \"50%\";\r\n        canvasInstance.canvas.style.overflow = \"hidden\";\r\n        canvasInstance.canvas.style.boxShadow = \"0 0 0 10px rgba(0,0,0,0.1)\"; // Optional: hint at the bezel\r\n    } else {\r\n        canvasInstance.canvas.style.borderRadius = \"0\";\r\n        canvasInstance.canvas.style.overflow = \"visible\";\r\n        canvasInstance.canvas.style.boxShadow = \"none\";\r\n    }\r\n\r\n    // Apply dark mode/theme\r\n    if (AppState.settings.editor_light_mode) {\r\n        canvasInstance.canvas.classList.add(\"light-mode\");\r\n    } else {\r\n        canvasInstance.canvas.classList.remove(\"light-mode\");\r\n    }\r\n\r\n    // Apply black background mode for canvas preview (per-page overrides global)\r\n    const effectiveDarkMode = getEffectiveDarkMode();\r\n    if (effectiveDarkMode) {\r\n        canvasInstance.canvas.classList.add(\"dark\");\r\n        if (canvasInstance.viewport) canvasInstance.viewport.classList.add(\"device-dark-mode\");\r\n    } else {\r\n        canvasInstance.canvas.classList.remove(\"dark\");\r\n        if (canvasInstance.viewport) canvasInstance.viewport.classList.remove(\"device-dark-mode\");\r\n    }\r\n\r\n    // Render LVGL grid overlay if page has grid layout\r\n    if (page && page.layout && /^\\d+x\\d+$/.test(page.layout)) {\r\n        renderLvglGridOverlay(canvasInstance, page.layout, dims, effectiveDarkMode);\r\n    }\r\n\r\n    if (!page) return;\r\n\r\n    for (const widget of page.widgets) {\r\n        const el = document.createElement(\"div\");\r\n        el.className = \"widget\";\r\n        el.style.left = widget.x + \"px\";\r\n        el.style.top = widget.y + \"px\";\r\n        el.style.width = widget.width + \"px\";\r\n        el.style.height = widget.height + \"px\";\r\n        el.dataset.id = widget.id;\r\n\r\n        // Accessibility\r\n        el.role = \"region\";\r\n        const widgetLabel = widget.title || widget.id;\r\n        el.setAttribute(\"aria-label\", `${widget.type} widget: ${widgetLabel}`);\r\n        el.title = `${widget.type} (${widgetLabel})`;\r\n\r\n        if (AppState.selectedWidgetIds.includes(widget.id)) {\r\n            el.classList.add(\"active\");\r\n        }\r\n\r\n        if (widget.locked) {\r\n            el.classList.add(\"locked\");\r\n        }\r\n\r\n        if (widget.hidden) {\r\n            el.classList.add(\"hidden-widget\");\r\n        }\r\n\r\n        const type = (widget.type || \"\").toLowerCase();\r\n\r\n        // Feature Registry Integration\r\n        const feature = FeatureRegistry ? FeatureRegistry.get(type) : null;\r\n        if (feature && feature.render) {\r\n            try {\r\n                // Wrap getColorStyle to be theme-aware\r\n                const wrappedGetColorStyle = (color) => {\r\n                    const pageTheme = getEffectiveDarkMode() ? 'dark' : 'light';\r\n                    if (!color) {\r\n                        return pageTheme === 'dark' ? '#ffffff' : '#000000';\r\n                    }\r\n                    return getColorStyle(color);\r\n                };\r\n                feature.render(el, widget, { getColorStyle: wrappedGetColorStyle });\r\n            } catch (err) {\r\n                Logger.error(`[Canvas] Error rendering widget '${widget.id}' (${type}):`, err);\r\n                el.textContent = `Error: ${type}`;\r\n                el.style.border = \"2px solid red\";\r\n                el.style.backgroundColor = \"rgba(255,0,0,0.1)\";\r\n                el.style.display = \"flex\";\r\n                el.style.alignItems = \"center\";\r\n                el.style.justifyContent = \"center\";\r\n            }\r\n            addResizeHandle(el);\r\n            canvasInstance.canvas.appendChild(el);\r\n            continue;\r\n        } else if (FeatureRegistry) {\r\n            // If not found, try to load it asynchronously\r\n            FeatureRegistry.load(type).then(loadedFeature => {\r\n                if (loadedFeature) {\r\n                    Logger.log(`[Canvas] Feature '${type}' loaded, triggering re-render.`);\r\n                    // Ideally we call render again, but we need access to the instance method or pass the instance\r\n                    // Since we have canvasInstance passed in, we can call the main render method on it \r\n                    // IF canvasInstance has a render method delegating to this, OR we recurse.\r\n                    // To avoid infinite loops or complexity, we'll try to call a method on the instance if it exists, \r\n                    // or just re-run this export.\r\n                    if (typeof canvasInstance.render === 'function') {\r\n                        canvasInstance.render();\r\n                    } else {\r\n                        render(canvasInstance);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Debug: log when falling back to legacy\r\n            Logger.warn(`[Canvas] No FeatureRegistry render for type '${type}', using legacy while loading...`);\r\n        } else {\r\n            Logger.error(`[Canvas] FeatureRegistry not defined!`);\r\n        }\r\n\r\n        // Fallback for missing or failing features\r\n        if (!feature || (feature && !feature.render)) {\r\n            // Display Missing Plugin Error\r\n            el.innerText = `Missing Plugin: ${type}`;\r\n            el.style.display = \"flex\";\r\n            el.style.alignItems = \"center\";\r\n            el.style.justifyContent = \"center\";\r\n            el.style.fontSize = \"10px\";\r\n            el.style.color = \"red\";\r\n            el.style.border = \"1px dashed red\";\r\n            el.style.backgroundColor = \"rgba(255, 0, 0, 0.05)\";\r\n            el.style.overflow = \"hidden\";\r\n            el.style.textAlign = \"center\";\r\n\r\n            addResizeHandle(el);\r\n            canvasInstance.canvas.appendChild(el);\r\n        }\r\n    }\r\n}\r\n\r\nexport function applyZoom(canvasInstance) {\r\n    const zoom = AppState.zoomLevel;\r\n    const dims = AppState.getCanvasDimensions();\r\n    const settings = AppState.settings;\r\n\r\n    if (canvasInstance.canvas) {\r\n        canvasInstance.canvas.style.transform = `scale(${zoom})`;\r\n        // Change transform origin to 0 0 for predictable scrolling container\r\n        canvasInstance.canvas.style.transformOrigin = \"0 0\";\r\n    }\r\n\r\n    if (canvasInstance.canvasContainer) {\r\n        // Apply panning via transform on the container\r\n        canvasInstance.canvasContainer.style.transform = `translate(${canvasInstance.panX}px, ${canvasInstance.panY}px)`;\r\n\r\n        // Force the container to match the scaled size so parents overflow correctly\r\n        canvasInstance.canvasContainer.style.width = (dims.width * zoom) + \"px\";\r\n        canvasInstance.canvasContainer.style.height = (dims.height * zoom) + \"px\";\r\n    }\r\n\r\n    // Apply grid opacity\r\n    const opacity = (settings.grid_opacity !== undefined ? settings.grid_opacity : 8) / 100;\r\n    document.documentElement.style.setProperty('--grid-opacity', opacity.toString());\r\n\r\n    // Update zoom level display\r\n    const zoomLevelEl = document.getElementById(\"zoomLevel\");\r\n    if (zoomLevelEl) {\r\n        zoomLevelEl.textContent = Math.round(zoom * 100) + \"%\";\r\n    }\r\n}\r\n\r\nexport function updateWidgetDOM(canvasInstance, widget) {\r\n    if (!widget || !widget.id) return;\r\n    const el = canvasInstance.canvas.querySelector(`.widget[data-id=\"${widget.id}\"]`);\r\n    if (el) {\r\n        el.style.left = widget.x + \"px\";\r\n        el.style.top = widget.y + \"px\";\r\n        el.style.width = widget.width + \"px\";\r\n        el.style.height = widget.height + \"px\";\r\n\r\n        // Re-render plugin logic for real-time updates (e.g. font-size in icons)\r\n        const type = (widget.type || \"\").toLowerCase();\r\n        const feature = FeatureRegistry ? FeatureRegistry.get(type) : null;\r\n        if (feature && feature.render) {\r\n            try {\r\n                const wrappedGetColorStyle = (color) => {\r\n                    const pageTheme = getEffectiveDarkMode() ? 'dark' : 'light';\r\n                    if (!color) {\r\n                        return pageTheme === 'dark' ? '#ffffff' : '#000000';\r\n                    }\r\n                    return getColorStyle(color);\r\n                };\r\n                feature.render(el, widget, { getColorStyle: wrappedGetColorStyle });\r\n            } catch (err) {\r\n                // Silent fail for minor real-time updates to keep performance high\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function getEffectiveDarkMode() {\r\n    const page = AppState.getCurrentPage();\r\n    const pageDarkMode = page?.dark_mode;\r\n\r\n    // \"inherit\" or undefined = use global setting\r\n    // \"dark\" = force dark mode\r\n    // \"light\" = force light mode\r\n    if (pageDarkMode === \"dark\") return true;\r\n    if (pageDarkMode === \"light\") return false;\r\n    return !!AppState.settings.dark_mode;\r\n}\r\n\r\nfunction renderLvglGridOverlay(canvasInstance, layout, dims, isDark) {\r\n    const match = layout.match(/^(\\d+)x(\\d+)$/);\r\n    if (!match) return;\r\n\r\n    const rows = parseInt(match[1], 10);\r\n    const cols = parseInt(match[2], 10);\r\n\r\n    // Create grid container\r\n    const gridOverlay = document.createElement(\"div\");\r\n    gridOverlay.className = \"lvgl-grid-overlay\";\r\n    gridOverlay.style.cssText = `\r\n        position: absolute;\r\n        top: 0; left: 0; right: 0; bottom: 0;\r\n        display: grid;\r\n        grid-template-rows: repeat(${rows}, 1fr);\r\n        grid-template-columns: repeat(${cols}, 1fr);\r\n        pointer-events: none;\r\n        z-index: 1;\r\n    `;\r\n\r\n    const lineColor = isDark ? \"rgba(255,255,255,0.2)\" : \"rgba(0,0,0,0.15)\";\r\n    const labelColor = isDark ? \"rgba(255,255,255,0.5)\" : \"rgba(0,0,0,0.4)\";\r\n\r\n    // Create grid cells with labels\r\n    for (let r = 0; r < rows; r++) {\r\n        for (let c = 0; c < cols; c++) {\r\n            const cell = document.createElement(\"div\");\r\n            cell.style.cssText = `\r\n                border: 1px dashed ${lineColor};\r\n                position: relative;\r\n                box-sizing: border-box;\r\n            `;\r\n\r\n            // Add label in top-left corner\r\n            const label = document.createElement(\"span\");\r\n            label.textContent = `${r},${c}`;\r\n            label.style.cssText = `\r\n                position: absolute;\r\n                top: 2px; left: 4px;\r\n                font-size: 10px;\r\n                color: ${labelColor};\r\n                font-family: monospace;\r\n                pointer-events: none;\r\n            `;\r\n            cell.appendChild(label);\r\n            gridOverlay.appendChild(cell);\r\n        }\r\n    }\r\n\r\n    canvasInstance.canvas.appendChild(gridOverlay);\r\n}\r\n\r\nfunction addResizeHandle(el) {\r\n    const handle = document.createElement(\"div\");\r\n    handle.className = \"widget-resize-handle\";\r\n    el.appendChild(handle);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\canvas_snap.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\canvas_touch.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Logger' is defined but never used.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"Logger"},"fix":{"range":[40,84],"text":""},"desc":"Remove unused variable 'Logger'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'updateWidgetDOM' is defined but never used.","line":5,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"updateWidgetDOM"},"fix":{"range":[247,264],"text":""},"desc":"Remove unused variable 'updateWidgetDOM'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from './state.js';\r\nimport { Logger } from '../utils/logger.js';\r\nimport { emit, EVENTS } from './events.js';\r\nimport { snapToGridCell, applySnapToPosition, clearSnapGuides } from './canvas_snap.js';\r\nimport { render, applyZoom, updateWidgetDOM } from './canvas_renderer.js';\r\n\r\nexport function setupTouchInteractions(canvasInstance) {\r\n    if (!canvasInstance.canvas || !canvasInstance.canvasContainer) return;\r\n\r\n    // Touch start on canvas (for widget interaction and panning)\r\n    canvasInstance.canvas.addEventListener(\"touchstart\", (ev) => {\r\n        const touches = ev.touches;\r\n\r\n        if (touches.length === 2) {\r\n            // Two-finger: start pinch/pan mode\r\n            ev.preventDefault();\r\n            canvasInstance.pinchState = {\r\n                startDistance: getTouchDistance(touches[0], touches[1]),\r\n                startZoom: AppState.zoomLevel,\r\n                startPanX: canvasInstance.panX,\r\n                startPanY: canvasInstance.panY,\r\n                startCenterX: (touches[0].clientX + touches[1].clientX) / 2,\r\n                startCenterY: (touches[0].clientY + touches[1].clientY) / 2\r\n            };\r\n            canvasInstance.touchState = null;\r\n            return;\r\n        }\r\n\r\n        if (touches.length === 1) {\r\n            const touch = touches[0];\r\n            const widgetEl = touch.target.closest(\".widget\");\r\n\r\n            // START LONG PRESS TIMER\r\n            if (canvasInstance.longPressTimer) clearTimeout(canvasInstance.longPressTimer);\r\n            canvasInstance.longPressTimer = setTimeout(() => {\r\n                const widgetId = widgetEl ? widgetEl.dataset.id : null;\r\n                if (window.RadialMenu) {\r\n                    window.RadialMenu.show(touch.clientX, touch.clientY, widgetId);\r\n                }\r\n                canvasInstance.touchState = null; // Cancel move/resize if menu opens\r\n            }, 600); // 600ms for long press\r\n\r\n            if (widgetEl) {\r\n                // TOUCHING A WIDGET: Prepare for direct manipulation\r\n                // We DO NOT call selectWidget here to avoid a re-render that would \r\n                // detach the element from the touch stream.\r\n                ev.preventDefault();\r\n\r\n                const widgetId = widgetEl.dataset.id;\r\n                const widget = AppState.getWidgetById(widgetId);\r\n                if (!widget) return;\r\n\r\n                const isResizeHandle = touch.target.classList.contains(\"widget-resize-handle\");\r\n\r\n                if (isResizeHandle) {\r\n                    canvasInstance.touchState = {\r\n                        mode: \"resize\",\r\n                        id: widgetId,\r\n                        startX: touch.clientX,\r\n                        startY: touch.clientY,\r\n                        startW: widget.width,\r\n                        startH: widget.height,\r\n                        el: widgetEl\r\n                    };\r\n                } else {\r\n                    canvasInstance.touchState = {\r\n                        mode: \"move\",\r\n                        id: widgetId,\r\n                        startTouchX: touch.clientX,\r\n                        startTouchY: touch.clientY,\r\n                        startWidgetX: widget.x,\r\n                        startWidgetY: widget.y,\r\n                        hasMoved: false,\r\n                        el: widgetEl\r\n                    };\r\n                }\r\n\r\n                window.addEventListener(\"touchmove\", (ev) => onTouchMove(ev, canvasInstance), { passive: false });\r\n                window.addEventListener(\"touchend\", (ev) => onTouchEnd(ev, canvasInstance));\r\n                window.addEventListener(\"touchcancel\", (ev) => onTouchEnd(ev, canvasInstance));\r\n\r\n            } else {\r\n                // TOUCHING EMPTY CANVAS: Pan or double-tap zoom reset\r\n                const now = Date.now();\r\n                if (now - canvasInstance.lastTapTime < 300) {\r\n                    // Zoom Reset logic inline or call exposed method\r\n                    AppState.setZoomLevel(1.0);\r\n                    canvasInstance.panX = 0;\r\n                    canvasInstance.panY = 0;\r\n                    applyZoom(canvasInstance);\r\n\r\n                    canvasInstance.lastTapTime = 0;\r\n                    ev.preventDefault();\r\n                    return;\r\n                }\r\n                canvasInstance.lastTapTime = now;\r\n\r\n                ev.preventDefault();\r\n                canvasInstance.touchState = {\r\n                    mode: \"pan\",\r\n                    startTouchX: touch.clientX,\r\n                    startTouchY: touch.clientY,\r\n                    startPanX: canvasInstance.panX,\r\n                    startPanY: canvasInstance.panY\r\n                };\r\n\r\n                window.addEventListener(\"touchmove\", (ev) => onTouchMove(ev, canvasInstance), { passive: false });\r\n                window.addEventListener(\"touchend\", (ev) => onTouchEnd(ev, canvasInstance));\r\n                window.addEventListener(\"touchcancel\", (ev) => onTouchEnd(ev, canvasInstance));\r\n            }\r\n        }\r\n    }, { passive: false });\r\n\r\n    // Also capture two-finger gestures on the viewport/container for pinch zoom\r\n    canvasInstance.canvasContainer.addEventListener(\"touchstart\", (ev) => {\r\n        if (ev.touches.length === 2) {\r\n            ev.preventDefault();\r\n            const touches = ev.touches;\r\n            canvasInstance.pinchState = {\r\n                startDistance: getTouchDistance(touches[0], touches[1]),\r\n                startZoom: AppState.zoomLevel,\r\n                startPanX: canvasInstance.panX,\r\n                startPanY: canvasInstance.panY,\r\n                startCenterX: (touches[0].clientX + touches[1].clientX) / 2,\r\n                startCenterY: (touches[0].clientY + touches[1].clientY) / 2\r\n            };\r\n            canvasInstance.touchState = null;\r\n\r\n            window.addEventListener(\"touchmove\", (ev) => onTouchMove(ev, canvasInstance), { passive: false });\r\n            window.addEventListener(\"touchend\", (ev) => onTouchEnd(ev, canvasInstance));\r\n            window.addEventListener(\"touchcancel\", (ev) => onTouchEnd(ev, canvasInstance));\r\n        }\r\n    }, { passive: false });\r\n}\r\n\r\nfunction onTouchMove(ev, canvasInstance) {\r\n    const touches = ev.touches;\r\n\r\n    // Handle pinch/pan with two fingers\r\n    if (canvasInstance.pinchState && touches.length === 2) {\r\n        ev.preventDefault();\r\n        const currentDistance = getTouchDistance(touches[0], touches[1]);\r\n        const scale = currentDistance / canvasInstance.pinchState.startDistance;\r\n        const newZoom = Math.max(0.25, Math.min(4, canvasInstance.pinchState.startZoom * scale));\r\n        AppState.setZoomLevel(newZoom);\r\n\r\n        // Also pan based on center point movement\r\n        const currentCenterX = (touches[0].clientX + touches[1].clientX) / 2;\r\n        const currentCenterY = (touches[0].clientY + touches[1].clientY) / 2;\r\n        const dx = currentCenterX - canvasInstance.pinchState.startCenterX;\r\n        const dy = currentCenterY - canvasInstance.pinchState.startCenterY;\r\n        canvasInstance.panX = canvasInstance.pinchState.startPanX + dx;\r\n        canvasInstance.panY = canvasInstance.pinchState.startPanY + dy;\r\n        applyZoom(canvasInstance);\r\n        return;\r\n    }\r\n\r\n    // Cancel long press if touch moves significantly\r\n    if (touches.length === 1 && canvasInstance.longPressTimer) {\r\n        const touch = touches[0];\r\n        const dx = touch.clientX - (canvasInstance.touchState?.startTouchX || touch.clientX);\r\n        const dy = touch.clientY - (canvasInstance.touchState?.startTouchY || touch.clientY);\r\n        if (Math.hypot(dx, dy) > 10) {\r\n            clearTimeout(canvasInstance.longPressTimer);\r\n            canvasInstance.longPressTimer = null;\r\n        }\r\n    }\r\n\r\n    // Handle single-finger interactions\r\n    if (canvasInstance.touchState && touches.length === 1) {\r\n        ev.preventDefault();\r\n        const touch = touches[0];\r\n\r\n        if (canvasInstance.touchState.mode === \"pan\") {\r\n            // Canvas panning\r\n            const dx = touch.clientX - canvasInstance.touchState.startTouchX;\r\n            const dy = touch.clientY - canvasInstance.touchState.startTouchY;\r\n            canvasInstance.panX = canvasInstance.touchState.startPanX + dx;\r\n            canvasInstance.panY = canvasInstance.touchState.startPanY + dy;\r\n            applyZoom(canvasInstance);\r\n        } else if (canvasInstance.touchState.mode === \"move\") {\r\n            // Widget move with small deadzone\r\n            const dx = touch.clientX - canvasInstance.touchState.startTouchX;\r\n            const dy = touch.clientY - canvasInstance.touchState.startTouchY;\r\n\r\n            if (!canvasInstance.touchState.hasMoved && Math.hypot(dx, dy) < 5) {\r\n                return; // Small deadzone\r\n            }\r\n            canvasInstance.touchState.hasMoved = true;\r\n\r\n            const widget = AppState.getWidgetById(canvasInstance.touchState.id);\r\n            if (!widget) return;\r\n\r\n            const dims = AppState.getCanvasDimensions();\r\n            const zoom = AppState.zoomLevel;\r\n\r\n            let x = canvasInstance.touchState.startWidgetX + dx / zoom;\r\n            let y = canvasInstance.touchState.startWidgetY + dy / zoom;\r\n\r\n            // Clamp to canvas\r\n            x = Math.max(0, Math.min(dims.width - widget.width, x));\r\n            y = Math.max(0, Math.min(dims.height - widget.height, y));\r\n\r\n            // Update internal state\r\n            widget.x = x;\r\n            widget.y = y;\r\n\r\n            // Direct DOM update instead of render() to preserve touch stream\r\n            if (canvasInstance.touchState.el) {\r\n                canvasInstance.touchState.el.style.left = x + \"px\";\r\n                canvasInstance.touchState.el.style.top = y + \"px\";\r\n            }\r\n        } else if (canvasInstance.touchState.mode === \"resize\") {\r\n            // Widget resize\r\n            const widget = AppState.getWidgetById(canvasInstance.touchState.id);\r\n            if (!widget) return;\r\n\r\n            const dims = AppState.getCanvasDimensions();\r\n            const zoom = AppState.zoomLevel;\r\n\r\n            let w = canvasInstance.touchState.startW + (touch.clientX - canvasInstance.touchState.startX) / zoom;\r\n            let h = canvasInstance.touchState.startH + (touch.clientY - canvasInstance.touchState.startY) / zoom;\r\n\r\n            const wtype = (widget.type || \"\").toLowerCase();\r\n\r\n            // Special handling for line widgets\r\n            if (wtype === \"line\" || wtype === \"lvgl_line\") {\r\n                const props = widget.props || {};\r\n                const orientation = props.orientation || \"horizontal\";\r\n                const strokeWidth = parseInt(props.stroke_width || props.line_width || 3, 10);\r\n\r\n                if (orientation === \"vertical\") {\r\n                    w = strokeWidth;\r\n                    h = Math.max(10, h);\r\n                } else {\r\n                    h = strokeWidth;\r\n                    w = Math.max(10, w);\r\n                }\r\n            }\r\n\r\n            // Clamp to canvas bounds\r\n            const minSize = 20; // Ensure widget doesn't disappear\r\n            w = Math.max(minSize, Math.min(dims.width - widget.x, w));\r\n            h = Math.max(minSize, Math.min(dims.height - widget.y, h));\r\n\r\n            widget.width = w;\r\n            widget.height = h;\r\n\r\n            // Direct DOM update instead of render() to preserve touch stream\r\n            if (canvasInstance.touchState.el) {\r\n                canvasInstance.touchState.el.style.width = w + \"px\";\r\n                canvasInstance.touchState.el.style.height = h + \"px\";\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction onTouchEnd(ev, canvasInstance) {\r\n    if (canvasInstance.touchState) {\r\n        const widgetId = canvasInstance.touchState.id;\r\n        const mode = canvasInstance.touchState.mode;\r\n        const hasMoved = canvasInstance.touchState.hasMoved;\r\n\r\n        // Handle final snapping and selection for widgets\r\n        if (widgetId) {\r\n            const widget = AppState.getWidgetById(widgetId);\r\n            if (widget) {\r\n                if (mode === \"move\" && hasMoved) {\r\n                    // Apply final snapping on release\r\n                    const dims = AppState.getCanvasDimensions();\r\n                    const page = AppState.getCurrentPage();\r\n                    if (page?.layout) {\r\n                        const snapped = snapToGridCell(widget.x, widget.y, widget.width, widget.height, page.layout, dims);\r\n                        widget.x = snapped.x;\r\n                        widget.y = snapped.y;\r\n                    } else {\r\n                        const snapped = applySnapToPosition(canvasInstance, widget, widget.x, widget.y, false, dims);\r\n                        widget.x = snapped.x;\r\n                        widget.y = snapped.y;\r\n                    }\r\n                } else if (mode === \"resize\") {\r\n                    // Integer rounding for final dimensions\r\n                    widget.width = Math.round(widget.width);\r\n                    widget.height = Math.round(widget.height);\r\n                }\r\n\r\n                // Perform selection at the end to avoid DOM detachment during gesture\r\n                AppState.selectWidget(widgetId);\r\n            }\r\n\r\n            if ((mode === \"move\" || mode === \"resize\") && hasMoved) {\r\n                updateWidgetGridCell(canvasInstance, widgetId);\r\n                AppState.recordHistory();\r\n                emit(EVENTS.STATE_CHANGED);\r\n            }\r\n        }\r\n\r\n        canvasInstance.touchState = null;\r\n        clearSnapGuides(canvasInstance);\r\n        render(canvasInstance);\r\n    }\r\n\r\n    if (canvasInstance.pinchState) {\r\n        canvasInstance.pinchState = null;\r\n    }\r\n\r\n    if (canvasInstance.longPressTimer) {\r\n        clearTimeout(canvasInstance.longPressTimer);\r\n        canvasInstance.longPressTimer = null;\r\n    }\r\n\r\n    // Cleanup listeners is tricky with bound functions in separate modules\r\n    // Ideally we'd remove them, but we used anonymous arrow functions in addEventListener\r\n    // which makes removeEventListener hard unless we store the reference.\r\n    // In this module implementation, we are adding NEW listeners on every touchstart!\r\n    // This is a memory leak if we don't clean up.\r\n    // The original code used `this._boundTouchMove`.\r\n    // We should do the same or just use ONE global listener for move/end on window that checks state.\r\n    // Let's rely on the fact that touchstart adds them, and we need to remove them.\r\n    // We can't remove (ev) => onTouchMove(ev, canvasInstance).\r\n\r\n    // FIX: We need to store the specific bound function on canvasInstance so we can remove it.\r\n    // But since we are extracting logic, let's change strategy:\r\n    // We attach ONE persistent listener to window in setupTouchInteractions?\r\n    // No, standard practice is add on drag start, remove on drag end.\r\n    // Let's fix this in the next iteration or rewrite this file content now.\r\n}\r\n\r\nfunction getTouchDistance(t1, t2) {\r\n    return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);\r\n}\r\n\r\n// Helper to update grid cell\r\nfunction updateWidgetGridCell(canvasInstance, widgetId) {\r\n    const page = AppState.getCurrentPage();\r\n    if (!page || !page.layout) return;\r\n\r\n    const match = page.layout.match(/^(\\d+)x(\\d+)$/);\r\n    if (!match) return;\r\n\r\n    const widget = AppState.getWidgetById(widgetId);\r\n    if (!widget) return;\r\n\r\n    const rows = parseInt(match[1], 10);\r\n    const cols = parseInt(match[2], 10);\r\n    const dims = AppState.getCanvasDimensions();\r\n    const cellWidth = dims.width / cols;\r\n    const cellHeight = dims.height / rows;\r\n\r\n    // Calculate cell based on widget center\r\n    const centerX = widget.x + widget.width / 2;\r\n    const centerY = widget.y + widget.height / 2;\r\n\r\n    const col = Math.floor(centerX / cellWidth);\r\n    const row = Math.floor(centerY / cellHeight);\r\n\r\n    // Clamp to valid range\r\n    const clampedRow = Math.max(0, Math.min(rows - 1, row));\r\n    const clampedCol = Math.max(0, Math.min(cols - 1, col));\r\n\r\n    // Update widget props with detected grid position\r\n    const newProps = {\r\n        ...widget.props,\r\n        grid_cell_row_pos: clampedRow,\r\n        grid_cell_column_pos: clampedCol\r\n    };\r\n\r\n    // Also detect span based on widget size\r\n    const rowSpan = Math.max(1, Math.round(widget.height / cellHeight));\r\n    const colSpan = Math.max(1, Math.round(widget.width / cellWidth));\r\n    newProps.grid_cell_row_span = rowSpan;\r\n    newProps.grid_cell_column_span = colSpan;\r\n\r\n    AppState.updateWidget(widgetId, { props: newProps });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\constants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\constants_icons.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\events.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\keyboard.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'selectedWidgetId' is assigned a value but never used.","line":24,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"selectedWidgetId"},"fix":{"range":[575,623],"text":""},"desc":"Remove unused variable 'selectedWidgetId'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from './state.js';\nimport { Logger } from '../utils/logger.js';\n\nexport class KeyboardHandler {\n    constructor() {\n        this.init();\n    }\n\n    init() {\n        window.addEventListener(\"keydown\", (ev) => this.handleKeyDown(ev));\n    }\n\n    handleKeyDown(ev) {\n        // Debug\n        // Key event handling\n\n        const state = AppState || window.AppState;\n        if (!state) {\n            Logger.error(\"KeyboardHandler: AppState not found!\");\n            return;\n        }\n\n        const hasSelection = state.selectedWidgetIds.length > 0;\n        const selectedWidgetId = state.selectedWidgetId; // Reference for single-widget ops\n        const isAutoHighlight = window.isAutoHighlight || false; // Global flag from snippet editor\n\n        // Quick Search: Shift+Space\n        // Quick Search: Shift+Space\n        if (ev.shiftKey && ev.code === \"Space\") {\n            // Always trigger, even in input fields\n            // Blur the current input if it's focused (e.g. YAML snippet box)\n            if (ev.target.tagName === \"INPUT\" || ev.target.tagName === \"TEXTAREA\") {\n                ev.target.blur();\n            }\n\n            ev.preventDefault();\n            if (window.QuickSearch) {\n                window.QuickSearch.open();\n            }\n            return;\n        }\n\n        if ((ev.key === \"Delete\" || ev.key === \"Backspace\") && hasSelection) {\n            // Special case: If snippet box is focused but selection matches the auto-highlight,\n            // treat it as a widget delete.\n            const lastHighlightRange = window.lastHighlightRange;\n            if (ev.target.id === \"snippetBox\" && lastHighlightRange) {\n                if (ev.target.selectionStart === lastHighlightRange.start &&\n                    ev.target.selectionEnd === lastHighlightRange.end) {\n                    ev.preventDefault();\n                    this.deleteWidget(null); // Fix: Delete current selection (multi), not just the single ID\n                    return;\n                }\n            }\n\n            if (ev.target.tagName === \"INPUT\" || ev.target.tagName === \"TEXTAREA\") {\n                return;\n            }\n            ev.preventDefault();\n            this.deleteWidget(null); // Passing null to delete current selection\n            return;\n        }\n\n        // Copy: Ctrl+C\n        if ((ev.ctrlKey || ev.metaKey) && ev.key === \"c\") {\n            if (ev.target.tagName === \"INPUT\" || ev.target.tagName === \"TEXTAREA\") {\n                if (ev.target.id === \"snippetBox\" && isAutoHighlight) {\n                    ev.preventDefault();\n                    this.copyWidget();\n                    return;\n                }\n                return;\n            }\n            ev.preventDefault();\n            this.copyWidget();\n        }\n\n        // Paste: Ctrl+V\n        if ((ev.ctrlKey || ev.metaKey) && ev.key === \"v\") {\n            if (ev.target.tagName === \"INPUT\" || ev.target.tagName === \"TEXTAREA\") {\n                if (ev.target.id === \"snippetBox\" && isAutoHighlight) {\n                    ev.preventDefault();\n                    this.pasteWidget();\n                    return;\n                }\n                return;\n            }\n            ev.preventDefault();\n            this.pasteWidget();\n        }\n\n        // Undo: Ctrl+Z\n        if ((ev.ctrlKey || ev.metaKey) && ev.key === \"z\" && !ev.shiftKey) {\n            ev.preventDefault();\n            state.undo();\n        }\n\n        // Redo: Ctrl+Y or Ctrl+Shift+Z\n        if ((ev.ctrlKey || ev.metaKey) && (ev.key === \"y\" || (ev.key === \"z\" && ev.shiftKey))) {\n            ev.preventDefault();\n            state.redo();\n        }\n\n        // Lock/Unlock: Ctrl+L\n        if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === \"l\" && hasSelection) {\n            ev.preventDefault();\n            const selectedWidgets = state.getSelectedWidgets();\n            const allLocked = selectedWidgets.every(w => w.locked);\n            // Toggle: if all are locked, unlock them. Otherwise, lock all.\n            state.updateWidgets(state.selectedWidgetIds, { locked: !allLocked });\n        }\n    }\n\n    deleteWidget(widgetId) {\n        const state = AppState || window.AppState;\n        if (state) state.deleteWidget(widgetId);\n    }\n\n    copyWidget() {\n        const state = AppState || window.AppState;\n        if (state) state.copyWidget();\n    }\n\n    pasteWidget() {\n        const state = AppState || window.AppState;\n        if (state) state.pasteWidget();\n    }\n}\n\n// Initialize globally\nwindow.KeyboardHandler = KeyboardHandler;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\layout_constants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\plugin_registry.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\properties.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'emit' is defined but never used.","line":2,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":18,"suggestions":[{"messageId":"removeVar","data":{"varName":"emit"},"fix":{"range":[50,56],"text":""},"desc":"Remove unused variable 'emit'."}]},{"ruleId":"no-dupe-else-if","severity":2,"message":"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.","line":1057,"column":18,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":1057,"endColumn":39},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":1076,"column":55,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":1076,"endColumn":56,"suggestions":[{"messageId":"removeEscape","fix":{"range":[60869,60870],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[60869,60869],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'rows' is assigned a value but never used.","line":1420,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":1420,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"rows"},"fix":{"range":[83685,83715],"text":""},"desc":"Remove unused variable 'rows'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from './state.js';\nimport { on, emit, EVENTS } from './events.js';\nimport { getAvailableColors, getDeviceModel } from '../utils/device.js';\nimport { registry as FeatureRegistry } from './plugin_registry.js';\nimport { WidgetFactory } from './widget_factory.js';\nimport { fetchEntityStates, ENTITY_DATALIST_ID, ensureEntityDatalist } from '../io/ha_api.js';\nimport { openEntityPickerForWidget } from '../ui/entity_picker.js';\nimport { openIconPickerForWidget } from '../ui/icon_picker.js';\n// debounce import removed\n\nexport class PropertiesPanel {\n    constructor() {\n        this.panel = document.getElementById(\"propertiesPanel\");\n        this.lastRenderedWidgetId = null; // Track which widget was last rendered\n        this.init();\n    }\n\n    init() {\n        // Subscribe to events\n        on(EVENTS.SELECTION_CHANGED, () => this.render());\n        on(EVENTS.STATE_CHANGED, () => this.render());\n\n        // Bind Snap Toggle (Static in sidebar)\n        const snapToggle = document.getElementById(\"snapToggle\");\n        if (snapToggle) {\n            // Initialize state from AppState\n            snapToggle.checked = AppState.snapEnabled;\n\n            // Listen for user interaction\n            snapToggle.addEventListener(\"change\", (e) => {\n                AppState.setSnapEnabled(e.target.checked);\n            });\n\n            // Listen for state changes (e.g. from Editor Settings modal)\n            on(EVENTS.SETTINGS_CHANGED, (settings) => {\n                if (settings.snapEnabled !== undefined) {\n                    snapToggle.checked = settings.snapEnabled;\n                }\n            });\n        }\n\n        // Bind Lock Toggle (Static in sidebar)\n        const lockToggle = document.getElementById(\"lockPositionToggle\");\n        if (lockToggle) {\n            lockToggle.addEventListener(\"change\", (e) => {\n                const selectedIds = AppState.selectedWidgetIds;\n                if (selectedIds.length > 0) {\n                    AppState.updateWidgets(selectedIds, { locked: e.target.checked });\n                    // No need to emit STATE_CHANGED here as updateWidgets already does it\n                }\n            });\n        }\n\n        this.render();\n    }\n\n    render() {\n        if (!this.panel) return;\n\n        // Get current selected widget ID\n        const currentWidgetId = AppState.selectedWidgetId;\n\n        // Check if the selected widget changed - if so, force re-render\n        const widgetChanged = this.lastRenderedWidgetId !== currentWidgetId;\n\n        // Prevent re-rendering if user is typing in the panel AND same widget\n        // This avoids losing focus/cursor position while editing the same widget\n        // But if the widget changed, we MUST re-render to show correct properties\n        if (!widgetChanged && this.panel && this.panel.isConnected) {\n            // Robustly check for focus within the panel\n            const active = document.activeElement;\n            if (active && this.panel.contains(active)) {\n                // Return if user is typing in an input/textarea\n                const tag = active.tagName.toLowerCase();\n                if (tag === \"input\" || tag === \"textarea\") {\n                    return;\n                }\n            }\n        }\n\n        // Update tracking\n        this.lastRenderedWidgetId = currentWidgetId;\n\n        this.panel.innerHTML = \"\";\n\n        // Update Lock Toggle state based on selection\n        const lockToggle = document.getElementById(\"lockPositionToggle\");\n        if (lockToggle) {\n            const selectedWidgets = AppState.getSelectedWidgets();\n            const allLocked = selectedWidgets.length > 0 && selectedWidgets.every(w => w.locked);\n            const someLocked = selectedWidgets.some(w => w.locked);\n\n            lockToggle.checked = allLocked;\n            lockToggle.indeterminate = someLocked && !allLocked;\n            lockToggle.disabled = selectedWidgets.length === 0;\n        }\n\n        if (AppState.selectedWidgetIds.length === 0) {\n            this.panel.innerHTML = \"<div style='padding:16px;color:#aaa;text-align:center;'>Select a widget to edit properties</div>\";\n            return;\n        }\n\n        if (AppState.selectedWidgetIds.length > 1) {\n            this.panel.innerHTML = `\n                <div style='padding:16px; text-align:center;'>\n                    <div style=\"font-size: 24px; margin-bottom: 12px;\">­ƒôæ</div>\n                    <div style=\"font-weight: 600; color: var(--text);\">${AppState.selectedWidgetIds.length} widgets selected</div>\n                    <div style=\"font-size: 11px; color: var(--muted); margin-top: 8px; margin-bottom: 16px;\">\n                        Move, group, or delete the selection. Use the Lock toggle above to lock all.\n                    </div>\n                    <button id=\"multiDeleteBtn\" class=\"btn btn-secondary btn-xs\" style=\"background: var(--danger); color: white; border: none; width: 100%;\">\n                        ­ƒùæ Delete Selected Widgets\n                    </button>\n                </div>\n            `;\n\n            const delBtn = this.panel.querySelector(\"#multiDeleteBtn\");\n            if (delBtn) {\n                delBtn.addEventListener(\"click\", () => {\n                    if (confirm(`Are you sure you want to delete ${AppState.selectedWidgetIds.length} widgets?`)) {\n                        AppState.deleteWidget(null);\n                    }\n                });\n            }\n            return;\n        }\n\n        const widget = AppState.getSelectedWidget();\n        if (!widget) return;\n\n\n        const type = (widget.type || \"\").toLowerCase();\n        const title = document.createElement(\"div\");\n        title.className = \"sidebar-section-label\";\n        title.style.marginTop = \"0\";\n        title.textContent = `${type} Properties`;\n        this.panel.appendChild(title);\n\n        // Lock Toggle state is already updated above in the general selection handling\n\n        // === LAYER ORDER SECTION (TOP) ===\n        this.addSectionLabel(\"Layer Order\");\n        this.addLayerOrderButtons(widget);\n\n        // === COMMON PROPERTIES ===\n        this.addSectionLabel(\"Position & Size\");\n        this.addLabeledInput(\"Position X\", \"number\", widget.x, (v) => {\n            AppState.updateWidget(widget.id, { x: parseInt(v, 10) || 0 });\n        });\n        this.addLabeledInput(\"Position Y\", \"number\", widget.y, (v) => {\n            AppState.updateWidget(widget.id, { y: parseInt(v, 10) || 0 });\n        });\n        this.addLabeledInput(\"Width\", \"number\", widget.width, (v) => {\n            AppState.updateWidget(widget.id, { width: parseInt(v, 10) || 10 });\n        });\n        this.addLabeledInput(\"Height\", \"number\", widget.height, (v) => {\n            AppState.updateWidget(widget.id, { height: parseInt(v, 10) || 10 });\n        });\n\n        // === WIDGET-SPECIFIC PROPERTIES ===\n        this.addSectionLabel(\"Widget Settings\");\n\n        // Feature Registry Schema Support (Future)\n        if (FeatureRegistry) {\n            const feature = FeatureRegistry.get(type);\n            if (feature && feature.schema) {\n                // TODO: Implement full schema-driven rendering\n            }\n        }\n\n        // Legacy Widget Specific Logic\n        this.renderLegacyProperties(widget, type);\n\n        // === GRID CELL PROPERTIES (for LVGL widgets in grid layout) ===\n        this.renderGridCellProperties(widget, type);\n\n        // === VISIBILITY CONDITIONS SECTION (BOTTOM) ===\n        this.addSectionLabel(\"Visibility Conditions\");\n        this.addVisibilityConditions(widget);\n    }\n\n    /**\n     * Renders grid cell position properties for widgets when page uses grid layout.\n     * For LVGL widgets: uses native grid_cell_* properties\n     * For non-LVGL widgets: auto-calculates x/y from grid position\n     */\n    renderGridCellProperties(widget, type) {\n        const page = AppState.getCurrentPage();\n        if (!page || !page.layout) return;  // Only show if page has grid layout\n\n        const isLvgl = WidgetFactory.isLvglWidget(type);\n        const props = widget.props || {};\n\n        const updateProp = (key, value) => {\n            const newProps = { ...widget.props, [key]: value };\n            AppState.updateWidget(widget.id, { props: newProps });\n        };\n\n        // Helper to calculate x/y from grid position for non-LVGL widgets\n        const calculateGridPosition = (row, col, rowSpan, colSpan) => {\n            const match = page.layout.match(/^(\\d+)x(\\d+)$/);\n            if (!match) return null;\n\n            const rows = parseInt(match[1], 10);\n            const cols = parseInt(match[2], 10);\n            const dims = AppState.getCanvasDimensions();\n            const cellWidth = dims.width / cols;\n            const cellHeight = dims.height / rows;\n\n            return {\n                x: Math.round(col * cellWidth),\n                y: Math.round(row * cellHeight),\n                width: Math.round(cellWidth * colSpan),\n                height: Math.round(cellHeight * rowSpan)\n            };\n        };\n\n        this.addSectionLabel(isLvgl ? \"Grid Cell Position\" : \"Grid Cell Position (Auto X/Y)\");\n\n        // Row Position\n        this.addLabeledInput(\"Row (0-indexed)\", \"number\", props.grid_cell_row_pos ?? \"\", (v) => {\n            const val = v === \"\" ? null : parseInt(v, 10);\n            updateProp(\"grid_cell_row_pos\", isNaN(val) ? null : val);\n\n            // Auto-calculate x/y for canvas preview (all widgets)\n            const freshWidget = AppState.getWidgetById(widget.id);\n            const fp = freshWidget?.props || {};\n            if (val != null && fp.grid_cell_column_pos != null) {\n                const pos = calculateGridPosition(val, fp.grid_cell_column_pos,\n                    fp.grid_cell_row_span || 1, fp.grid_cell_column_span || 1);\n                if (pos) {\n                    AppState.updateWidget(widget.id, { x: pos.x, y: pos.y, width: pos.width, height: pos.height });\n                }\n            }\n        });\n\n        // Column Position\n        this.addLabeledInput(\"Column (0-indexed)\", \"number\", props.grid_cell_column_pos ?? \"\", (v) => {\n            const val = v === \"\" ? null : parseInt(v, 10);\n            updateProp(\"grid_cell_column_pos\", isNaN(val) ? null : val);\n\n            // Auto-calculate x/y for canvas preview (all widgets)\n            const freshWidget = AppState.getWidgetById(widget.id);\n            const fp = freshWidget?.props || {};\n            if (val != null && fp.grid_cell_row_pos != null) {\n                const pos = calculateGridPosition(fp.grid_cell_row_pos, val,\n                    fp.grid_cell_row_span || 1, fp.grid_cell_column_span || 1);\n                if (pos) {\n                    AppState.updateWidget(widget.id, { x: pos.x, y: pos.y, width: pos.width, height: pos.height });\n                }\n            }\n        });\n\n        // Row Span\n        this.addLabeledInput(\"Row Span\", \"number\", props.grid_cell_row_span || 1, (v) => {\n            const span = Math.max(1, parseInt(v, 10) || 1);\n            updateProp(\"grid_cell_row_span\", span);\n\n            // Recalculate size for canvas preview (all widgets)\n            const freshWidget = AppState.getWidgetById(widget.id);\n            const fp = freshWidget?.props || {};\n            if (fp.grid_cell_row_pos != null && fp.grid_cell_column_pos != null) {\n                const pos = calculateGridPosition(fp.grid_cell_row_pos, fp.grid_cell_column_pos,\n                    span, fp.grid_cell_column_span || 1);\n                if (pos) {\n                    AppState.updateWidget(widget.id, { x: pos.x, y: pos.y, width: pos.width, height: pos.height });\n                }\n            }\n        });\n\n        // Column Span\n        this.addLabeledInput(\"Column Span\", \"number\", props.grid_cell_column_span || 1, (v) => {\n            const span = Math.max(1, parseInt(v, 10) || 1);\n            updateProp(\"grid_cell_column_span\", span);\n\n            // Recalculate size for canvas preview (all widgets)\n            const freshWidget = AppState.getWidgetById(widget.id);\n            const fp = freshWidget?.props || {};\n            if (fp.grid_cell_row_pos != null && fp.grid_cell_column_pos != null) {\n                const pos = calculateGridPosition(fp.grid_cell_row_pos, fp.grid_cell_column_pos,\n                    fp.grid_cell_row_span || 1, span);\n                if (pos) {\n                    AppState.updateWidget(widget.id, { x: pos.x, y: pos.y, width: pos.width, height: pos.height });\n                }\n            }\n        });\n\n        // Alignment options (only for LVGL widgets that support it natively)\n        if (isLvgl) {\n            const alignOptions = [\"START\", \"END\", \"CENTER\", \"STRETCH\"];\n            this.addSelect(\"X Align\", props.grid_cell_x_align || \"STRETCH\", alignOptions, (v) => {\n                updateProp(\"grid_cell_x_align\", v);\n            });\n            this.addSelect(\"Y Align\", props.grid_cell_y_align || \"STRETCH\", alignOptions, (v) => {\n                updateProp(\"grid_cell_y_align\", v);\n            });\n        }\n    }\n\n    renderLegacyProperties(widget, type) {\n        const colors = getAvailableColors();\n        const props = widget.props || {};\n\n        // Helper to update props\n        const updateProp = (key, value) => {\n            const newProps = { ...widget.props, [key]: value };\n            AppState.updateWidget(widget.id, { props: newProps });\n        };\n\n        // Common: Opacity\n        this.addLabeledInput(\"Opacity (%)\", \"number\", props.opacity !== undefined ? props.opacity : 100, (v) => {\n            updateProp(\"opacity\", parseInt(v, 10));\n        });\n\n        if (type === \"shape_rect\" || type === \"shape_circle\") {\n            this.addCheckbox(\"Fill\", props.fill || false, (v) => updateProp(\"fill\", v));\n            this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 1, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n            this.addColorSelector(\"Border Color\", props.border_color || \"black\", colors, (v) => updateProp(\"border_color\", v));\n        }\n        else if (type === \"rounded_rect\") {\n            this.addCheckbox(\"Fill\", props.fill || false, (v) => updateProp(\"fill\", v));\n            if (props.fill) {\n                this.addCheckbox(\"Show Border\", props.show_border || false, (v) => updateProp(\"show_border\", v));\n            }\n            this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 4, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n            this.addLabeledInput(\"Corner Radius\", \"number\", props.radius || 10, (v) => updateProp(\"radius\", parseInt(v, 10)));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n            this.addColorSelector(\"Border Color\", props.border_color || \"black\", colors, (v) => updateProp(\"border_color\", v));\n        }\n        else if (type === \"line\") {\n            this.addSelect(\"Orientation\", props.orientation || \"horizontal\", [\"horizontal\", \"vertical\"], (v) => {\n                const strokeWidth = parseInt(props.stroke_width || 3, 10);\n                const currentW = widget.width;\n                const currentH = widget.height;\n                const isVert = v === \"vertical\";\n\n                // When switching orientation, swap the length dimension and set the other to stroke width\n                if (isVert) {\n                    // Switching to vertical: height becomes the length (use current width as reference), width becomes stroke\n                    AppState.updateWidget(widget.id, {\n                        width: strokeWidth,\n                        height: Math.max(currentW, currentH, 20) // Use the larger dimension as new length\n                    });\n                } else {\n                    // Switching to horizontal: width becomes the length (use current height as reference), height becomes stroke\n                    AppState.updateWidget(widget.id, {\n                        width: Math.max(currentW, currentH, 20), // Use the larger dimension as new length\n                        height: strokeWidth\n                    });\n                }\n                updateProp(\"orientation\", v);\n            });\n\n            // Show the \"Length\" property for the line (the dimension that can be resized)\n            const isVertical = (props.orientation || \"horizontal\") === \"vertical\";\n            this.addLabeledInput(\"Line Length (px)\", \"number\", isVertical ? widget.height : widget.width, (v) => {\n                const newLength = parseInt(v, 10) || 20;\n                if (isVertical) {\n                    AppState.updateWidget(widget.id, { height: newLength });\n                } else {\n                    AppState.updateWidget(widget.id, { width: newLength });\n                }\n            });\n\n            this.addLabeledInput(\"Stroke Width (px)\", \"number\", props.stroke_width || 3, (v) => {\n                const newStroke = parseInt(v, 10) || 1;\n                updateProp(\"stroke_width\", newStroke);\n                // Also update the widget dimension that represents thickness\n                const isVert = (props.orientation || \"horizontal\") === \"vertical\";\n                if (isVert) {\n                    AppState.updateWidget(widget.id, { width: newStroke });\n                } else {\n                    AppState.updateWidget(widget.id, { height: newStroke });\n                }\n            });\n\n            // Fill Length Button\n            const fillBtn = document.createElement(\"button\");\n            fillBtn.textContent = \"Fill Canvas Length\";\n            fillBtn.className = \"btn btn-secondary\";\n            fillBtn.style.marginTop = \"8px\";\n            fillBtn.style.width = \"100%\";\n            fillBtn.onclick = () => {\n                const dims = AppState.getCanvasDimensions();\n                const isVert = (props.orientation || \"horizontal\") === \"vertical\";\n                if (isVert) {\n                    AppState.updateWidget(widget.id, { y: 0, height: dims.height });\n                } else {\n                    AppState.updateWidget(widget.id, { x: 0, width: dims.width });\n                }\n            };\n            this.panel.appendChild(fillBtn);\n\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"text\" || type === \"label\") {\n            this.addLabeledInput(\"Text\", \"text\", props.text || \"\", (v) => updateProp(\"text\", v));\n            this.addLabeledInput(\"Font Size\", \"number\", props.font_size || 20, (v) => updateProp(\"font_size\", parseInt(v, 10)));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n\n            // Font Family with Custom Support\n            const fontOptions = [\"Roboto\", \"Inter\", \"Open Sans\", \"Lato\", \"Montserrat\", \"Poppins\", \"Raleway\", \"Roboto Mono\", \"Ubuntu\", \"Nunito\", \"Playfair Display\", \"Merriweather\", \"Work Sans\", \"Source Sans Pro\", \"Quicksand\", \"Custom...\"];\n            const currentFont = props.font_family || \"Roboto\";\n            const isCustom = !fontOptions.slice(0, -1).includes(currentFont);\n\n            this.addSelect(\"Font\", isCustom ? \"Custom...\" : currentFont, fontOptions, (v) => {\n                if (v !== \"Custom...\") {\n                    updateProp(\"font_family\", v);\n                    updateProp(\"custom_font_family\", \"\");\n                } else {\n                    updateProp(\"font_family\", \"Custom...\");\n                }\n            });\n\n            if (isCustom || props.font_family === \"Custom...\") {\n                this.addLabeledInput(\"Custom Font Name\", \"text\", props.custom_font_family || (isCustom ? currentFont : \"\"), (v) => {\n                    updateProp(\"font_family\", v || \"Roboto\");\n                    updateProp(\"custom_font_family\", v);\n                });\n                this.addHint('Browse <a href=\"https://fonts.google.com\" target=\"_blank\">fonts.google.com</a>');\n            }\n\n            this.addSelect(\"Weight\", props.font_weight || 400, [100, 200, 300, 400, 500, 600, 700, 800, 900], (v) => updateProp(\"font_weight\", parseInt(v, 10)));\n            this.addCheckbox(\"Italic\", props.italic || false, (v) => updateProp(\"italic\", v));\n\n            // Text Alignment\n            const alignOptions = [\n                \"TOP_LEFT\", \"TOP_CENTER\", \"TOP_RIGHT\",\n                \"CENTER_LEFT\", \"CENTER\", \"CENTER_RIGHT\",\n                \"BOTTOM_LEFT\", \"BOTTOM_CENTER\", \"BOTTOM_RIGHT\"\n            ];\n            this.addSelect(\"Align\", props.text_align || \"TOP_LEFT\", alignOptions, (v) => updateProp(\"text_align\", v));\n\n            this.addSelect(\"BPP (Anti-aliasing)\", String(props.bpp || 1), [\"1\", \"2\", \"4\", \"8\"], (v) => updateProp(\"bpp\", parseInt(v, 10)));\n            this.addHint(\"1=no AA, 2=4 levels, 4=16 levels, 8=256 levels\");\n        }\n        else if (type === \"sensor_text\") {\n            this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n                // Auto-populate title if empty and entity has a friendly name\n                if (v && !widget.title && window.AppState && window.AppState.entityStates) {\n                    this.autoPopulateTitleFromEntity(widget.id, v);\n                }\n            }, widget);\n            // Text Sensor toggle (auto-detected when entity is selected)\n            this.addCheckbox(\"Text Sensor (string value)\", props.is_text_sensor || false, (v) => updateProp(\"is_text_sensor\", v));\n            this.addHint(\"Enable if entity returns text instead of numbers.\");\n            this.addCheckbox(\"Local / On-Device Sensor\", !!props.is_local_sensor, (v) => updateProp(\"is_local_sensor\", v));\n            this.addHint(\"Use internal battery_level/signal sensor.\");\n            this.addLabeledInputWithPicker(\"Secondary Entity ID\", \"text\", widget.entity_id_2 || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id_2: v });\n            }, widget);\n            this.addLabeledInput(\"Separator\", \"text\", props.separator || \" ~ \", (v) => updateProp(\"separator\", v));\n            this.addLabeledInput(\"Title/Label\", \"text\", widget.title || \"\", (v) => {\n                AppState.updateWidget(widget.id, { title: v });\n            });\n            this.addSelect(\"Display Format\", props.value_format || \"label_value\", [\n                { value: \"label_value\", label: \"Label: Value & Unit\" },\n                { value: \"label_value_no_unit\", label: \"Label: Value Only\" },\n                { value: \"label_newline_value\", label: \"Label [newline] Value & Unit\" },\n                { value: \"label_newline_value_no_unit\", label: \"Label [newline] Value Only\" },\n                { value: \"value_only\", label: \"Value & Unit\" },\n                { value: \"value_only_no_unit\", label: \"Value Only\" }\n            ], (v) => updateProp(\"value_format\", v));\n            this.addLabeledInput(\"Precision\", \"number\", props.precision !== undefined ? props.precision : 2, (v) => updateProp(\"precision\", parseInt(v, 10)));\n            this.addLabeledInputWithDataList(\"Prefix\", \"text\", props.prefix || \"\", [\"Ôé¼\", \"$\", \"┬ú\", \"┬Ñ\", \"CHF\", \"kr\"], (v) => updateProp(\"prefix\", v));\n            this.addLabeledInputWithDataList(\"Postfix\", \"text\", props.postfix || \"\", [\" kWh\", \" W\", \" V\", \" A\", \" ┬░C\", \" %\", \" ppm\", \" lx\"], (v) => updateProp(\"postfix\", v));\n\n            this.addLabeledInput(\"Unit (Manual helper)\", \"text\", props.unit || \"\", (v) => updateProp(\"unit\", v));\n            this.addCheckbox(\"Hide default unit\", props.hide_unit || false, (v) => updateProp(\"hide_unit\", v));\n            this.addLabeledInput(\"Label Size\", \"number\", props.label_font_size || 14, (v) => updateProp(\"label_font_size\", parseInt(v, 10)));\n            this.addLabeledInput(\"Value Size\", \"number\", props.value_font_size || 20, (v) => updateProp(\"value_font_size\", parseInt(v, 10)));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n\n            // Font Family with Custom Support\n            const fontOptions = [\"Roboto\", \"Inter\", \"Open Sans\", \"Lato\", \"Montserrat\", \"Poppins\", \"Raleway\", \"Roboto Mono\", \"Ubuntu\", \"Nunito\", \"Playfair Display\", \"Merriweather\", \"Work Sans\", \"Source Sans Pro\", \"Quicksand\", \"Custom...\"];\n            const currentFont = props.font_family || \"Roboto\";\n            const isCustom = !fontOptions.slice(0, -1).includes(currentFont);\n\n            this.addSelect(\"Font\", isCustom ? \"Custom...\" : currentFont, fontOptions, (v) => {\n                if (v !== \"Custom...\") {\n                    updateProp(\"font_family\", v);\n                    updateProp(\"custom_font_family\", \"\");\n                } else {\n                    updateProp(\"font_family\", \"Custom...\");\n                }\n            });\n\n            if (isCustom || props.font_family === \"Custom...\") {\n                this.addLabeledInput(\"Custom Font Name\", \"text\", props.custom_font_family || (isCustom ? currentFont : \"\"), (v) => {\n                    updateProp(\"font_family\", v || \"Roboto\");\n                    updateProp(\"custom_font_family\", v);\n                });\n                this.addHint('Browse <a href=\"https://fonts.google.com\" target=\"_blank\">fonts.google.com</a>');\n            }\n\n            this.addSelect(\"Weight\", props.font_weight || 400, [100, 200, 300, 400, 500, 600, 700, 800, 900], (v) => updateProp(\"font_weight\", parseInt(v, 10)));\n            this.addCheckbox(\"Italic\", props.italic || false, (v) => updateProp(\"italic\", v));\n\n            // Text Alignment for Sensor Text\n            const alignOptions = [\n                \"TOP_LEFT\", \"TOP_CENTER\", \"TOP_RIGHT\",\n                \"CENTER_LEFT\", \"CENTER\", \"CENTER_RIGHT\",\n                \"BOTTOM_LEFT\", \"BOTTOM_CENTER\", \"BOTTOM_RIGHT\"\n            ];\n            this.addSelect(\"Align\", props.text_align || \"TOP_LEFT\", alignOptions, (v) => {\n                updateProp(\"text_align\", v);\n                updateProp(\"label_align\", v);\n                updateProp(\"value_align\", v);\n            });\n        }\n        else if (type === \"datetime\") {\n            this.addSelect(\"Display Format\", props.format || \"time_date\", [\"time_date\", \"time_only\", \"date_only\", \"weekday_day_month\"], (v) => updateProp(\"format\", v));\n            this.addLabeledInput(\"Time Font Size\", \"number\", props.time_font_size || 28, (v) => updateProp(\"time_font_size\", parseInt(v, 10)));\n            this.addLabeledInput(\"Date Font Size\", \"number\", props.date_font_size || 16, (v) => updateProp(\"date_font_size\", parseInt(v, 10)));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n\n            // Font Family with Custom Support\n            const fontOptions = [\"Roboto\", \"Inter\", \"Open Sans\", \"Lato\", \"Montserrat\", \"Poppins\", \"Raleway\", \"Roboto Mono\", \"Ubuntu\", \"Nunito\", \"Playfair Display\", \"Merriweather\", \"Work Sans\", \"Source Sans Pro\", \"Quicksand\", \"Custom...\"];\n            const currentFont = props.font_family || \"Roboto\";\n            const isCustom = !fontOptions.slice(0, -1).includes(currentFont);\n\n            this.addSelect(\"Font\", isCustom ? \"Custom...\" : currentFont, fontOptions, (v) => {\n                if (v !== \"Custom...\") {\n                    updateProp(\"font_family\", v);\n                    updateProp(\"custom_font_family\", \"\");\n                } else {\n                    updateProp(\"font_family\", \"Custom...\");\n                }\n            });\n\n            if (isCustom || props.font_family === \"Custom...\") {\n                this.addLabeledInput(\"Custom Font Name\", \"text\", props.custom_font_family || (isCustom ? currentFont : \"\"), (v) => {\n                    updateProp(\"font_family\", v || \"Roboto\");\n                    updateProp(\"custom_font_family\", v);\n                });\n                this.addHint('Browse <a href=\"https://fonts.google.com\" target=\"_blank\">fonts.google.com</a>');\n            }\n\n            this.addCheckbox(\"Italic\", props.italic || false, (v) => updateProp(\"italic\", v));\n\n            // Text Alignment\n            const alignOptions = [\n                \"TOP_LEFT\", \"TOP_CENTER\", \"TOP_RIGHT\",\n                \"CENTER_LEFT\", \"CENTER\", \"CENTER_RIGHT\",\n                \"BOTTOM_LEFT\", \"BOTTOM_CENTER\", \"BOTTOM_RIGHT\"\n            ];\n            this.addSelect(\"Align\", props.text_align || \"CENTER\", alignOptions, (v) => updateProp(\"text_align\", v));\n        }\n        else if (type === \"progress_bar\") {\n            this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n                // Auto-populate title if empty and entity has a friendly name\n                if (v && !widget.title && window.AppState && window.AppState.entityStates) {\n                    this.autoPopulateTitleFromEntity(widget.id, v);\n                }\n            }, widget);\n            this.addLabeledInput(\"Title/Label\", \"text\", widget.title || \"\", (v) => {\n                AppState.updateWidget(widget.id, { title: v });\n            });\n            this.addCheckbox(\"Show Label\", props.show_label !== false, (v) => updateProp(\"show_label\", v));\n            this.addCheckbox(\"Show Percentage\", props.show_percentage !== false, (v) => updateProp(\"show_percentage\", v));\n\n            // Fix: Ensure bar_height is parsed correctly and defaults to 15\n            this.addLabeledInput(\"Bar Height\", \"number\", props.bar_height || 15, (v) => {\n                const val = parseInt(v, 10);\n                updateProp(\"bar_height\", isNaN(val) ? 15 : val);\n            });\n\n            this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 1, (v) => {\n                const val = parseInt(v, 10);\n                updateProp(\"border_width\", isNaN(val) ? 1 : val);\n            });\n\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"graph\") {\n            this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n            this.addLabeledInput(\"Title\", \"text\", widget.title || \"\", (v) => {\n                AppState.updateWidget(widget.id, { title: v });\n            });\n            this.addLabeledInput(\"Duration\", \"text\", props.duration || \"1h\", (v) => updateProp(\"duration\", v));\n            this.addColorSelector(\"Line Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n            this.addSelect(\"Line Type\", props.line_type || \"SOLID\", [\"SOLID\", \"DASHED\", \"DOTTED\"], (v) => updateProp(\"line_type\", v));\n            this.addLabeledInput(\"Line Thickness\", \"number\", props.line_thickness || 3, (v) => updateProp(\"line_thickness\", parseInt(v, 10)));\n            this.addCheckbox(\"Show Border\", props.border !== false, (v) => updateProp(\"border\", v));\n            this.addCheckbox(\"Show Grid\", props.grid !== false, (v) => updateProp(\"grid\", v));\n            this.addLabeledInput(\"X Grid Interval\", \"text\", props.x_grid || \"1h\", (v) => updateProp(\"x_grid\", v));\n            this.addLabeledInput(\"Y Grid Step\", \"text\", props.y_grid || \"auto\", (v) => updateProp(\"y_grid\", v));\n            this.addLabeledInput(\"Min Value\", \"number\", props.min_value || \"\", (v) => updateProp(\"min_value\", v));\n            this.addLabeledInput(\"Max Value\", \"number\", props.max_value || \"\", (v) => updateProp(\"max_value\", v));\n        }\n        else if (type === \"icon\") {\n            this.addCheckbox(\"Fit icon to frame\", props.fit_icon_to_frame || false, (v) => updateProp(\"fit_icon_to_frame\", v));\n\n            // Use the new reusable icon picker\n            this.addIconPicker(\"Select Icon\", props.code || \"F07D0\", (v) => updateProp(\"code\", v), widget);\n\n            this.addLabeledInput(\"Icon Size (px)\", \"number\", props.size || 40, (v) => {\n                let n = parseInt(v || \"40\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 260) n = 260;\n                updateProp(\"size\", n);\n            });\n\n            this.addSelect(\"Font Reference\", props.font_ref || \"font_mdi_medium\", [\"font_mdi_medium\", \"font_mdi_large\"], (v) => updateProp(\"font_ref\", v));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"battery_icon\") {\n            // Entity ID with built-in picker\n            this.addLabeledInputWithPicker(\"Battery Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n\n            this.addCheckbox(\"Local / On-Device Sensor\", !!props.is_local_sensor, (v) => updateProp(\"is_local_sensor\", v));\n            this.addCheckbox(\"Fit icon to frame\", props.fit_icon_to_frame || false, (v) => updateProp(\"fit_icon_to_frame\", v));\n\n            this.addLabeledInput(\"Icon Size (px)\", \"number\", props.size || 48, (v) => {\n                let n = parseInt(v || \"48\", 10);\n                if (Number.isNaN(n) || n < 16) n = 16;\n                if (n > 200) n = 200;\n                updateProp(\"size\", n);\n            });\n\n            this.addLabeledInput(\"Percentage Font Size (px)\", \"number\", props.font_size || 12, (v) => {\n                let n = parseInt(v || \"12\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 100) n = 100;\n                updateProp(\"font_size\", n);\n            });\n\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"wifi_signal\") {\n            // WiFi Signal Strength Widget\n            // Entity ID with built-in picker (for remote HA sensors)\n            this.addLabeledInputWithPicker(\"WiFi Signal Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n\n            this.addCheckbox(\"Local / On-Device Sensor\", props.is_local_sensor !== false, (v) => updateProp(\"is_local_sensor\", v));\n            this.addCheckbox(\"Show dBm value\", props.show_dbm !== false, (v) => updateProp(\"show_dbm\", v));\n            this.addCheckbox(\"Fit icon to frame\", props.fit_icon_to_frame || false, (v) => updateProp(\"fit_icon_to_frame\", v));\n\n            this.addLabeledInput(\"Icon Size (px)\", \"number\", props.size || 24, (v) => {\n                let n = parseInt(v || \"24\", 10);\n                if (Number.isNaN(n) || n < 16) n = 16;\n                if (n > 200) n = 200;\n                updateProp(\"size\", n);\n            });\n\n            this.addLabeledInput(\"dBm Font Size (px)\", \"number\", props.font_size || 12, (v) => {\n                let n = parseInt(v || \"12\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 100) n = 100;\n                updateProp(\"font_size\", n);\n            });\n\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"ondevice_temperature\") {\n            // On-Device Temperature Widget (SHT4x sensor)\n            this.addLabeledInputWithPicker(\"Temperature Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n\n            this.addCheckbox(\"Local / On-Device Sensor\", props.is_local_sensor !== false, (v) => updateProp(\"is_local_sensor\", v));\n            this.addCheckbox(\"Fit icon to frame\", props.fit_icon_to_frame || false, (v) => updateProp(\"fit_icon_to_frame\", v));\n            this.addCheckbox(\"Show Label\", props.show_label !== false, (v) => updateProp(\"show_label\", v));\n\n            this.addLabeledInput(\"Icon Size (px)\", \"number\", props.size || 32, (v) => {\n                let n = parseInt(v || \"32\", 10);\n                if (Number.isNaN(n) || n < 16) n = 16;\n                if (n > 200) n = 200;\n                updateProp(\"size\", n);\n            });\n\n            this.addLabeledInput(\"Value Font Size (px)\", \"number\", props.font_size || 16, (v) => {\n                let n = parseInt(v || \"16\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 200) n = 200;\n                updateProp(\"font_size\", n);\n            });\n\n            this.addLabeledInput(\"Label Font Size (px)\", \"number\", props.label_font_size || 10, (v) => {\n                let n = parseInt(v || \"10\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 100) n = 100;\n                updateProp(\"label_font_size\", n);\n            });\n\n            this.addSelect(\"Unit\", props.unit || \"┬░C\", [\"┬░C\", \"┬░F\"], (v) => updateProp(\"unit\", v));\n            this.addLabeledInput(\"Precision\", \"number\", props.precision ?? 1, (v) => updateProp(\"precision\", parseInt(v, 10)));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"ondevice_humidity\") {\n            // On-Device Humidity Widget (SHT4x sensor)\n            this.addLabeledInputWithPicker(\"Humidity Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n\n            this.addCheckbox(\"Local / On-Device Sensor\", props.is_local_sensor !== false, (v) => updateProp(\"is_local_sensor\", v));\n            this.addCheckbox(\"Fit icon to frame\", props.fit_icon_to_frame || false, (v) => updateProp(\"fit_icon_to_frame\", v));\n            this.addCheckbox(\"Show Label\", props.show_label !== false, (v) => updateProp(\"show_label\", v));\n\n            this.addLabeledInput(\"Icon Size (px)\", \"number\", props.size || 32, (v) => {\n                let n = parseInt(v || \"32\", 10);\n                if (Number.isNaN(n) || n < 16) n = 16;\n                if (n > 200) n = 200;\n                updateProp(\"size\", n);\n            });\n\n            this.addLabeledInput(\"Value Font Size (px)\", \"number\", props.font_size || 16, (v) => {\n                let n = parseInt(v || \"16\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 200) n = 200;\n                updateProp(\"font_size\", n);\n            });\n\n            this.addLabeledInput(\"Label Font Size (px)\", \"number\", props.label_font_size || 10, (v) => {\n                let n = parseInt(v || \"10\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 100) n = 100;\n                updateProp(\"label_font_size\", n);\n            });\n\n            this.addLabeledInput(\"Unit\", \"text\", props.unit || \"%\", (v) => updateProp(\"unit\", v));\n            this.addLabeledInput(\"Precision\", \"number\", props.precision ?? 0, (v) => updateProp(\"precision\", parseInt(v, 10)));\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n\n        else if (type === \"weather_icon\") {\n\n            // Fix: Add Entity ID picker for weather_icon\n            this.addLabeledInputWithPicker(\"Weather Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n\n            this.addCheckbox(\"Fit icon to frame\", props.fit_icon_to_frame || false, (v) => updateProp(\"fit_icon_to_frame\", v));\n\n            this.addLabeledInput(\"Icon Size (px)\", \"number\", props.size || 48, (v) => {\n                let n = parseInt(v || \"48\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                if (n > 260) n = 260;\n                updateProp(\"size\", n);\n            });\n\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"weather_forecast\") {\n            this.addLabeledInputWithPicker(\"Weather Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n\n            this.addSelect(\"Layout\", props.layout || \"horizontal\", [\"horizontal\", \"vertical\"], (v) => updateProp(\"layout\", v));\n\n            this.addCheckbox(\"Show High/Low Temp\", props.show_high_low !== false, (v) => updateProp(\"show_high_low\", v));\n\n            this.addSectionLabel(\"Typography\");\n            this.addLabeledInput(\"Day Font Size\", \"number\", props.day_font_size || 14, (v) => updateProp(\"day_font_size\", parseInt(v, 10)));\n            this.addLabeledInput(\"Temp Font Size\", \"number\", props.temp_font_size || 14, (v) => updateProp(\"temp_font_size\", parseInt(v, 10)));\n            this.addLabeledInput(\"Icon Size\", \"number\", props.icon_size || 24, (v) => updateProp(\"icon_size\", parseInt(v, 10)));\n\n            // Font Family with Custom Support\n            const fontOptions = [\"Roboto\", \"Inter\", \"Open Sans\", \"Lato\", \"Montserrat\", \"Poppins\", \"Raleway\", \"Roboto Mono\", \"Ubuntu\", \"Nunito\", \"Playfair Display\", \"Merriweather\", \"Work Sans\", \"Source Sans Pro\", \"Quicksand\", \"Custom...\"];\n            const currentFont = props.font_family || \"Roboto\";\n            const isCustom = !fontOptions.slice(0, -1).includes(currentFont);\n\n            this.addSelect(\"Font\", isCustom ? \"Custom...\" : currentFont, fontOptions, (v) => {\n                if (v !== \"Custom...\") {\n                    updateProp(\"font_family\", v);\n                    updateProp(\"custom_font_family\", \"\");\n                } else {\n                    updateProp(\"font_family\", \"Custom...\");\n                }\n            });\n\n            if (isCustom || props.font_family === \"Custom...\") {\n                this.addLabeledInput(\"Custom Font Name\", \"text\", props.custom_font_family || (isCustom ? currentFont : \"\"), (v) => {\n                    updateProp(\"font_family\", v || \"Roboto\");\n                    updateProp(\"custom_font_family\", v);\n                });\n                this.addHint('Browse <a href=\"https://fonts.google.com\" target=\"_blank\">fonts.google.com</a>');\n            }\n\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n\n            this.addSectionLabel(\"Frame & Background\");\n            this.addCheckbox(\"Show Border\", props.show_border !== false, (v) => updateProp(\"show_border\", v));\n            if (props.show_border !== false) {\n                this.addLabeledInput(\"Border Width\", \"number\", props.border_width !== undefined ? props.border_width : 1, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n                this.addColorSelector(\"Border Color\", props.border_color || \"black\", colors, (v) => updateProp(\"border_color\", v));\n            }\n            this.addColorSelector(\"Background Color\", props.background_color || \"transparent\", colors, (v) => updateProp(\"background_color\", v));\n        }\n        else if (type === \"template_sensor_bar\") {\n            this.addSectionLabel(\"Sensor Visibility\");\n            this.addCheckbox(\"Show WiFi\", props.show_wifi !== false, (v) => updateProp(\"show_wifi\", v));\n            this.addCheckbox(\"Show Temperature\", props.show_temperature !== false, (v) => updateProp(\"show_temperature\", v));\n            this.addCheckbox(\"Show Humidity\", props.show_humidity !== false, (v) => updateProp(\"show_humidity\", v));\n            this.addCheckbox(\"Show Battery\", props.show_battery !== false, (v) => updateProp(\"show_battery\", v));\n\n            this.addSectionLabel(\"Appearance\");\n            this.addCheckbox(\"Show Background\", props.show_background !== false, (v) => updateProp(\"show_background\", v));\n            if (props.show_background !== false) {\n                this.addColorSelector(\"Background Color\", props.background_color || \"black\", colors, (v) => updateProp(\"background_color\", v));\n                this.addLabeledInput(\"Border Radius\", \"number\", props.border_radius || 8, (v) => updateProp(\"border_radius\", parseInt(v, 10)));\n            }\n\n            this.addSectionLabel(\"Sizes & Color\");\n            this.addLabeledInput(\"Icon Size\", \"number\", props.icon_size || 20, (v) => updateProp(\"icon_size\", parseInt(v, 10)));\n            this.addLabeledInput(\"Font Size\", \"number\", props.font_size || 14, (v) => updateProp(\"font_size\", parseInt(v, 10)));\n            this.addColorSelector(\"Foreground Color\", props.color || \"white\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"template_nav_bar\") {\n            this.addSectionLabel(\"Button Visibility\");\n            this.addCheckbox(\"Show Previous\", props.show_prev !== false, (v) => updateProp(\"show_prev\", v));\n            this.addCheckbox(\"Show Home\", props.show_home !== false, (v) => updateProp(\"show_home\", v));\n            this.addCheckbox(\"Show Next\", props.show_next !== false, (v) => updateProp(\"show_next\", v));\n\n            this.addSectionLabel(\"Appearance\");\n            this.addCheckbox(\"Show Background\", props.show_background !== false, (v) => updateProp(\"show_background\", v));\n            if (props.show_background !== false) {\n                this.addColorSelector(\"Background Color\", props.background_color || \"black\", colors, (v) => updateProp(\"background_color\", v));\n                this.addLabeledInput(\"Border Radius\", \"number\", props.border_radius || 8, (v) => updateProp(\"border_radius\", parseInt(v, 10)));\n            }\n\n            this.addSectionLabel(\"Sizes & Color\");\n            this.addLabeledInput(\"Icon Size\", \"number\", props.icon_size || 24, (v) => updateProp(\"icon_size\", parseInt(v, 10)));\n            this.addColorSelector(\"Foreground Color\", props.color || \"white\", colors, (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"touch_area\") {\n\n            // Navigation Action dropdown\n            this.addSelect(\"Navigation Action\", props.nav_action || \"none\", [\n                { value: \"none\", label: \"None (Entity Toggle)\" },\n                { value: \"next_page\", label: \"Next Page\" },\n                { value: \"previous_page\", label: \"Previous Page\" },\n                { value: \"reload_page\", label: \"Reload Page\" }\n            ], (v) => {\n                updateProp(\"nav_action\", v);\n                // Auto-set icon when action changes if no icon is set or if it's one of the defaults\n                const isDefaultNavIcon = props.icon === \"F0142\" || props.icon === \"F0141\" || props.icon === \"F0450\" || !props.icon;\n                if (isDefaultNavIcon) {\n                    if (v === \"next_page\") updateProp(\"icon\", \"F0142\");\n                    else if (v === \"previous_page\") updateProp(\"icon\", \"F0141\");\n                    else if (v === \"reload_page\") updateProp(\"icon\", \"F0450\");\n                }\n            });\n\n            // Only show entity picker if nav_action is \"none\"\n            if ((props.nav_action || \"none\") === \"none\") {\n                this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n            }\n\n            this.addLabeledInput(\"Title\", \"text\", props.title || \"\", (v) => updateProp(\"title\", v));\n            this.addIconPicker(\"Icon\", props.icon || \"\", (v) => updateProp(\"icon\", v), widget);\n            this.addLabeledInput(\"Icon Size\", \"number\", props.icon_size || 40, (v) => updateProp(\"icon_size\", parseInt(v, 10)));\n            this.addColorSelector(\"Icon Color\", props.icon_color || \"black\", colors, (v) => updateProp(\"icon_color\", v));\n            this.addColorSelector(\"Background Color\", props.color || \"rgba(0, 0, 255, 0.2)\", colors, (v) => updateProp(\"color\", v));\n            this.addColorSelector(\"Border Color\", props.border_color || \"#0000ff\", colors, (v) => updateProp(\"border_color\", v));\n        }\n        else if (type === \"image\") {\n            this.addHint(\"­ƒû╝´©Å Static image from ESPHome:<br/><code style='background:#f0f0f0;padding:2px 4px;border-radius:2px;'>/config/esphome/images/logo.png</code><br/><span style='color:#4a9eff;'>Ôä╣´©Å Place images in /config/esphome/images/ folder</span>\");\n            this.addLabeledInput(\"Image Path\", \"text\", props.path || \"\", (v) => updateProp(\"path\", v));\n\n            if (props.invert === undefined) {\n                updateProp(\"invert\", getDeviceModel() === \"reterminal_e1001\");\n            }\n            this.addCheckbox(\"Invert colors\", props.invert || false, (v) => updateProp(\"invert\", v));\n\n            this.addSelect(\"Render Mode\", props.render_mode || \"Auto\", [\"Auto\", \"Binary\", \"Grayscale\", \"Color (RGB565)\"], (v) => updateProp(\"render_mode\", v));\n\n            // Fill Screen Button\n            const fillWrap = document.createElement(\"div\");\n            fillWrap.className = \"field\";\n            fillWrap.style.marginTop = \"12px\";\n            const isFullScreen = (widget.x === 0 && widget.y === 0 && widget.width === 800 && widget.height === 480); // Assuming 800x480\n            const fillBtn = document.createElement(\"button\");\n            fillBtn.className = \"btn \" + (isFullScreen ? \"btn-primary\" : \"btn-secondary\") + \" btn-full\";\n            fillBtn.textContent = isFullScreen ? \"Ô£ô Full Screen (click to restore)\" : \"ÔøÂ Fill Screen\";\n            fillBtn.type = \"button\";\n            fillBtn.addEventListener(\"click\", () => {\n                if (isFullScreen) {\n                    AppState.updateWidget(widget.id, { x: 50, y: 50, width: 200, height: 150 });\n                } else {\n                    AppState.updateWidget(widget.id, { x: 0, y: 0, width: 800, height: 480 });\n                }\n            });\n            fillWrap.appendChild(fillBtn);\n            this.panel.appendChild(fillWrap);\n        }\n        else if (type === \"online_image\") {\n            this.addHint(\"­ƒÆí Fetch remote images dynamically (Puppet support):<br/><code style='background:#f0f0f0;padding:2px 4px;border-radius:2px;'>https://example.com/camera/snapshot.jpg </code><br/><span style='color:#4a9eff;'>Ôä╣´©Å Images are downloaded at specified intervals</span>\");\n            this.addLabeledInput(\"Remote URL\", \"text\", props.url || \"\", (v) => updateProp(\"url\", v));\n            this.addLabeledInput(\"Update interval (seconds)\", \"number\", props.interval_s || 300, (v) => updateProp(\"interval_s\", parseInt(v, 10)));\n\n            if (props.invert === undefined) {\n                updateProp(\"invert\", getDeviceModel() === \"reterminal_e1001\");\n            }\n            this.addCheckbox(\"Invert colors\", props.invert || false, (v) => updateProp(\"invert\", v));\n\n            this.addSelect(\"Render Mode\", props.render_mode || \"Auto\", [\"Auto\", \"Binary\", \"Grayscale\", \"Color (RGB565)\"], (v) => updateProp(\"render_mode\", v));\n\n            // Fill Screen Button\n            const fillWrap = document.createElement(\"div\");\n            fillWrap.className = \"field\";\n            fillWrap.style.marginTop = \"12px\";\n            const isFullScreen = (widget.x === 0 && widget.y === 0 && widget.width === 800 && widget.height === 480);\n            const fillBtn = document.createElement(\"button\");\n            fillBtn.className = \"btn \" + (isFullScreen ? \"btn-primary\" : \"btn-secondary\") + \" btn-full\";\n            fillBtn.textContent = isFullScreen ? \"Ô£ô Full Screen (click to restore)\" : \"ÔøÂ Fill Screen\";\n            fillBtn.type = \"button\";\n            fillBtn.addEventListener(\"click\", () => {\n                if (isFullScreen) {\n                    AppState.updateWidget(widget.id, { x: 50, y: 50, width: 200, height: 150 });\n                } else {\n                    AppState.updateWidget(widget.id, { x: 0, y: 0, width: 800, height: 480 });\n                }\n            });\n            fillWrap.appendChild(fillBtn);\n            this.panel.appendChild(fillWrap);\n        }\n        else if (type === \"qr_code\") {\n            this.addHint(\"­ƒô▒ Generate QR codes that can be scanned by phones/tablets\");\n            this.addLabeledInput(\"QR Content\", \"text\", props.value || \"https://esphome.io\", (v) => updateProp(\"value\", v));\n            this.addHint(\"Enter a URL, text, or any string to encode\");\n\n            this.addLabeledInput(\"Scale\", \"number\", props.scale || 2, (v) => {\n                let n = parseInt(v || \"2\", 10);\n                if (Number.isNaN(n) || n < 1) n = 1;\n                if (n > 10) n = 10;\n                updateProp(\"scale\", n);\n            });\n            this.addHint(\"Size multiplier (1-10). Larger = bigger QR code\");\n\n            this.addSelect(\"Error Correction\", props.ecc || \"LOW\", [\"LOW\", \"MEDIUM\", \"QUARTILE\", \"HIGH\"], (v) => updateProp(\"ecc\", v));\n            this.addHint(\"Higher = more redundancy, can recover from damage\");\n\n            this.addSelect(\"Color\", props.color || \"black\", [\"black\", \"white\"], (v) => updateProp(\"color\", v));\n        }\n        else if (type === \"quote_rss\") {\n            // Quote / RSS Feed Widget Properties\n            this.addHint(\"­ƒô░ Display quotes from an RSS feed (Quote of the Day)\");\n\n            this.addLabeledInput(\"Feed URL\", \"text\", props.feed_url || \"https://www.brainyquote.com/link/quotebr.rss\", (v) => updateProp(\"feed_url\", v));\n            this.addHint(\"Enter any RSS feed URL. Default: BrainyQuote daily quotes\");\n\n            this.addCheckbox(\"Show Author\", props.show_author !== false, (v) => updateProp(\"show_author\", v));\n            this.addCheckbox(\"Random Quote\", props.random !== false, (v) => updateProp(\"random\", v));\n            this.addHint(\"Pick a random quote from the feed, or use the first one\");\n\n            // Refresh interval\n            const refreshOptions = [\"15min\", \"30min\", \"1h\", \"2h\", \"4h\", \"8h\", \"12h\", \"24h\"];\n            this.addSelect(\"Refresh Interval\", props.refresh_interval || \"24h\", refreshOptions, (v) => updateProp(\"refresh_interval\", v));\n\n            this.addSectionLabel(\"Typography\");\n\n            this.addLabeledInput(\"Quote Text Size (Line 1)\", \"number\", props.quote_font_size || 18, (v) => updateProp(\"quote_font_size\", parseInt(v, 10)));\n            this.addLabeledInput(\"Author Size (Line 2)\", \"number\", props.author_font_size || 14, (v) => updateProp(\"author_font_size\", parseInt(v, 10)));\n\n            // Font Family with Custom Support\n            const fontOptions = [\"Roboto\", \"Inter\", \"Open Sans\", \"Lato\", \"Montserrat\", \"Poppins\", \"Raleway\", \"Roboto Mono\", \"Ubuntu\", \"Nunito\", \"Playfair Display\", \"Merriweather\", \"Work Sans\", \"Source Sans Pro\", \"Quicksand\", \"Custom...\"];\n            const currentFont = props.font_family || \"Roboto\";\n            const isCustom = !fontOptions.slice(0, -1).includes(currentFont);\n\n            this.addSelect(\"Font\", isCustom ? \"Custom...\" : currentFont, fontOptions, (v) => {\n                if (v !== \"Custom...\") {\n                    updateProp(\"font_family\", v);\n                    updateProp(\"custom_font_family\", \"\");\n                } else {\n                    updateProp(\"font_family\", \"Custom...\");\n                }\n            });\n\n            if (isCustom || props.font_family === \"Custom...\") {\n                this.addLabeledInput(\"Custom Font Name\", \"text\", props.custom_font_family || (isCustom ? currentFont : \"\"), (v) => {\n                    updateProp(\"font_family\", v || \"Roboto\");\n                    updateProp(\"custom_font_family\", v);\n                });\n                this.addHint('Browse <a href=\"https://fonts.google.com\" target=\"_blank\">fonts.google.com</a>');\n            }\n\n            this.addSelect(\"Weight\", props.font_weight || 400, [100, 200, 300, 400, 500, 600, 700, 800, 900], (v) => updateProp(\"font_weight\", parseInt(v, 10)));\n\n            // Text Alignment\n            const alignOptions = [\n                \"TOP_LEFT\", \"TOP_CENTER\", \"TOP_RIGHT\",\n                \"CENTER_LEFT\", \"CENTER\", \"CENTER_RIGHT\",\n                \"BOTTOM_LEFT\", \"BOTTOM_CENTER\", \"BOTTOM_RIGHT\"\n            ];\n            this.addSelect(\"Align\", props.text_align || \"TOP_LEFT\", alignOptions, (v) => updateProp(\"text_align\", v));\n\n            this.addColorSelector(\"Color\", props.color || \"black\", colors, (v) => updateProp(\"color\", v));\n\n            this.addSectionLabel(\"Display Options\");\n\n            this.addCheckbox(\"Word Wrap\", props.word_wrap !== false, (v) => updateProp(\"word_wrap\", v));\n            this.addCheckbox(\"Auto Scale Text\", props.auto_scale || false, (v) => updateProp(\"auto_scale\", v));\n            this.addHint(\"Automatically reduce font size if text is too long\");\n            this.addCheckbox(\"Italic Quote\", props.italic_quote !== false, (v) => updateProp(\"italic_quote\", v));\n        }\n        else if (type === \"calendar\") {\n            this.addSectionLabel(\"Appearance\");\n            this.addColorSelector(\"Text Color\", props.text_color || \"black\", colors, (v) => updateProp(\"text_color\", v));\n            this.addColorSelector(\"Border Color\", props.border_color || \"black\", colors, (v) => updateProp(\"border_color\", v));\n            this.addColorSelector(\"Background\", props.background_color || \"white\", colors, (v) => updateProp(\"background_color\", v));\n\n            this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 2, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n            this.addCheckbox(\"Show Border\", props.show_border !== false, (v) => updateProp(\"show_border\", v));\n\n            this.addSectionLabel(\"Font Sizes\");\n            this.addLabeledInput(\"Big Date Size\", \"number\", props.font_size_date || 100, (v) => updateProp(\"font_size_date\", parseInt(v, 10)));\n            this.addLabeledInput(\"Day Name Size\", \"number\", props.font_size_day || 24, (v) => updateProp(\"font_size_day\", parseInt(v, 10)));\n            this.addLabeledInput(\"Grid Text Size\", \"number\", props.font_size_grid || 14, (v) => updateProp(\"font_size_grid\", parseInt(v, 10)));\n            this.addLabeledInput(\"Event Text Size\", \"number\", props.font_size_event || 18, (v) => updateProp(\"font_size_event\", parseInt(v, 10)));\n\n            this.addSectionLabel(\"Data\");\n            this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"sensor.esp_calendar_data\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n            this.addLabeledInput(\"Max Events\", \"number\", props.max_events || 8, (v) => updateProp(\"max_events\", parseInt(v, 10)));\n            this.addHint(\"Must be a sensor with attribute 'entries'\");\n\n            // Helper Script Download\n            const dlBtn = document.createElement(\"button\");\n            dlBtn.className = \"btn btn-secondary btn-full\";\n            dlBtn.textContent = \"Download Helper Script\";\n            dlBtn.style.marginTop = \"10px\";\n            dlBtn.addEventListener(\"click\", () => {\n                const element = document.createElement('a');\n                element.setAttribute('href', 'data:text/x-python;charset=utf-8,' + encodeURIComponent(CALENDAR_HELPER_SCRIPT));\n                element.setAttribute('download', 'esp_calendar_data_conversion.py');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n            });\n            this.panel.appendChild(dlBtn);\n            this.addHint(\"Place in /config/python_scripts/\");\n        }\n        else if (type === \"puppet\") {\n            this.addLabeledInput(\"File path / URL\", \"text\", props.image_url || \"\", (v) => updateProp(\"image_url\", v));\n            this.addHint('Tip: Use mdi:icon-name for Material Design Icons. <br><b>Important:</b> Ensure `materialdesignicons-webfont.ttf` is in your ESPHome `fonts/` folder. <a href=\"https://pictogrammers.com/library/mdi/\" target=\"_blank\" style=\"color: #52c7ea\">MDI Library</a>');\n\n            this.addSelect(\"Image type\", props.image_type || \"RGB565\", [\"RGB565\", \"RGB\", \"GRAYSCALE\", \"BINARY\"], (v) => updateProp(\"image_type\", v));\n            this.addHint(\"RGB565=2B/px, RGB=3B/px, GRAYSCALE=1B/px, BINARY=1bit/px\");\n\n            this.addSelect(\"Transparency\", props.transparency || \"opaque\", [\"opaque\", \"chroma_key\", \"alpha_channel\"], (v) => updateProp(\"transparency\", v));\n            this.addHint(\"opaque=no transparency, chroma_key=color key, alpha_channel=smooth blend\");\n        }\n        else if (type === \"touch_area\") {\n            this.addLabeledInputWithPicker(\"Entity ID (Binary Sensor)\", \"text\", widget.entity_id || \"\", (v) => {\n                AppState.updateWidget(widget.id, { entity_id: v });\n            }, widget);\n            this.addHint(\"ID for the binary_sensor (e.g. my_touch_button)\");\n\n            this.addLabeledInput(\"Label (Preview)\", \"text\", props.title || \"Touch Area\", (v) => updateProp(\"title\", v));\n\n            // User requested non-LVGL style color picker. \n            // We'll use a simple native picker for color and a slider for opacity.\n            // But we need to combine them into RGBA.\n            const currentColor = props.color || \"rgba(0, 0, 255, 0.2)\";\n            // Naive parse or default\n            let hex = \"#0000ff\";\n            let alpha = 0.2;\n            if (currentColor.startsWith(\"#\")) {\n                hex = currentColor;\n                alpha = 1.0;\n            } else if (currentColor.startsWith(\"rgba\")) {\n                const parts = currentColor.match(/([\\d\\.]+)/g);\n                if (parts && parts.length >= 4) {\n                    const r = parseInt(parts[0]);\n                    const g = parseInt(parts[1]);\n                    const b = parseInt(parts[2]);\n                    alpha = parseFloat(parts[3]);\n                    hex = \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n                }\n            }\n\n            this.addLabeledInput(\"Preview Color\", \"color\", hex, (v) => {\n                // Convert back to rgba\n                // v is hex\n                const r = parseInt(v.slice(1, 3), 16);\n                const g = parseInt(v.slice(3, 5), 16);\n                const b = parseInt(v.slice(5, 7), 16);\n                updateProp(\"color\", `rgba(${r}, ${g}, ${b}, ${alpha})`);\n            });\n\n            this.addLabeledInput(\"Opacity (0.0 - 1.0)\", \"number\", alpha, (v) => {\n                let a = parseFloat(v);\n                if (a < 0) a = 0; if (a > 1) a = 1;\n                // Reconstruct RGBA\n                const r = parseInt(hex.slice(1, 3), 16);\n                const g = parseInt(hex.slice(3, 5), 16);\n                const b = parseInt(hex.slice(5, 7), 16);\n                updateProp(\"color\", `rgba(${r}, ${g}, ${b}, ${a})`);\n            });\n\n            this.addLabeledInput(\"Border Color\", \"color\", props.border_color || \"#0000ff\", (v) => updateProp(\"border_color\", v));\n\n            this.addSectionLabel(\"Icons\");\n            this.addIconPicker(\"Normal Icon\", props.icon || \"\", (v) => updateProp(\"icon\", v), widget);\n            this.addIconPicker(\"Pressed Icon\", props.icon_pressed || \"\", (v) => updateProp(\"icon_pressed\", v), widget);\n            this.addHint(\"Leave Normal Icon empty for invisible touch area. Pressed Icon is optional.\");\n\n            this.addLabeledInput(\"Icon Size (px)\", \"number\", props.icon_size || 40, (v) => {\n                let n = parseInt(v || \"40\", 10);\n                if (Number.isNaN(n) || n < 8) n = 8;\n                updateProp(\"icon_size\", n);\n            });\n\n            this.addColorSelector(\"Icon Color\", props.icon_color || \"black\", colors, (v) => updateProp(\"icon_color\", v));\n        }\n        else if (type === \"lvgl_label\" || type.startsWith(\"lvgl_\")) {\n            // Apply common LVGL properties to all lvgl_* widgets\n            this.addCommonLVGLProperties(widget, props);\n            this.addSectionLabel(\"Widget Settings\");\n\n            if (type === \"lvgl_label\") {\n                this.addLabeledInput(\"Text\", \"text\", props.text || \"Label\", (v) => updateProp(\"text\", v));\n                this.addLabeledInput(\"Font Size\", \"number\", props.font_size || 20, (v) => updateProp(\"font_size\", parseInt(v, 10)));\n                this.addColorMixer(\"Text Color\", props.color || \"black\", (v) => updateProp(\"color\", v));\n                this.addColorMixer(\"Background Color\", props.bg_color || \"transparent\", (v) => updateProp(\"bg_color\", v));\n\n                // Font Family\n                const fontOptions = [\"Roboto\", \"Inter\", \"Open Sans\", \"Lato\", \"Montserrat\", \"Poppins\", \"Raleway\", \"Roboto Mono\", \"Ubuntu\", \"Nunito\", \"Playfair Display\", \"Merriweather\", \"Work Sans\", \"Source Sans Pro\", \"Quicksand\", \"Custom...\"];\n                const currentFont = props.font_family || \"Roboto\";\n                const isCustom = !fontOptions.slice(0, -1).includes(currentFont);\n\n                this.addSelect(\"Font\", isCustom ? \"Custom...\" : currentFont, fontOptions, (v) => {\n                    if (v !== \"Custom...\") {\n                        updateProp(\"font_family\", v);\n                    } else {\n                        updateProp(\"font_family\", \"Custom...\");\n                    }\n                });\n\n                this.addSelect(\"Weight\", props.font_weight || 400, [100, 200, 300, 400, 500, 600, 700, 800, 900], (v) => updateProp(\"font_weight\", parseInt(v, 10)));\n                this.addCheckbox(\"Italic\", props.italic || false, (v) => updateProp(\"italic\", v));\n\n                // Alignment\n                const alignOptions = [\"TOP_LEFT\", \"TOP_CENTER\", \"TOP_RIGHT\", \"CENTER_LEFT\", \"CENTER\", \"CENTER_RIGHT\", \"BOTTOM_LEFT\", \"BOTTOM_CENTER\", \"BOTTOM_RIGHT\"];\n                this.addSelect(\"Align\", props.text_align || \"CENTER\", alignOptions, (v) => updateProp(\"text_align\", v));\n            }\n            else if (type === \"lvgl_line\") {\n                // \"Like non-LVGL widget\": Simple Horizontal/Vertical orientation with fill options\n                const orientation = props.orientation || \"horizontal\";\n                this.addSelect(\"Orientation\", orientation, [\"horizontal\", \"vertical\"], (v) => {\n                    // When changing orientation, swap width/height to preserve 'length' feel\n                    const oldW = widget.width;\n                    const oldH = widget.height;\n                    AppState.updateWidget(widget.id, {\n                        props: { ...props, orientation: v },\n                        width: oldH,\n                        height: oldW\n                    });\n                });\n\n                this.addLabeledInput(\"Line Width\", \"number\", props.line_width || 3, (v) => updateProp(\"line_width\", parseInt(v, 10)));\n                this.addColorMixer(\"Line Color\", props.line_color || props.color || \"black\", (v) => updateProp(\"line_color\", v));\n                this.addCheckbox(\"Rounded Ends\", props.line_rounded !== false, (v) => updateProp(\"line_rounded\", v));\n                this.addLabeledInput(\"Opacity (0-255)\", \"number\", props.opa || 255, (v) => updateProp(\"opa\", parseInt(v, 10)));\n\n                // Fill Horizontal / Fill Vertical buttons\n                this.addSectionLabel(\"Quick Size\");\n                const fillBtnContainer = document.createElement(\"div\");\n                fillBtnContainer.style.display = \"flex\";\n                fillBtnContainer.style.gap = \"8px\";\n                fillBtnContainer.style.marginBottom = \"8px\";\n\n                const resolution = AppState.getCanvasDimensions();\n                const canvasW = resolution.width;\n                const canvasH = resolution.height;\n\n                const fillHBtn = document.createElement(\"button\");\n                fillHBtn.className = \"btn btn-secondary\";\n                fillHBtn.style.flex = \"1\";\n                fillHBtn.textContent = \"Ôåö Fill Horizontal\";\n                fillHBtn.addEventListener(\"click\", () => {\n                    const lw = props.line_width || 3;\n                    AppState.updateWidget(widget.id, {\n                        x: 0,\n                        y: widget.y,\n                        width: canvasW,\n                        height: lw,\n                        props: { ...props, orientation: \"horizontal\" }\n                    });\n                });\n\n                const fillVBtn = document.createElement(\"button\");\n                fillVBtn.className = \"btn btn-secondary\";\n                fillVBtn.style.flex = \"1\";\n                fillVBtn.textContent = \"Ôåò Fill Vertical\";\n                fillVBtn.addEventListener(\"click\", () => {\n                    const lw = props.line_width || 3;\n                    AppState.updateWidget(widget.id, {\n                        x: widget.x,\n                        y: 0,\n                        width: lw,\n                        height: canvasH,\n                        props: { ...props, orientation: \"vertical\" }\n                    });\n                });\n\n                fillBtnContainer.appendChild(fillHBtn);\n                fillBtnContainer.appendChild(fillVBtn);\n                this.panel.appendChild(fillBtnContainer);\n            }\n            else if (type === \"lvgl_meter\") {\n                this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n\n                this.addSectionLabel(\"Scale\");\n                this.addLabeledInput(\"Min Value\", \"number\", props.min || 0, (v) => updateProp(\"min\", parseInt(v, 10)));\n                this.addLabeledInput(\"Max Value\", \"number\", props.max || 100, (v) => updateProp(\"max\", parseInt(v, 10)));\n\n                this.addSectionLabel(\"Preview\");\n                this.addLabeledInput(\"Value (Preview)\", \"number\", props.value !== undefined ? props.value : 60, (v) => updateProp(\"value\", parseInt(v, 10)));\n\n                this.addSectionLabel(\"Appearance\");\n                this.addColorMixer(\"Scale Color\", props.color || \"black\", (v) => updateProp(\"color\", v));\n                this.addColorMixer(\"Needle Color\", props.indicator_color || \"red\", (v) => updateProp(\"indicator_color\", v));\n                this.addLabeledInput(\"Scale Width\", \"number\", props.scale_width || 10, (v) => updateProp(\"scale_width\", parseInt(v, 10)));\n                this.addLabeledInput(\"Needle Width\", \"number\", props.indicator_width || 4, (v) => updateProp(\"indicator_width\", parseInt(v, 10)));\n                this.addLabeledInput(\"Ticks\", \"number\", props.tick_count || 11, (v) => updateProp(\"tick_count\", parseInt(v, 10)));\n                this.addLabeledInput(\"Tick Length\", \"number\", props.tick_length || 10, (v) => updateProp(\"tick_length\", parseInt(v, 10)));\n                this.addLabeledInput(\"Label Gap\", \"number\", props.label_gap || 10, (v) => updateProp(\"label_gap\", parseInt(v, 10)));\n            }\n\n            else if (type === \"lvgl_button\") {\n                this.addLabeledInputWithPicker(\"Action Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n                this.addHint(\"Entity to toggle/trigger when clicked\");\n\n                this.addLabeledInput(\"Text\", \"text\", props.text || \"BTN\", (v) => updateProp(\"text\", v));\n                this.addColorMixer(\"Background Color\", props.bg_color || \"white\", (v) => updateProp(\"bg_color\", v));\n                this.addColorMixer(\"Text Color\", props.color || \"black\", (v) => updateProp(\"color\", v));\n                this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 2, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n                this.addLabeledInput(\"Corner Radius\", \"number\", props.radius || 5, (v) => updateProp(\"radius\", parseInt(v, 10)));\n                this.addCheckbox(\"Checkable (Toggle)\", props.checkable || false, (v) => updateProp(\"checkable\", v));\n            }\n            else if (type === \"lvgl_arc\") {\n                this.addLabeledInputWithPicker(\"Sensor Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n                this.addHint(\"Sensor to bind to arc value\");\n\n                this.addLabeledInput(\"Title / Label\", \"text\", props.title || \"\", (v) => {\n                    const newProps = { ...widget.props, title: v };\n                    AppState.updateWidget(widget.id, { props: newProps });\n                });\n\n                this.addLabeledInput(\"Min Value\", \"number\", props.min || 0, (v) => updateProp(\"min\", parseInt(v, 10)));\n                this.addLabeledInput(\"Max Value\", \"number\", props.max || 100, (v) => updateProp(\"max\", parseInt(v, 10)));\n                this.addLabeledInput(\"Default/Preview Value\", \"number\", props.value || 0, (v) => updateProp(\"value\", parseInt(v, 10)));\n\n                this.addLabeledInput(\"Thickness\", \"number\", props.thickness || 10, (v) => updateProp(\"thickness\", parseInt(v, 10)));\n                this.addLabeledInput(\"Start Angle\", \"number\", props.start_angle || 135, (v) => updateProp(\"start_angle\", parseInt(v, 10)));\n                this.addLabeledInput(\"End Angle\", \"number\", props.end_angle || 45, (v) => updateProp(\"end_angle\", parseInt(v, 10)));\n                this.addSelect(\"Mode\", props.mode || \"NORMAL\", [\"NORMAL\", \"SYMMETRICAL\", \"REVERSE\"], (v) => updateProp(\"mode\", v));\n                this.addColorMixer(\"Color\", props.color || \"blue\", (v) => updateProp(\"color\", v));\n            }\n            else if (type === \"lvgl_chart\") {\n                this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n                this.addLabeledInput(\"Title\", \"text\", props.title || \"\", (v) => updateProp(\"title\", v));\n                this.addSelect(\"Type\", props.type || \"LINE\", [\"LINE\", \"SCATTER\", \"BAR\"], (v) => updateProp(\"type\", v));\n                this.addLabeledInput(\"Min Value\", \"number\", props.min || 0, (v) => updateProp(\"min\", parseInt(v, 10)));\n                this.addLabeledInput(\"Max Value\", \"number\", props.max || 100, (v) => updateProp(\"max\", parseInt(v, 10)));\n                this.addLabeledInput(\"Point Count\", \"number\", props.point_count || 10, (v) => updateProp(\"point_count\", parseInt(v, 10)));\n                this.addLabeledInput(\"X Div Lines\", \"number\", props.x_div_lines || 3, (v) => updateProp(\"x_div_lines\", parseInt(v, 10)));\n                this.addLabeledInput(\"Y Div Lines\", \"number\", props.y_div_lines || 3, (v) => updateProp(\"y_div_lines\", parseInt(v, 10)));\n                this.addColorMixer(\"Color\", props.color || \"black\", (v) => updateProp(\"color\", v));\n            }\n            else if (type === \"lvgl_img\") {\n                this.addLabeledInput(\"Source (Image/Symbol)\", \"text\", props.src || \"\", (v) => updateProp(\"src\", v));\n                this.addHint(\"e.g. symbol_ok, symbol_home, or /image.png\");\n\n                this.addLabeledInput(\"Rotation (0.1 deg)\", \"number\", props.rotation || 0, (v) => updateProp(\"rotation\", parseInt(v, 10)));\n                this.addLabeledInput(\"Scale (256 = 1x)\", \"number\", props.scale || 256, (v) => updateProp(\"scale\", parseInt(v, 10)));\n                this.addColorMixer(\"Color (Tint)\", props.color || \"black\", (v) => updateProp(\"color\", v));\n            }\n            else if (type === \"lvgl_qrcode\") {\n                this.addLabeledInput(\"Content / URL\", \"text\", props.text || \"\", (v) => updateProp(\"text\", v));\n                this.addLabeledInput(\"Size (px)\", \"number\", props.size || 100, (v) => updateProp(\"size\", parseInt(v, 10)));\n                this.addColorMixer(\"Color\", props.color || \"black\", (v) => updateProp(\"color\", v));\n                this.addColorMixer(\"Background Color\", props.bg_color || \"white\", (v) => updateProp(\"bg_color\", v));\n            }\n            else if (type === \"lvgl_bar\") {\n                this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n\n                this.addLabeledInput(\"Min Value\", \"number\", props.min || 0, (v) => updateProp(\"min\", parseInt(v, 10)));\n                this.addLabeledInput(\"Max Value\", \"number\", props.max || 100, (v) => updateProp(\"max\", parseInt(v, 10)));\n                this.addLabeledInput(\"Preview Value\", \"number\", props.value || 50, (v) => updateProp(\"value\", parseInt(v, 10)));\n\n                this.addColorMixer(\"Bar Color\", props.color || \"black\", (v) => updateProp(\"color\", v));\n                this.addColorMixer(\"Background Color\", props.bg_color || \"gray\", (v) => updateProp(\"bg_color\", v));\n                this.addLabeledInput(\"Start Value\", \"number\", props.start_value || 0, (v) => updateProp(\"start_value\", parseInt(v, 10)));\n                this.addSelect(\"Mode\", props.mode || \"NORMAL\", [\"NORMAL\", \"SYMMETRICAL\", \"REVERSE\"], (v) => updateProp(\"mode\", v));\n                this.addCheckbox(\"Range Mode\", props.range_mode || false, (v) => updateProp(\"range_mode\", v));\n            }\n            else if (type === \"lvgl_slider\") {\n                this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n                this.addHint(\"Controls this entity number/level\");\n\n                // Orientation (vertical/horizontal)\n                const isVertical = props.vertical || false;\n                this.addSelect(\"Orientation\", isVertical ? \"Vertical\" : \"Horizontal\", [\"Horizontal\", \"Vertical\"], (v) => {\n                    const newVertical = v === \"Vertical\";\n                    // Swap width/height when changing orientation\n                    const oldW = widget.width;\n                    const oldH = widget.height;\n                    AppState.updateWidget(widget.id, {\n                        props: { ...props, vertical: newVertical },\n                        width: oldH,\n                        height: oldW\n                    });\n                });\n\n                this.addLabeledInput(\"Min Value\", \"number\", props.min || 0, (v) => updateProp(\"min\", parseInt(v, 10)));\n                this.addLabeledInput(\"Max Value\", \"number\", props.max || 100, (v) => updateProp(\"max\", parseInt(v, 10)));\n                this.addLabeledInput(\"Preview Value\", \"number\", props.value || 30, (v) => updateProp(\"value\", parseInt(v, 10)));\n\n                this.addColorMixer(\"Knob/Bar Color\", props.color || \"black\", (v) => updateProp(\"color\", v));\n                this.addColorMixer(\"Track Color\", props.bg_color || \"gray\", (v) => updateProp(\"bg_color\", v));\n                this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 2, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n                this.addSelect(\"Mode\", props.mode || \"NORMAL\", [\"NORMAL\", \"SYMMETRICAL\", \"REVERSE\"], (v) => updateProp(\"mode\", v));\n            }\n            else if (type === \"calendar\") {\n                this.addHint(\"­ƒôà Displays a monthly calendar and agenda.\");\n                this.addHint(\"ÔÜá´©Å Requires 'esp_calendar_data_conversion.py' setup in Home Assistant.\");\n\n                this.addLabeledInputWithPicker(\"Data Entity ID\", \"text\", widget.props.entity_id || \"sensor.esp_calendar_data\", (v) => {\n                    const newProps = { ...widget.props, entity_id: v };\n                    AppState.updateWidget(widget.id, { props: newProps });\n                }, widget);\n                this.addLabeledInput(\"Max Events\", \"number\", props.max_events || 8, (v) => updateProp(\"max_events\", parseInt(v, 10)));\n\n                this.addSectionLabel(\"Appearance\");\n                this.addCheckbox(\"Show Border\", props.show_border !== false, (v) => updateProp(\"show_border\", v));\n                this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 2, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n                this.addColorSelector(\"Border Color\", props.border_color || \"black\", colors, (v) => updateProp(\"border_color\", v));\n                this.addColorSelector(\"Background Color\", props.background_color || \"white\", colors, (v) => updateProp(\"background_color\", v));\n                this.addColorSelector(\"Text Color\", props.text_color || \"black\", colors, (v) => updateProp(\"text_color\", v));\n\n                this.addSectionLabel(\"Font Sizes\");\n                this.addLabeledInput(\"Big Date Size\", \"number\", props.font_size_date || 100, (v) => updateProp(\"font_size_date\", parseInt(v, 10)));\n                this.addLabeledInput(\"Day Name Size\", \"number\", props.font_size_day || 24, (v) => updateProp(\"font_size_day\", parseInt(v, 10)));\n                this.addLabeledInput(\"Grid Text Size\", \"number\", props.font_size_grid || 14, (v) => updateProp(\"font_size_grid\", parseInt(v, 10)));\n                this.addLabeledInput(\"Event Text Size\", \"number\", props.font_size_event || 18, (v) => updateProp(\"font_size_event\", parseInt(v, 10)));\n\n                // Add \"Download Helper Script\" button\n                const container = this.panel; // Or create a sub-container\n                const downloadBtn = document.createElement(\"button\");\n                downloadBtn.className = \"action-btn\"; // Assuming this class exists or button basic style\n                downloadBtn.style.marginTop = \"15px\";\n                downloadBtn.style.width = \"100%\";\n                downloadBtn.style.cursor = \"pointer\";\n                downloadBtn.style.padding = \"8px\";\n                downloadBtn.innerHTML = \"­ƒôÑ Download Helper Script\";\n\n                downloadBtn.onclick = () => {\n                    const blob = new Blob([CALENDAR_HELPER_SCRIPT], { type: \"text/x-python\" });\n                    const url = URL.createObjectURL(blob);\n                    const a = document.createElement(\"a\");\n                    a.href = url;\n                    a.download = \"esp_calendar_data_conversion.py\";\n                    document.body.appendChild(a);\n                    a.click();\n                    document.body.removeChild(a);\n                    URL.revokeObjectURL(url);\n                };\n                container.appendChild(downloadBtn);\n\n                const note = document.createElement(\"div\");\n                note.style.marginTop = \"5px\";\n                note.style.fontSize = \"10px\";\n                note.style.color = \"#888\";\n                note.style.textAlign = \"center\";\n                note.innerText = \"Check widget instructions for HA setup.\";\n                container.appendChild(note);\n            }\n            else if (type === \"lvgl_tabview\") {\n                this.addLabeledInput(\"Tabs (comma separated)\", \"text\", (props.tabs || []).join(\", \"), (v) => {\n                    const tabs = v.split(\",\").map(t => t.trim()).filter(t => t);\n                    updateProp(\"tabs\", tabs);\n                });\n                this.addColorMixer(\"Background Color\", props.bg_color || \"white\", (v) => updateProp(\"bg_color\", v));\n            }\n            else if (type === \"lvgl_tileview\") {\n                this.addHint(\"Tiles are currently configured via YAML or advanced properties.\");\n                this.addColorMixer(\"Background Color\", props.bg_color || \"white\", (v) => updateProp(\"bg_color\", v));\n            }\n            else if (type === \"lvgl_led\") {\n                this.addColorMixer(\"Color\", props.color || \"red\", (v) => updateProp(\"color\", v));\n                this.addLabeledInput(\"Brightness (0-255)\", \"number\", props.brightness || 255, (v) => updateProp(\"brightness\", parseInt(v, 10)));\n            }\n            else if (type === \"lvgl_spinner\") {\n                this.addLabeledInput(\"Spin Time (ms)\", \"number\", props.spin_time || 1000, (v) => updateProp(\"spin_time\", parseInt(v, 10)));\n                this.addLabeledInput(\"Arc Length (deg)\", \"number\", props.arc_length || 60, (v) => updateProp(\"arc_length\", parseInt(v, 10)));\n                this.addColorMixer(\"Arc Color\", props.arc_color || \"blue\", (v) => updateProp(\"arc_color\", v));\n                this.addColorMixer(\"Track Color\", props.track_color || \"white\", (v) => updateProp(\"track_color\", v));\n            }\n            else if (type === \"lvgl_buttonmatrix\") {\n                this.addHint(\"Edit rows via YAML or simple comma-separated lists per row.\");\n                // Simple editor: Row 1, Row 2...\n                const rows = props.rows || [];\n                // Just a placeholder for now\n            }\n            else if (type === \"lvgl_checkbox\") {\n                this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n                this.addHint(\"Toggle input_boolean when tapped\");\n\n                this.addLabeledInput(\"Label\", \"text\", props.text || \"Checkbox\", (v) => updateProp(\"text\", v));\n                this.addCheckbox(\"Checked\", props.checked || false, (v) => updateProp(\"checked\", v));\n                this.addColorMixer(\"Color\", props.color || \"blue\", (v) => updateProp(\"color\", v));\n            }\n            else if (type === \"lvgl_dropdown\") {\n                this.addLabeledInput(\"Options (one per line)\", \"textarea\", props.options || \"\", (v) => updateProp(\"options\", v));\n                this.addLabeledInput(\"Selected Index\", \"number\", props.selected_index || 0, (v) => updateProp(\"selected_index\", parseInt(v, 10)));\n                this.addSelect(\"Direction\", props.direction || \"DOWN\", [\"DOWN\", \"UP\", \"LEFT\", \"RIGHT\"], (v) => updateProp(\"direction\", v));\n                this.addLabeledInput(\"Max Height\", \"number\", props.max_height || 200, (v) => updateProp(\"max_height\", parseInt(v, 10)));\n                this.addColorMixer(\"Color\", props.color || \"white\", (v) => updateProp(\"color\", v));\n            }\n            else if (type === \"lvgl_keyboard\") {\n                this.addSelect(\"Mode\", props.mode || \"TEXT_UPPER\", [\"TEXT_LOWER\", \"TEXT_UPPER\", \"SPECIAL\", \"NUMBER\"], (v) => updateProp(\"mode\", v));\n                this.addLabeledInput(\"Textarea ID Link\", \"text\", props.textarea_id || \"\", (v) => updateProp(\"textarea_id\", v));\n            }\n            else if (type === \"lvgl_roller\") {\n                this.addLabeledInput(\"Options (one per line)\", \"textarea\", props.options || \"\", (v) => updateProp(\"options\", v));\n                this.addLabeledInput(\"Visible Rows\", \"number\", props.visible_row_count || 3, (v) => updateProp(\"visible_row_count\", parseInt(v, 10)));\n                this.addColorMixer(\"Color\", props.color || \"white\", (v) => updateProp(\"color\", v));\n                this.addColorMixer(\"Background Color\", props.bg_color || \"black\", (v) => updateProp(\"bg_color\", v));\n                this.addColorMixer(\"Selected BG Color\", props.selected_bg_color || \"blue\", (v) => updateProp(\"selected_bg_color\", v));\n                this.addColorMixer(\"Selected Text Color\", props.selected_text_color || \"white\", (v) => updateProp(\"selected_text_color\", v));\n                this.addSelect(\"Mode\", props.mode || \"NORMAL\", [\"NORMAL\", \"INFINITE\"], (v) => updateProp(\"mode\", v));\n            }\n            else if (type === \"lvgl_spinbox\") {\n                this.addLabeledInput(\"Min\", \"number\", props.min || 0, (v) => updateProp(\"min\", parseInt(v, 10)));\n                this.addLabeledInput(\"Max\", \"number\", props.max || 100, (v) => updateProp(\"max\", parseInt(v, 10)));\n                this.addLabeledInput(\"Value\", \"number\", props.value || 0, (v) => updateProp(\"value\", parseInt(v, 10)));\n                this.addLabeledInput(\"Digits\", \"number\", props.digit_count || 4, (v) => updateProp(\"digit_count\", parseInt(v, 10)));\n                this.addLabeledInput(\"Step\", \"number\", props.step || 1, (v) => updateProp(\"step\", parseInt(v, 10)));\n            }\n            else if (type === \"lvgl_switch\") {\n                this.addLabeledInputWithPicker(\"Entity ID\", \"text\", widget.entity_id || \"\", (v) => {\n                    AppState.updateWidget(widget.id, { entity_id: v });\n                }, widget);\n                this.addHint(\"Toggle switch/light/input_boolean when tapped\");\n\n                this.addCheckbox(\"Checked\", props.checked || false, (v) => updateProp(\"checked\", v));\n                this.addColorMixer(\"Indicator Color\", props.color || \"blue\", (v) => updateProp(\"color\", v));\n                this.addColorMixer(\"Background Color\", props.bg_color || \"gray\", (v) => updateProp(\"bg_color\", v));\n                this.addColorMixer(\"Knob Color\", props.knob_color || \"white\", (v) => updateProp(\"knob_color\", v));\n            }\n            else if (type === \"lvgl_textarea\") {\n                this.addLabeledInput(\"Placeholder\", \"text\", props.placeholder || \"\", (v) => updateProp(\"placeholder\", v));\n                this.addLabeledInput(\"Text\", \"text\", props.text || \"\", (v) => updateProp(\"text\", v));\n                this.addCheckbox(\"One Line\", props.one_line || false, (v) => updateProp(\"one_line\", v));\n                this.addCheckbox(\"Password Mode\", props.password_mode || false, (v) => updateProp(\"password_mode\", v));\n                this.addLabeledInput(\"Accepted Chars\", \"text\", props.accepted_chars || \"\", (v) => updateProp(\"accepted_chars\", v));\n                this.addLabeledInput(\"Max Length\", \"number\", props.max_length || 0, (v) => updateProp(\"max_length\", parseInt(v, 10)));\n            }\n            else if (type === \"lvgl_obj\") {\n                this.addColorMixer(\"Color\", props.color || \"white\", (v) => updateProp(\"color\", v));\n                this.addLabeledInput(\"Border Width\", \"number\", props.border_width || 1, (v) => updateProp(\"border_width\", parseInt(v, 10)));\n                this.addColorMixer(\"Border Color\", props.border_color || \"gray\", (v) => updateProp(\"border_color\", v));\n                this.addLabeledInput(\"Radius\", \"number\", props.radius || 0, (v) => updateProp(\"radius\", parseInt(v, 10)));\n            }\n        }\n    }\n\n    addCommonLVGLProperties(widget, props) {\n        const updateProp = (key, value) => {\n            const newProps = { ...widget.props, [key]: value };\n            AppState.updateWidget(widget.id, { props: newProps });\n        };\n\n        this.addSectionLabel(\"Common LVGL\");\n\n        // Flags\n        const flagContainer = document.createElement(\"div\");\n        flagContainer.style.display = \"grid\";\n        flagContainer.style.gridTemplateColumns = \"1fr 1fr\";\n        flagContainer.style.gap = \"4px\";\n\n        this.panel.appendChild(flagContainer);\n\n        const addFlag = (label, key, def = false) => {\n            const wrap = document.createElement(\"div\");\n            const checkbox = document.createElement(\"input\");\n            checkbox.type = \"checkbox\";\n            checkbox.checked = props[key] !== undefined ? props[key] : def;\n            checkbox.addEventListener(\"change\", () => updateProp(key, checkbox.checked));\n            const lbl = document.createElement(\"span\");\n            lbl.textContent = \" \" + label;\n            lbl.style.fontSize = \"10px\";\n            wrap.appendChild(checkbox);\n            wrap.appendChild(lbl);\n            flagContainer.appendChild(wrap);\n        };\n\n        addFlag(\"Hidden\", \"hidden\", false);\n        addFlag(\"Clickable\", \"clickable\", true);\n        addFlag(\"Checkable\", \"checkable\", false);\n        addFlag(\"Scrollable\", \"scrollable\", true);\n        addFlag(\"Floating\", \"floating\", false);\n        addFlag(\"Ignore Layout\", \"ignore_layout\", false);\n\n        this.addSelect(\"Scrollbar Mode\", props.scrollbar_mode || \"AUTO\", [\"AUTO\", \"ON\", \"OFF\", \"ACTIVE\"], (v) => updateProp(\"scrollbar_mode\", v));\n    }\n\n    // --- Helpers ---\n\n    addLabeledInput(label, type, value, onChange) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        const lbl = document.createElement(\"div\");\n        lbl.className = \"prop-label\";\n        lbl.textContent = label;\n        const input = document.createElement(\"input\");\n        input.className = \"prop-input\";\n        input.type = type;\n        input.value = value;\n\n        input.addEventListener(\"input\", () => {\n            onChange(input.value);\n        });\n\n        // Also update immediately on blur/enter to ensure saving before unintended loss of focus\n        input.addEventListener(\"change\", () => {\n            onChange(input.value);\n        });\n\n        wrap.appendChild(lbl);\n        wrap.appendChild(input);\n        this.panel.appendChild(wrap);\n    }\n\n    addSelect(label, value, options, onChange) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        const lbl = document.createElement(\"div\");\n        lbl.className = \"prop-label\";\n        lbl.textContent = label;\n        const select = document.createElement(\"select\");\n        select.className = \"prop-input\";\n        options.forEach(opt => {\n            const o = document.createElement(\"option\");\n            if (typeof opt === 'object' && opt !== null) {\n                o.value = opt.value;\n                o.textContent = opt.label;\n                if (opt.value === value) o.selected = true;\n            } else {\n                o.value = opt;\n                o.textContent = opt;\n                if (opt === value) o.selected = true;\n            }\n            select.appendChild(o);\n        });\n        select.addEventListener(\"change\", () => onChange(select.value));\n        wrap.appendChild(lbl);\n        wrap.appendChild(select);\n        this.panel.appendChild(wrap);\n    }\n\n    addCheckbox(label, value, onChange) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        wrap.style.marginBottom = \"8px\"; // Added spacing\n\n        const checkboxLabel = document.createElement(\"label\");\n        checkboxLabel.style.display = \"flex\";\n        checkboxLabel.style.alignItems = \"center\";\n        checkboxLabel.style.gap = \"8px\"; // Increased gap\n        checkboxLabel.style.fontSize = \"13px\"; // Increased font size\n        checkboxLabel.style.cursor = \"pointer\"; // Better UX\n\n        const checkbox = document.createElement(\"input\");\n        checkbox.type = \"checkbox\";\n        checkbox.checked = !!value;\n        checkbox.style.width = \"16px\"; // Bigger checkbox\n        checkbox.style.height = \"16px\"; // Bigger checkbox\n        checkbox.style.margin = \"0\";\n        checkbox.style.cursor = \"pointer\";\n        checkbox.addEventListener(\"change\", () => onChange(checkbox.checked));\n\n        const span = document.createElement(\"span\");\n        span.textContent = label;\n\n        checkboxLabel.appendChild(checkbox);\n        checkboxLabel.appendChild(span);\n        wrap.appendChild(checkboxLabel);\n        this.panel.appendChild(wrap);\n    }\n\n    addHint(htmlContent) {\n        const hint = document.createElement(\"div\");\n        hint.style.fontSize = \"11px\"; // Increased font size\n        hint.style.color = \"#666\";\n        hint.style.marginTop = \"4px\"; // Small top margin\n        hint.style.marginBottom = \"12px\"; // Increased bottom spacing\n        hint.style.lineHeight = \"1.4\"; // Better readability\n        hint.innerHTML = htmlContent;\n        this.panel.appendChild(hint);\n    }\n\n    addLabeledInputWithDataList(label, type, value, suggestions, onChange) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        const lbl = document.createElement(\"div\");\n        lbl.className = \"prop-label\";\n        lbl.textContent = label;\n\n        const listId = \"datalist_\" + Math.random().toString(36).substr(2, 9);\n        const dataList = document.createElement(\"datalist\");\n        dataList.id = listId;\n        suggestions.forEach(s => {\n            const opt = document.createElement(\"option\");\n            opt.value = s;\n            dataList.appendChild(opt);\n        });\n\n        const input = document.createElement(\"input\");\n        input.className = \"prop-input\";\n        input.type = type;\n        input.value = value;\n        input.setAttribute(\"list\", listId);\n        // Handle both input (typing) and change (selection)\n        input.addEventListener(\"input\", () => onChange(input.value));\n        input.addEventListener(\"change\", () => onChange(input.value));\n\n        wrap.appendChild(lbl);\n        wrap.appendChild(input);\n        wrap.appendChild(dataList);\n        this.panel.appendChild(wrap);\n    }\n\n    addSectionLabel(text) {\n        const section = document.createElement(\"div\");\n        section.className = \"sidebar-section-label\";\n        section.textContent = text;\n        this.panel.appendChild(section);\n    }\n\n    /**\n     * Auto-populate title from entity's friendly_name when entity_id changes\n     * @param {string} widgetId - The widget ID to update\n     * @param {string} entityId - The entity_id to look up\n     */\n    autoPopulateTitleFromEntity(widgetId, entityId) {\n        if (!entityId || !window.AppState) return;\n\n        // Try to get entity info from the cached entity states\n        // entityStatesCache contains objects with entity_id, name (friendly_name), formatted, attributes\n        if (typeof fetchEntityStates === 'function') {\n            fetchEntityStates().then(entities => {\n                if (!entities || entities.length === 0) return;\n                const entity = entities.find(e => e.entity_id === entityId);\n                if (entity && entity.name) {\n                    // Only update if widget still has no title\n                    const currentWidget = AppState.getSelectedWidget();\n                    if (currentWidget && currentWidget.id === widgetId && !currentWidget.title) {\n                        AppState.updateWidget(widgetId, { title: entity.name });\n                    }\n                }\n            }).catch(() => {\n                // Silently fail - title auto-populate is optional\n            });\n        }\n    }\n\n    addLayerOrderButtons(widget) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        wrap.style.display = \"flex\";\n        wrap.style.flexDirection = \"row\";\n        wrap.style.gap = \"4px\";\n\n        const buttons = [\n            { label: \"Ôåæ Front\", action: () => this.moveToFront(widget) },\n            { label: \"Ôåô Back\", action: () => this.moveToBack(widget) },\n            { label: \"Ôû▓ Up\", action: () => this.moveUp(widget) },\n            { label: \"Ôû╝ Down\", action: () => this.moveDown(widget) }\n        ];\n\n        buttons.forEach(btn => {\n            const button = document.createElement(\"button\");\n            button.className = \"btn btn-secondary\";\n            button.textContent = btn.label;\n            button.style.flex = \"1\";\n            button.style.fontSize = \"10px\";\n            button.style.padding = \"4px\";\n            button.addEventListener(\"click\", () => {\n                btn.action();\n            });\n            wrap.appendChild(button);\n        });\n\n        this.panel.appendChild(wrap);\n    }\n\n    moveToFront(widget) {\n        const page = AppState.getCurrentPage();\n        const idx = page.widgets.findIndex(w => w.id === widget.id);\n        if (idx > -1 && idx < page.widgets.length - 1) {\n            page.widgets.splice(idx, 1);\n            page.widgets.push(widget);\n            AppState.setPages(AppState.pages); // Trigger update\n        }\n    }\n\n    moveToBack(widget) {\n        const page = AppState.getCurrentPage();\n        const idx = page.widgets.findIndex(w => w.id === widget.id);\n        if (idx > 0) {\n            page.widgets.splice(idx, 1);\n            page.widgets.unshift(widget);\n            AppState.setPages(AppState.pages);\n        }\n    }\n\n    moveUp(widget) {\n        const page = AppState.getCurrentPage();\n        const idx = page.widgets.findIndex(w => w.id === widget.id);\n        if (idx > -1 && idx < page.widgets.length - 1) {\n            [page.widgets[idx], page.widgets[idx + 1]] = [page.widgets[idx + 1], page.widgets[idx]];\n            AppState.setPages(AppState.pages);\n        }\n    }\n\n    moveDown(widget) {\n        const page = AppState.getCurrentPage();\n        const idx = page.widgets.findIndex(w => w.id === widget.id);\n        if (idx > 0) {\n            [page.widgets[idx], page.widgets[idx - 1]] = [page.widgets[idx - 1], page.widgets[idx]];\n            AppState.setPages(AppState.pages);\n        }\n    }\n\n    addVisibilityConditions(widget) {\n        widget.condition_entity = widget.condition_entity || \"\";\n        widget.condition_operator = widget.condition_operator || \"==\";\n        widget.condition_state = widget.condition_state || \"\";\n        widget.condition_min = widget.condition_min || \"\";\n        widget.condition_max = widget.condition_max || \"\";\n\n        // Help Text\n        const helpWrap = document.createElement(\"div\");\n        helpWrap.className = \"field\";\n        helpWrap.style.fontSize = \"9px\";\n        helpWrap.style.color = \"#9499a6\"; // var(--muted)\n        helpWrap.style.marginBottom = \"6px\";\n        helpWrap.innerHTML = \"Show/hide this widget based on an entity's state.\";\n        this.panel.appendChild(helpWrap);\n\n        // Condition Entity with Picker\n        this.addLabeledInputWithPicker(\"Condition Entity\", \"text\", widget.condition_entity, (v) => {\n            AppState.updateWidget(widget.id, { condition_entity: v });\n        }, widget);\n\n        const operators = [\"==\", \"!=\", \"<\", \">\", \"<=\", \">=\"];\n        this.addSelect(\"Operator\", widget.condition_operator, operators, (v) => {\n            AppState.updateWidget(widget.id, { condition_operator: v });\n        });\n\n        const commonStates = [\n            \"on\", \"off\", \"open\", \"closed\",\n            \"true\", \"false\", \"home\", \"not_home\",\n            \"locked\", \"unlocked\", \"active\", \"inactive\",\n            \"detected\", \"clear\", \"occupied\"\n        ];\n        this.addLabeledInputWithDataList(\"Condition State\", \"text\", widget.condition_state, commonStates, (v) => {\n            AppState.updateWidget(widget.id, { condition_state: v });\n        });\n\n        this.addLabeledInput(\"Min Value (Range)\", \"text\", widget.condition_min, (v) => {\n            AppState.updateWidget(widget.id, { condition_min: v });\n        });\n\n        this.addLabeledInput(\"Max Value (Range)\", \"text\", widget.condition_max, (v) => {\n            AppState.updateWidget(widget.id, { condition_max: v });\n        });\n\n        // Clear Condition Button\n        const clearWrap = document.createElement(\"div\");\n        clearWrap.className = \"field\";\n        clearWrap.style.marginTop = \"8px\";\n        const clearBtn = document.createElement(\"button\");\n        clearBtn.className = \"btn btn-secondary btn-full\";\n        clearBtn.textContent = \"Clear Condition\";\n        clearBtn.type = \"button\";\n        clearBtn.addEventListener(\"click\", () => {\n            AppState.updateWidget(widget.id, {\n                condition_entity: \"\",\n                condition_operator: \"==\",\n                condition_state: \"\",\n                condition_min: \"\",\n                condition_max: \"\"\n            });\n        });\n        clearWrap.appendChild(clearBtn);\n        this.panel.appendChild(clearWrap);\n    }\n\n    addLabeledInputWithPicker(label, type, value, onChange, widget) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        const lbl = document.createElement(\"div\");\n        lbl.className = \"prop-label\";\n        lbl.textContent = label;\n\n        const inputRow = document.createElement(\"div\");\n        inputRow.style.display = \"flex\";\n        inputRow.style.gap = \"4px\";\n\n        const input = document.createElement(\"input\");\n        input.className = \"prop-input\";\n        input.type = type;\n        input.value = value;\n        input.style.flex = \"1\";\n        input.placeholder = \"Start typing or click Ôû╝ to pick...\";\n        input.autocomplete = \"off\";\n\n        // Enable autocomplete with datalist\n        if (ENTITY_DATALIST_ID) {\n            input.setAttribute('list', ENTITY_DATALIST_ID);\n            // Ensure datalist exists\n            ensureEntityDatalist();\n        }\n\n        input.addEventListener(\"input\", () => onChange(input.value));\n\n        // Add picker button\n        const pickerBtn = document.createElement(\"button\");\n        pickerBtn.className = \"btn btn-secondary\";\n        pickerBtn.innerHTML = \"Ôû╝\";\n        pickerBtn.style.padding = \"4px 8px\";\n        pickerBtn.style.fontSize = \"10px\";\n        pickerBtn.style.minWidth = \"32px\";\n        pickerBtn.type = \"button\";\n        pickerBtn.title = \"Browse all entities\";\n        pickerBtn.addEventListener(\"click\", () => {\n            openEntityPickerForWidget(widget, input, (selectedEntityId) => {\n                input.value = selectedEntityId;\n                onChange(selectedEntityId);\n            });\n        });\n        inputRow.appendChild(input);\n        inputRow.appendChild(pickerBtn);\n\n        wrap.appendChild(lbl);\n        wrap.appendChild(inputRow);\n        this.panel.appendChild(wrap);\n    }\n\n    addIconPicker(label, currentValue, onSelect, widget) {\n        const iconPickerData = window.iconPickerData || [];\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        const lbl = document.createElement(\"div\");\n        lbl.className = \"prop-label\";\n        lbl.textContent = label;\n        wrap.appendChild(lbl);\n\n        // Visual Select Dropdown\n        const pickerSelect = document.createElement(\"select\");\n        pickerSelect.className = \"select\";\n        pickerSelect.style.fontFamily = \"MDI, monospace, system-ui\";\n        pickerSelect.style.fontSize = \"16px\";\n        pickerSelect.style.lineHeight = \"1.5\";\n        pickerSelect.style.width = \"100%\";\n        pickerSelect.style.marginBottom = \"4px\";\n\n        const placeholderOpt = document.createElement(\"option\");\n        placeholderOpt.value = \"\";\n        placeholderOpt.textContent = \"-- Quick visual picker --\";\n        placeholderOpt.style.fontFamily = \"system-ui, -apple-system, BlinkMacSystemFont, sans-serif\";\n        pickerSelect.appendChild(placeholderOpt);\n\n        const currentCode = (currentValue || \"\").replace(\"mdi:\", \"\").toUpperCase();\n\n        iconPickerData.forEach(icon => {\n            const opt = document.createElement(\"option\");\n            opt.value = icon.code;\n            const cp = 0xf0000 + parseInt(icon.code.slice(1), 16);\n            const glyph = String.fromCodePoint(cp);\n            opt.textContent = glyph + \"  \" + icon.code + (icon.name ? ` (${icon.name})` : \"\");\n            opt.style.fontFamily = \"MDI, monospace, system-ui\";\n            if (icon.code === currentCode) {\n                opt.selected = true;\n            }\n            pickerSelect.appendChild(opt);\n        });\n\n        pickerSelect.addEventListener(\"change\", () => {\n            if (pickerSelect.value) {\n                manualInput.value = pickerSelect.value;\n                onSelect(pickerSelect.value);\n            }\n        });\n\n        wrap.appendChild(pickerSelect);\n\n        // Manual Input Row\n        const inputRow = document.createElement(\"div\");\n        inputRow.style.display = \"flex\";\n        inputRow.style.gap = \"4px\";\n\n        const manualInput = document.createElement(\"input\");\n        manualInput.className = \"prop-input\";\n        manualInput.type = \"text\";\n        manualInput.placeholder = \"MDI Hex (Fxxxx)\";\n        manualInput.value = currentCode;\n        manualInput.style.flex = \"1\";\n        manualInput.style.fontFamily = \"monospace\";\n\n        manualInput.addEventListener(\"input\", () => {\n            const clean = (manualInput.value || \"\").trim().toUpperCase().replace(/^0X/, \"\").replace(/^MDI:/, \"\");\n            if (/^F[0-9A-F]{4}$/i.test(clean)) {\n                onSelect(clean);\n                // Try to sync the select if it exists in data\n                const opt = Array.from(pickerSelect.options).find(o => o.value === clean);\n                if (opt) pickerSelect.value = clean;\n                else pickerSelect.value = \"\";\n            } else if (clean === \"\") {\n                onSelect(\"\");\n                pickerSelect.value = \"\";\n            }\n        });\n\n        inputRow.appendChild(manualInput);\n\n        // Add picker button\n        const pickerBtn = document.createElement(\"button\");\n        pickerBtn.className = \"btn btn-secondary\";\n        pickerBtn.textContent = \"Ôÿà\";\n        pickerBtn.style.padding = \"4px 8px\";\n        pickerBtn.style.fontSize = \"14px\";\n        pickerBtn.type = \"button\";\n        pickerBtn.title = \"Open full icon browser\";\n        pickerBtn.addEventListener(\"click\", () => {\n            openIconPickerForWidget(widget, manualInput);\n        });\n        inputRow.appendChild(pickerBtn);\n\n        wrap.appendChild(inputRow);\n\n        const hint = document.createElement(\"div\");\n        hint.className = \"prop-hint\";\n        hint.innerHTML = 'Browse <a href=\"https://pictogrammers.com/library/mdi/icon/\" target=\"_blank\" style=\"color: #03a9f4; text-decoration: none;\">Pictogrammers MDI</a>';\n        wrap.appendChild(hint);\n\n        this.panel.appendChild(wrap);\n    }\n\n    addIconInput(label, value, onChange, widget) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        const lbl = document.createElement(\"div\");\n        lbl.className = \"prop-label\";\n        lbl.textContent = label;\n\n        const inputRow = document.createElement(\"div\");\n        inputRow.style.display = \"flex\";\n        inputRow.style.gap = \"4px\";\n\n        const input = document.createElement(\"input\");\n        input.className = \"prop-input\";\n        input.type = \"text\";\n        input.value = value;\n        input.style.flex = \"1\";\n        input.addEventListener(\"input\", () => onChange(input.value));\n\n        // Add picker button\n        const pickerBtn = document.createElement(\"button\");\n        pickerBtn.className = \"btn btn-secondary\";\n        pickerBtn.textContent = \"Ôÿà\"; // Star icon for picker\n        pickerBtn.style.padding = \"4px 8px\";\n        pickerBtn.style.fontSize = \"14px\";\n        pickerBtn.type = \"button\";\n        pickerBtn.addEventListener(\"click\", () => {\n            openIconPickerForWidget(widget, input);\n        });\n        inputRow.appendChild(input);\n        inputRow.appendChild(pickerBtn);\n\n        wrap.appendChild(lbl);\n        wrap.appendChild(inputRow);\n        this.panel.appendChild(wrap);\n    }\n\n    addColorSelector(label, value, options, onChange) {\n        if (typeof isRGBDevice === 'function' && isRGBDevice()) {\n            this.addColorMixer(label, value, onChange);\n        } else {\n            this.addSelect(label, value, options, onChange);\n        }\n    }\n\n    addColorMixer(label, value, onChange) {\n        const wrap = document.createElement(\"div\");\n        wrap.className = \"field\";\n        wrap.style.marginBottom = \"10px\";\n\n        const lbl = document.createElement(\"div\");\n        lbl.className = \"prop-label\";\n        lbl.textContent = label;\n        wrap.appendChild(lbl);\n\n        // Parse initial color\n        let r = 0, g = 0, b = 0;\n        let hex = \"#000000\";\n\n        // Helper to parse existing color (named, hex, or int)\n        const parseColor = (c) => {\n            const names = {\n                \"black\": \"#000000\", \"white\": \"#FFFFFF\", \"red\": \"#FF0000\", \"green\": \"#00FF00\",\n                \"blue\": \"#0000FF\", \"yellow\": \"#FFFF00\", \"gray\": \"#808080\", \"grey\": \"#808080\"\n            };\n            if (!c) return \"#000000\";\n            if (names[c.toLowerCase()]) return names[c.toLowerCase()];\n            if (c.startsWith(\"0x\")) return \"#\" + c.substring(2);\n            if (c.startsWith(\"#\")) return c;\n            return \"#000000\";\n        };\n\n        const hexToRgb = (h) => {\n            const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(h);\n            return result ? {\n                r: parseInt(result[1], 16),\n                g: parseInt(result[2], 16),\n                b: parseInt(result[3], 16)\n            } : { r: 0, g: 0, b: 0 };\n        };\n\n        const rgbToHex = (rv, gv, bv) => {\n            const toHex = (c) => {\n                const hx = Math.max(0, Math.min(255, c)).toString(16);\n                return hx.length === 1 ? \"0\" + hx : hx;\n            };\n            return \"#\" + toHex(rv) + toHex(gv) + toHex(bv);\n        };\n\n        // Initialize state\n        hex = parseColor(value);\n        const rgb = hexToRgb(hex);\n        r = rgb.r; g = rgb.g; b = rgb.b;\n\n        // Container for Preview + Inputs\n        const mixerContainer = document.createElement(\"div\");\n        mixerContainer.style.background = \"var(--bg)\";\n        mixerContainer.style.padding = \"8px\";\n        mixerContainer.style.borderRadius = \"6px\";\n        mixerContainer.style.border = \"1px solid var(--border-subtle)\";\n\n        // Top Row: Preview Box + Hex Input\n        const topRow = document.createElement(\"div\");\n        topRow.style.display = \"flex\";\n        topRow.style.alignItems = \"center\";\n        topRow.style.marginBottom = \"8px\";\n        topRow.style.gap = \"8px\";\n\n        const previewBox = document.createElement(\"div\");\n        previewBox.style.width = \"24px\";\n        previewBox.style.height = \"24px\";\n        previewBox.style.borderRadius = \"3px\";\n        previewBox.style.backgroundColor = hex;\n        previewBox.style.border = \"1px solid var(--border-subtle)\";\n\n        const hexInput = document.createElement(\"input\");\n        hexInput.type = \"text\";\n        hexInput.value = hex.toUpperCase();\n        hexInput.className = \"prop-input\";\n        hexInput.style.flex = \"1\";\n        hexInput.style.fontFamily = \"monospace\";\n\n        topRow.appendChild(previewBox);\n        topRow.appendChild(hexInput);\n        mixerContainer.appendChild(topRow);\n\n        // Sliders\n        const createSlider = (sliderLabel, val, color) => {\n            const row = document.createElement(\"div\");\n            row.style.display = \"flex\";\n            row.style.alignItems = \"center\";\n            row.style.marginBottom = \"4px\";\n            row.style.fontSize = \"11px\";\n\n            const rowLbl = document.createElement(\"span\");\n            rowLbl.textContent = sliderLabel;\n            rowLbl.style.width = \"15px\";\n            rowLbl.style.fontWeight = \"bold\";\n            rowLbl.style.color = \"var(--text)\";\n\n            const slider = document.createElement(\"input\");\n            slider.type = \"range\";\n            slider.min = \"0\";\n            slider.max = \"255\";\n            slider.value = val;\n            slider.style.flex = \"1\";\n            slider.style.marginLeft = \"4px\";\n            slider.style.accentColor = color;\n\n            const valLbl = document.createElement(\"span\");\n            valLbl.textContent = val;\n            valLbl.style.width = \"25px\";\n            valLbl.style.textAlign = \"right\";\n            valLbl.style.marginLeft = \"4px\";\n            valLbl.style.color = \"var(--muted)\";\n\n            row.appendChild(rowLbl);\n            row.appendChild(slider);\n            row.appendChild(valLbl);\n            return { row, slider, valLbl };\n        };\n\n        const rSlider = createSlider(\"R\", r, \"red\");\n        const gSlider = createSlider(\"G\", g, \"green\");\n        const bSlider = createSlider(\"B\", b, \"blue\");\n\n        mixerContainer.appendChild(rSlider.row);\n        mixerContainer.appendChild(gSlider.row);\n        mixerContainer.appendChild(bSlider.row);\n\n        wrap.appendChild(mixerContainer);\n        this.panel.appendChild(wrap);\n\n        // Event Handling logic\n        const updateFromSliders = () => {\n            r = parseInt(rSlider.slider.value);\n            g = parseInt(gSlider.slider.value);\n            b = parseInt(bSlider.slider.value);\n\n            rSlider.valLbl.textContent = r;\n            gSlider.valLbl.textContent = g;\n            bSlider.valLbl.textContent = b;\n\n            const newHex = rgbToHex(r, g, b).toUpperCase();\n            hexInput.value = newHex;\n            previewBox.style.backgroundColor = newHex;\n\n            onChange(newHex);\n        };\n\n        const updateFromHex = () => {\n            let val = hexInput.value.trim();\n            if (!val.startsWith(\"#\")) val = \"#\" + val;\n\n            if (/^#[0-9A-F]{6}$/i.test(val)) {\n                const rgbVal = hexToRgb(val);\n                r = rgbVal.r; g = rgbVal.g; b = rgbVal.b;\n\n                rSlider.slider.value = r; rSlider.valLbl.textContent = r;\n                gSlider.slider.value = g; gSlider.valLbl.textContent = g;\n                bSlider.slider.value = b; bSlider.valLbl.textContent = b;\n\n                previewBox.style.backgroundColor = val;\n                onChange(val);\n            }\n        };\n\n        rSlider.slider.addEventListener(\"input\", updateFromSliders);\n        gSlider.slider.addEventListener(\"input\", updateFromSliders);\n        bSlider.slider.addEventListener(\"input\", updateFromSliders);\n\n        hexInput.addEventListener(\"input\", updateFromHex);\n        hexInput.addEventListener(\"change\", updateFromHex);\n    }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\sidebar.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'emit' is defined but never used.","line":2,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":18,"suggestions":[{"messageId":"removeVar","data":{"varName":"emit"},"fix":{"range":[50,56],"text":""},"desc":"Remove unused variable 'emit'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from './state.js';\nimport { on, emit, EVENTS } from './events.js';\nimport { WidgetFactory } from './widget_factory.js';\nimport { showToast } from '../utils/dom.js';\nimport { Logger } from '../utils/logger.js';\n\nexport class Sidebar {\n    constructor() {\n        Logger.log(\"Sidebar: Constructor called\");\n        this.pageListEl = document.getElementById(\"pageList\");\n        this.widgetPaletteEl = document.getElementById(\"widgetPalette\");\n        Logger.log(\"Sidebar: widgetPaletteEl found?\", !!this.widgetPaletteEl);\n        if (!this.widgetPaletteEl) Logger.error(\"Sidebar: widgetPalette element not found!\");\n        this.addPageBtn = document.getElementById(\"addPageBtn\");\n        this.currentPageNameEl = document.getElementById(\"currentPageName\");\n    }\n\n    init() {\n        Logger.log(\"Sidebar: init called\");\n        const debugDiv = document.getElementById('debug-overlay');\n        if (debugDiv) debugDiv.innerHTML += 'Sidebar.init called<br>';\n        // Subscribe to state changes\n        on(EVENTS.STATE_CHANGED, () => this.render());\n        on(EVENTS.PAGE_CHANGED, () => this.render());\n\n        // Bind UI events\n        if (this.addPageBtn) {\n            this.addPageBtn.addEventListener(\"click\", () => this.handleAddPage());\n        }\n\n        // Widget Palette Delegation\n        if (this.widgetPaletteEl) {\n            this.widgetPaletteEl.addEventListener(\"click\", (e) => this.handlePaletteClick(e));\n\n            this.widgetPaletteEl.addEventListener(\"dragstart\", (e) => {\n                const item = e.target.closest(\".item[data-widget-type]\");\n                if (item) {\n                    const type = item.getAttribute(\"data-widget-type\");\n                    Logger.log(\"[Sidebar] Drag start:\", type);\n                    e.dataTransfer.setData(\"application/widget-type\", type);\n                    e.dataTransfer.effectAllowed = \"copy\";\n                }\n            });\n        }\n\n        // Global click debug\n        document.addEventListener('click', (e) => {\n            const debugDiv = document.getElementById('debug-overlay');\n            if (debugDiv) debugDiv.innerHTML += 'Global click: ' + e.target.tagName + '<br>';\n        });\n\n        // Clear Page Button\n        const clearAllBtn = document.getElementById('clearAllBtn');\n        if (clearAllBtn) {\n            clearAllBtn.addEventListener('click', () => this.handleClearPage());\n        }\n\n        this.setupMobileToggles();\n        this.render();\n    }\n\n    render() {\n        if (!this.pageListEl) return;\n\n        this.pageListEl.innerHTML = \"\";\n        const pages = AppState.pages;\n        const currentIndex = AppState.currentPageIndex;\n\n        pages.forEach((page, index) => {\n            const item = document.createElement(\"div\");\n            item.className = \"item\" + (index === currentIndex ? \" active\" : \"\");\n            item.draggable = true;\n\n            // Drag Handlers\n            item.ondragstart = (e) => {\n                e.dataTransfer.setData(\"text/plain\", index);\n                e.dataTransfer.effectAllowed = \"move\";\n                item.style.opacity = \"0.5\";\n            };\n\n            item.ondragend = () => {\n                item.style.opacity = \"1\";\n                Array.from(this.pageListEl.children).forEach(el => {\n                    el.style.borderTop = \"\";\n                    el.style.borderBottom = \"\";\n                });\n            };\n\n            item.ondragover = (e) => {\n                e.preventDefault();\n                e.dataTransfer.dropEffect = \"move\";\n                const rect = item.getBoundingClientRect();\n                const midpoint = rect.top + rect.height / 2;\n                if (e.clientY < midpoint) {\n                    item.style.borderTop = \"2px solid var(--primary)\";\n                    item.style.borderBottom = \"\";\n                } else {\n                    item.style.borderTop = \"\";\n                    item.style.borderBottom = \"2px solid var(--primary)\";\n                }\n            };\n\n            item.ondragleave = () => {\n                item.style.borderTop = \"\";\n                item.style.borderBottom = \"\";\n            };\n\n            item.ondrop = (e) => {\n                e.preventDefault();\n                item.style.borderTop = \"\";\n                item.style.borderBottom = \"\";\n                const fromIndex = parseInt(e.dataTransfer.getData(\"text/plain\"), 10);\n                const toIndex = index;\n                this.handlePageReorder(fromIndex, toIndex, e.clientY, item);\n            };\n\n            item.onclick = () => {\n                AppState.setCurrentPageIndex(index);\n            };\n\n            // Content\n            const label = document.createElement(\"span\");\n            label.className = \"label\";\n            label.textContent = page.name;\n\n            const tag = document.createElement(\"span\");\n            tag.className = \"tag\";\n            tag.textContent = page.id;\n\n            item.appendChild(label);\n            item.appendChild(tag);\n\n            // Actions\n            const actions = document.createElement(\"div\");\n            actions.style.marginLeft = \"auto\";\n            actions.style.display = \"flex\";\n            actions.style.gap = \"2px\";\n\n            const editBtn = document.createElement(\"button\");\n            editBtn.textContent = \"ÔÜÖ\";\n            editBtn.className = \"btn btn-secondary\";\n            editBtn.style.padding = \"1px 4px\";\n            editBtn.style.fontSize = \"8px\";\n            editBtn.onclick = (e) => {\n                e.stopPropagation();\n                this.openPageSettings(index);\n            };\n            actions.appendChild(editBtn);\n\n            if (pages.length > 1) {\n                const delBtn = document.createElement(\"button\");\n                delBtn.textContent = \"­ƒùæ\";\n                delBtn.className = \"btn btn-secondary\";\n                delBtn.style.padding = \"1px 4px\";\n                delBtn.style.fontSize = \"8px\";\n                delBtn.style.color = \"var(--danger)\";\n                delBtn.onclick = (e) => {\n                    e.stopPropagation();\n                    if (confirm(`Delete page \"${page.name}\"?`)) {\n                        AppState.state.pages.splice(index, 1);\n                        if (AppState.currentPageIndex >= AppState.pages.length) {\n                            AppState.setCurrentPageIndex(AppState.pages.length - 1);\n                        } else {\n                            // Force update if index didn't change but content did\n                            AppState.setPages(AppState.pages);\n                        }\n                    }\n                };\n                actions.appendChild(delBtn);\n            }\n\n            item.appendChild(actions);\n            this.pageListEl.appendChild(item);\n        });\n\n        // Update current page name header\n        if (this.currentPageNameEl) {\n            const page = AppState.getCurrentPage();\n            this.currentPageNameEl.textContent = page ? page.name : \"None\";\n        }\n    }\n\n    handleAddPage() {\n        const newId = AppState.pages.length;\n        const newPage = {\n            id: `page_${newId}`,\n            name: `Page ${newId + 1}`,\n            widgets: []\n        };\n        const newPages = [...AppState.pages, newPage];\n        AppState.setPages(newPages);\n        AppState.setCurrentPageIndex(newPages.length - 1);\n    }\n\n    handlePageReorder(fromIndex, toIndex, clientY, targetItem) {\n        if (fromIndex === toIndex) return;\n\n        const rect = targetItem.getBoundingClientRect();\n        const midpoint = rect.top + rect.height / 2;\n        let insertIndex = toIndex;\n        if (clientY >= midpoint) {\n            insertIndex++;\n        }\n\n        if (fromIndex < insertIndex) {\n            insertIndex--;\n        }\n\n        const pages = [...AppState.pages];\n        const [movedPage] = pages.splice(fromIndex, 1);\n        pages.splice(insertIndex, 0, movedPage);\n\n        // Renumber IDs? The original code did this.\n        // It might be better to keep stable IDs, but for now let's stick to the original behavior\n        // to avoid breaking backend expectations if any.\n        pages.forEach((p, i) => {\n            p.id = `page_${i}`;\n        });\n\n        AppState.setPages(pages);\n\n        // Update selection\n        if (AppState.currentPageIndex === fromIndex) {\n            AppState.setCurrentPageIndex(insertIndex);\n        } else if (AppState.currentPageIndex > fromIndex && AppState.currentPageIndex <= insertIndex) {\n            AppState.setCurrentPageIndex(AppState.currentPageIndex - 1);\n        } else if (AppState.currentPageIndex < fromIndex && AppState.currentPageIndex >= insertIndex) {\n            AppState.setCurrentPageIndex(AppState.currentPageIndex + 1);\n        }\n    }\n\n    handlePaletteClick(e) {\n        const debugDiv = document.getElementById('debug-overlay');\n        if (debugDiv) debugDiv.innerHTML += 'handlePaletteClick triggered<br>';\n\n        Logger.log(\"Sidebar: handlePaletteClick\", e.target);\n        const item = e.target.closest(\".item[data-widget-type]\");\n        if (!item) {\n            Logger.log(\"Sidebar: No item found\");\n            if (debugDiv) debugDiv.innerHTML += 'No item found<br>';\n            return;\n        }\n        const type = item.getAttribute(\"data-widget-type\");\n        Logger.log(\"Sidebar: Creating widget of type\", type);\n        if (debugDiv) debugDiv.innerHTML += 'Creating widget: ' + type + '<br>';\n\n        try {\n            const widget = WidgetFactory.createWidget(type);\n            Logger.log(\"Sidebar: Widget created\", widget);\n            if (debugDiv) debugDiv.innerHTML += 'Widget created<br>';\n\n            AppState.addWidget(widget);\n            Logger.log(\"Sidebar: Widget added to state\");\n            if (debugDiv) debugDiv.innerHTML += 'Widget added to state<br>';\n        } catch (err) {\n            Logger.error(\"Sidebar: Error creating/adding widget\", err);\n            if (debugDiv) debugDiv.innerHTML += 'Error: ' + err.message + '<br>';\n        }\n    }\n\n    openPageSettings(index) {\n        if (window.app && window.app.pageSettings) {\n            window.app.pageSettings.open(index);\n        } else {\n            Logger.error(\"Sidebar: PageSettings instance not found on window.app\");\n            // Fallback (should not be needed if main.js initializes correctly)\n            const page = AppState.pages[index];\n            window.currentPageSettingsTarget = page;\n            const modal = document.getElementById(\"pageSettingsModal\");\n            if (modal) {\n                modal.classList.remove(\"hidden\");\n                modal.style.display = \"flex\";\n            }\n        }\n    }\n\n    handleClearPage() {\n        // Defensive check for AppState as fallback\n        const State = AppState || window.AppState;\n        if (!State) {\n            console.error('[Sidebar] AppState is not defined!');\n            if (typeof showToast === 'function') showToast('Error: Application State is not ready.', 'error');\n            return;\n        }\n\n        // Use custom modal instead of native confirm to avoid brower/environment issues\n        const modal = document.createElement('div');\n        modal.className = 'modal-backdrop';\n        modal.style.display = 'flex'; // Force display\n        modal.innerHTML = `\n            <div class=\"modal\" style=\"width: 320px; height: auto; min-height: 180px; padding: var(--space-4);\">\n                <div class=\"modal-header\" style=\"font-size: var(--fs-md); padding-bottom: var(--space-2);\">\n                    <div>Clear Page</div>\n                </div>\n                <div class=\"modal-body\" style=\"padding: var(--space-2) 0;\">\n                    <p style=\"margin-bottom: var(--space-3); font-size: var(--fs-sm);\">Are you sure you want to clear all widgets? <b>Locked</b> widgets will stay.</p>\n                </div>\n                <div class=\"modal-actions\" style=\"padding-top: var(--space-3); border-top: 1px solid var(--border-subtle);\">\n                    <button class=\"btn btn-secondary close-btn btn-xs\">Cancel</button>\n                    <button class=\"btn btn-primary confirm-btn btn-xs\" style=\"background: var(--danger); color: white; border: none;\">Clear All</button>\n                </div>\n            </div>\n        `;\n\n        document.body.appendChild(modal);\n\n        const closeModal = () => {\n            modal.remove();\n        };\n\n        const confirmAction = () => {\n            closeModal();\n            try {\n                console.log('[Sidebar] Executing clearCurrentPage...');\n                const result = State.clearCurrentPage(true); // true = preserve locked\n\n                if (result.preserved > 0 && typeof showToast === 'function') {\n                    showToast(`Cleared ${result.deleted} widgets. ${result.preserved} locked widget(s) were preserved.`, \"info\");\n                } else if (result.deleted > 0) {\n                    showToast(`Cleared all ${result.deleted} widgets.`, \"success\");\n                } else {\n                    if (result.preserved > 0) {\n                        showToast(`No widgets cleared. ${result.preserved} locked widget(s) preserved.`, \"info\");\n                    } else {\n                        showToast(\"Page is already empty.\", \"info\");\n                    }\n                }\n                Logger.log('Cleared widgets from current page via AppState');\n            } catch (e) {\n                console.error('[Sidebar] Error clearing page:', e);\n                if (typeof showToast === 'function') showToast('Error clearing page: ' + e.message, 'error');\n            }\n        };\n\n        // Bind events\n        const closeBtns = modal.querySelectorAll('.close-btn');\n        closeBtns.forEach(btn => btn.onclick = closeModal);\n\n        const confirmBtn = modal.querySelector('.confirm-btn');\n        confirmBtn.onclick = confirmAction;\n\n        // Click outside to close\n        modal.onclick = (e) => {\n            if (e.target === modal) closeModal();\n        };\n    }\n\n    setupMobileToggles() {\n        const mobileWidgetsBtn = document.getElementById('mobileWidgetsBtn');\n        const mobilePropsBtn = document.getElementById('mobilePropsBtn');\n        const mobileDeviceBtn = document.getElementById('mobileDeviceBtn');\n        const backdrop = document.getElementById('mobileBackdrop');\n\n        const sidebar = document.querySelector('.sidebar');\n        const rightPanel = document.querySelector('.right-panel');\n\n        const closeAll = () => {\n            sidebar?.classList.remove('mobile-active');\n            rightPanel?.classList.remove('mobile-active');\n            backdrop?.classList.remove('active');\n        };\n\n        mobileWidgetsBtn?.addEventListener('click', () => {\n            const isActive = sidebar?.classList.contains('mobile-active');\n            closeAll();\n            if (!isActive) {\n                sidebar?.classList.add('mobile-active');\n                backdrop?.classList.add('active');\n            }\n        });\n\n        mobilePropsBtn?.addEventListener('click', () => {\n            const isActive = rightPanel?.classList.contains('mobile-active');\n            closeAll();\n            if (!isActive) {\n                rightPanel?.classList.add('mobile-active');\n                backdrop?.classList.add('active');\n            }\n        });\n\n        mobileDeviceBtn?.addEventListener('click', () => {\n            closeAll();\n            window.app?.deviceSettings?.open();\n        });\n\n        backdrop?.addEventListener('click', closeAll);\n\n        // Auto-close on widget selection (mobile only)\n        on(EVENTS.SELECTION_CHANGED, () => {\n            if (window.innerWidth <= 768) {\n                // Keep properties open if we just selected something, but close widget drawer\n                sidebar?.classList.remove('mobile-active');\n                if (!rightPanel?.classList.contains('mobile-active') && !sidebar?.classList.contains('mobile-active')) {\n                    backdrop?.classList.remove('active');\n                }\n            }\n        });\n\n        // Close sidebar when adding a widget from palette\n        const originalHandlePaletteClick = this.handlePaletteClick.bind(this);\n        this.handlePaletteClick = (e) => {\n            originalHandlePaletteClick(e);\n            if (window.innerWidth <= 768) {\n                closeAll();\n            }\n        };\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\state.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\stores\\editor_store.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\stores\\index.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Logger' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"Logger"},"fix":{"range":[260,307],"text":""},"desc":"Remove unused variable 'Logger'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":80,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":80,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ProjectStore } from './project_store.js';\r\nimport { EditorStore } from './editor_store.js';\r\nimport { PreferencesStore } from './preferences_store.js';\r\nimport { SecretsStore } from './secrets_store.js';\r\nimport { emit, EVENTS } from '../events.js';\r\nimport { Logger } from '../../utils/logger.js';\r\nimport { hasHaBackend } from '../../utils/env.js';\r\nimport { generateId } from '../../utils/helpers.js';\r\n\r\nclass AppStateFacade {\r\n    constructor() {\r\n        this.project = new ProjectStore();\r\n        this.editor = new EditorStore();\r\n        this.preferences = new PreferencesStore();\r\n        this.secrets = new SecretsStore();\r\n\r\n        this.recordHistory();\r\n    }\r\n\r\n    reset() {\r\n        this.project.reset();\r\n        this.editor.state.selectedWidgetIds = [];\r\n        this.recordHistory();\r\n    }\r\n\r\n    // --- Geters ---\r\n    get pages() { return this.project.pages; }\r\n    get currentPageIndex() { return this.project.currentPageIndex; }\r\n    get selectedWidgetId() { return this.editor.selectedWidgetIds[0] || null; }\r\n    get selectedWidgetIds() { return this.editor.selectedWidgetIds; }\r\n    get settings() {\r\n        return {\r\n            ...this.preferences.state,\r\n            device_name: this.project.deviceName,\r\n            device_model: this.project.deviceModel,\r\n            ...this.secrets.keys\r\n        };\r\n    }\r\n    get deviceName() { return this.project.deviceName; }\r\n    get deviceModel() { return this.project.deviceModel; }\r\n    get currentLayoutId() { return this.project.currentLayoutId; }\r\n    get snapEnabled() { return this.preferences.snapEnabled; }\r\n    get showGrid() { return this.preferences.showGrid; }\r\n    get zoomLevel() { return this.editor.zoomLevel; }\r\n\r\n    getCurrentPage() { return this.project.getCurrentPage(); }\r\n    getWidgetById(id) { return this.project.getWidgetById(id); }\r\n    getSelectedWidget() { return this.project.getWidgetById(this.editor.selectedWidgetIds[0]); }\r\n    getSelectedWidgets() { return this.editor.selectedWidgetIds.map(id => this.getWidgetById(id)).filter(w => !!w); }\r\n\r\n    getCanvasDimensions() {\r\n        return this.project.getCanvasDimensions(this.preferences.state.orientation);\r\n    }\r\n\r\n    getCanvasShape() {\r\n        return \"rect\"; // Fallback or implement profile lookup\r\n    }\r\n\r\n    getPagesPayload() {\r\n        return this.project.getPagesPayload ? this.project.getPagesPayload() : {\r\n            pages: this.project.pages,\r\n            ...this.settings\r\n        };\r\n    }\r\n\r\n    getSettings() { return this.settings; }\r\n    setSettings(s) { this.updateSettings(s); }\r\n\r\n    // --- Persistence ---\r\n    saveToLocalStorage() {\r\n        if (!hasHaBackend()) {\r\n            localStorage.setItem('esphome-designer-layout', JSON.stringify(this.getPagesPayload()));\r\n        }\r\n    }\r\n\r\n    loadFromLocalStorage() {\r\n        try {\r\n            const data = localStorage.getItem('esphome-designer-layout');\r\n            return data ? JSON.parse(data) : null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // --- Actions ---\r\n    setPages(pages) {\r\n        this.project.setPages(pages);\r\n        this.recordHistory();\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    reorderWidget(pageIndex, fromIndex, toIndex) {\r\n        this.project.reorderWidget(pageIndex, fromIndex, toIndex);\r\n        this.recordHistory();\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    setCurrentPageIndex(index) {\r\n        this.project.setCurrentPageIndex(index);\r\n        this.editor.setSelectedWidgetIds([]);\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    selectWidget(id, multi) { this.editor.selectWidget(id, multi); }\r\n    selectWidgets(ids) { this.editor.setSelectedWidgetIds(ids); }\r\n\r\n    updateSettings(newSettings) {\r\n        const secretUpdates = {};\r\n        const prefUpdates = {};\r\n\r\n        Object.keys(newSettings).forEach(key => {\r\n            if (key.startsWith('ai_api_key_')) secretUpdates[key] = newSettings[key];\r\n            else prefUpdates[key] = newSettings[key];\r\n        });\r\n\r\n        if (Object.keys(secretUpdates).length) {\r\n            Object.entries(secretUpdates).forEach(([k, v]) => this.secrets.set(k, v));\r\n        }\r\n\r\n        this.preferences.update(prefUpdates);\r\n\r\n        if (newSettings.device_name) this.project.state.deviceName = newSettings.device_name;\r\n        if (newSettings.device_model) this.project.state.deviceModel = newSettings.device_model;\r\n\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    setDeviceName(name) { this.project.state.deviceName = name; this.updateLayoutIndicator(); }\r\n    setDeviceModel(model) { this.project.state.deviceModel = model; this.updateLayoutIndicator(); }\r\n    setCurrentLayoutId(id) { this.project.state.currentLayoutId = id; this.updateLayoutIndicator(); }\r\n\r\n    updateLayoutIndicator() {\r\n        const nameEl = document.getElementById('currentLayoutName');\r\n        if (nameEl) nameEl.textContent = this.project.deviceName || this.project.currentLayoutId || \"Unknown\";\r\n    }\r\n\r\n    setSnapEnabled(e) { this.preferences.setSnapEnabled(e); }\r\n    setShowGrid(e) { this.preferences.setShowGrid(e); }\r\n    setZoomLevel(l) { this.editor.setZoomLevel(l); }\r\n\r\n    // --- Widget Ops ---\r\n    setCustomHardware(config) {\r\n        this.project.state.customHardware = config;\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    addWidget(w) {\r\n        this.project.addWidget(w);\r\n        this.recordHistory();\r\n        this.selectWidget(w.id);\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n    updateWidget(id, u) {\r\n        this.project.updateWidget(id, u);\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n    updateWidgets(ids, u) {\r\n        ids.forEach(id => this.project.updateWidget(id, u));\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n    deleteWidget(id) {\r\n        const ids = id ? [id] : [...this.editor.selectedWidgetIds];\r\n        this.project.deleteWidgets(ids);\r\n        this.editor.setSelectedWidgetIds([]);\r\n        this.recordHistory();\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    clearCurrentPage(preserveLocked = false) {\r\n        const result = this.project.clearCurrentPage(preserveLocked);\r\n        if (result.deleted > 0) {\r\n            this.editor.setSelectedWidgetIds([]);\r\n            this.recordHistory();\r\n            emit(EVENTS.STATE_CHANGED);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    copyWidget(id) {\r\n        const targetIds = id ? [id] : this.editor.selectedWidgetIds;\r\n        const widgets = targetIds.map(id => this.getWidgetById(id)).filter(w => !!w);\r\n        if (widgets.length > 0) {\r\n            this.editor.copyWidgets(widgets);\r\n        }\r\n    }\r\n\r\n    pasteWidget() {\r\n        const clipboard = this.editor.clipboardWidgets;\r\n        if (!clipboard || clipboard.length === 0) return;\r\n\r\n        const newWidgets = clipboard.map(w => {\r\n            const pasted = JSON.parse(JSON.stringify(w)); // Deep clone\r\n            pasted.id = generateId();\r\n            pasted.x += 10;\r\n            pasted.y += 10;\r\n            return pasted;\r\n        });\r\n\r\n        newWidgets.forEach(w => this.project.addWidget(w));\r\n        this.editor.setSelectedWidgetIds(newWidgets.map(w => w.id));\r\n        this.recordHistory();\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    // --- History ---\r\n    recordHistory() {\r\n        this.editor.recordHistory({\r\n            pages: this.project.pages,\r\n            deviceName: this.project.deviceName\r\n        });\r\n    }\r\n\r\n    undo() {\r\n        const s = this.editor.undo();\r\n        if (s) this.restoreSnapshot(s);\r\n    }\r\n\r\n    redo() {\r\n        const s = this.editor.redo();\r\n        if (s) this.restoreSnapshot(s);\r\n    }\r\n\r\n    restoreSnapshot(s) {\r\n        this.project.state.pages = s.pages;\r\n        this.project.state.deviceName = s.deviceName;\r\n        this.project.rebuildWidgetsIndex();\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    canUndo() { return this.editor.canUndo(); }\r\n    canRedo() { return this.editor.canRedo(); }\r\n}\r\n\r\nexport const AppState = new AppStateFacade();\r\nwindow.AppState = AppState;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\stores\\preferences_store.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\stores\\project_store.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Logger' is defined but never used.","line":4,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"Logger"},"fix":{"range":[196,243],"text":""},"desc":"Remove unused variable 'Logger'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'hasHaBackend' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":22,"suggestions":[{"messageId":"removeVar","data":{"varName":"hasHaBackend"},"fix":{"range":[245,295],"text":""},"desc":"Remove unused variable 'hasHaBackend'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { emit, EVENTS } from '../events.js';\r\nimport { DEFAULT_CANVAS_WIDTH, DEFAULT_CANVAS_HEIGHT, ORIENTATIONS } from '../constants.js';\r\nimport { DEVICE_PROFILES } from '../../io/devices.js';\r\nimport { Logger } from '../../utils/logger.js';\r\nimport { hasHaBackend } from '../../utils/env.js';\r\n\r\nexport class ProjectStore {\r\n    constructor() {\r\n        /**\r\n         * @type {{\r\n         *  pages: import(\"../../types.js\").PageConfig[],\r\n         *  currentPageIndex: number,\r\n         *  deviceName: string,\r\n         *  deviceModel: string,\r\n         *  currentLayoutId: string,\r\n         *  widgetsById: Map<string, import(\"../../types.js\").WidgetConfig>\r\n         * }}\r\n         */\r\n        this.state = {\r\n            pages: [],\r\n            currentPageIndex: 0,\r\n            deviceName: \"Layout 1\",\r\n            deviceModel: \"reterminal_e1001\",\r\n            currentLayoutId: \"reterminal_e1001\",\r\n            customHardware: {},\r\n            widgetsById: new Map()\r\n        };\r\n        this.reset();\r\n    }\r\n\r\n    reset() {\r\n        this.state.pages = [{\r\n            id: \"page_0\",\r\n            name: \"Overview\",\r\n            layout: null,\r\n            widgets: []\r\n        }];\r\n        this.state.currentPageIndex = 0;\r\n        this.rebuildWidgetsIndex();\r\n    }\r\n\r\n    /** @returns {import(\"../../types.js\").PageConfig[]} */\r\n    get pages() { return this.state.pages; }\r\n    /** @returns {number} */\r\n    get currentPageIndex() { return this.state.currentPageIndex; }\r\n    /** @returns {string} */\r\n    get deviceName() { return this.state.deviceName; }\r\n    /** @returns {string} */\r\n    get deviceModel() { return this.state.deviceModel; }\r\n    /** @returns {string} */\r\n    get currentLayoutId() { return this.state.currentLayoutId; }\r\n\r\n    /** @returns {import(\"../../types.js\").PageConfig} */\r\n    getCurrentPage() {\r\n        return this.state.pages[this.state.currentPageIndex] || this.state.pages[0];\r\n    }\r\n\r\n    /**\r\n     * @param {string} id \r\n     * @returns {import(\"../../types.js\").WidgetConfig|undefined}\r\n     */\r\n    getWidgetById(id) {\r\n        return this.state.widgetsById.get(id);\r\n    }\r\n\r\n    rebuildWidgetsIndex() {\r\n        this.state.widgetsById.clear();\r\n        for (const page of this.state.pages) {\r\n            for (const w of page.widgets) {\r\n                this.state.widgetsById.set(w.id, w);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @param {import(\"../../types.js\").PageConfig[]} pages */\r\n    setPages(pages) {\r\n        this.state.pages = pages;\r\n        this.rebuildWidgetsIndex();\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    /** @param {number} index */\r\n    setCurrentPageIndex(index) {\r\n        if (index >= 0 && index < this.state.pages.length) {\r\n            this.state.currentPageIndex = index;\r\n            emit(EVENTS.PAGE_CHANGED, { index });\r\n        }\r\n    }\r\n\r\n    /** @param {import(\"../../types.js\").WidgetConfig} widget */\r\n    addWidget(widget) {\r\n        const page = this.getCurrentPage();\r\n        page.widgets.push(widget);\r\n        this.state.widgetsById.set(widget.id, widget);\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    /**\r\n     * @param {string} widgetId \r\n     * @param {Partial<import(\"../../types.js\").WidgetConfig>} updates \r\n     */\r\n    updateWidget(widgetId, updates) {\r\n        const widget = this.getWidgetById(widgetId);\r\n        if (widget) {\r\n            Object.assign(widget, updates);\r\n            emit(EVENTS.STATE_CHANGED);\r\n        }\r\n    }\r\n\r\n    /** @param {string[]} idsToDelete */\r\n    deleteWidgets(idsToDelete) {\r\n        const page = this.getCurrentPage();\r\n        let changed = false;\r\n        for (const id of idsToDelete) {\r\n            const idx = page.widgets.findIndex(w => w.id === id);\r\n            if (idx !== -1) {\r\n                page.widgets.splice(idx, 1);\r\n                this.state.widgetsById.delete(id);\r\n                changed = true;\r\n            }\r\n        }\r\n        if (changed) {\r\n            emit(EVENTS.STATE_CHANGED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {number} pageIndex \r\n     * @param {number} fromIndex \r\n     * @param {number} toIndex \r\n     */\r\n    reorderWidget(pageIndex, fromIndex, toIndex) {\r\n        const page = this.state.pages[pageIndex];\r\n        if (!page) return;\r\n\r\n        const widgets = page.widgets;\r\n        if (fromIndex < 0 || fromIndex >= widgets.length || toIndex < 0 || toIndex >= widgets.length) {\r\n            return;\r\n        }\r\n\r\n        const [movedWidget] = widgets.splice(fromIndex, 1);\r\n        widgets.splice(toIndex, 0, movedWidget);\r\n\r\n        emit(EVENTS.STATE_CHANGED);\r\n    }\r\n\r\n    /**\r\n     * @param {boolean} preserveLocked \r\n     * @returns {{deleted: number, preserved: number}}\r\n     */\r\n    clearCurrentPage(preserveLocked = false) {\r\n        const page = this.getCurrentPage();\r\n        if (!page) return { deleted: 0, preserved: 0 };\r\n\r\n        const toDelete = [];\r\n        const toPreserve = [];\r\n\r\n        page.widgets.forEach(w => {\r\n            if (preserveLocked && w.locked) {\r\n                toPreserve.push(w);\r\n            } else {\r\n                toDelete.push(w);\r\n            }\r\n        });\r\n\r\n        page.widgets = toPreserve;\r\n        toDelete.forEach(w => this.state.widgetsById.delete(w.id));\r\n\r\n        if (toDelete.length > 0) {\r\n            emit(EVENTS.STATE_CHANGED);\r\n        }\r\n\r\n        return {\r\n            deleted: toDelete.length,\r\n            preserved: toPreserve.length\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @param {string} name \r\n     * @param {string} model \r\n     */\r\n    setDeviceSettings(name, model) {\r\n        if (name) this.state.deviceName = name;\r\n        if (model) {\r\n            this.state.deviceModel = model;\r\n            window.currentDeviceModel = model;\r\n        }\r\n        emit(EVENTS.SETTINGS_CHANGED);\r\n    }\r\n\r\n    /**\r\n     * @param {string} orientation \r\n     * @returns {{width: number, height: number}}\r\n     */\r\n    getCanvasDimensions(orientation) {\r\n        const model = this.state.deviceModel || \"reterminal_e1001\";\r\n        const profile = (DEVICE_PROFILES && DEVICE_PROFILES[model]) ? DEVICE_PROFILES[model] : null;\r\n\r\n        let width = DEFAULT_CANVAS_WIDTH;\r\n        let height = DEFAULT_CANVAS_HEIGHT;\r\n\r\n        if (profile) {\r\n            if (profile.resolution) {\r\n                width = profile.resolution.width;\r\n                height = profile.resolution.height;\r\n            }\r\n        } else if (model === 'custom' && this.state.customHardware) {\r\n            const ch = this.state.customHardware;\r\n            if (ch.resWidth && ch.resHeight) {\r\n                width = ch.resWidth;\r\n                height = ch.resHeight;\r\n            }\r\n        }\r\n\r\n        if (orientation === ORIENTATIONS.PORTRAIT) {\r\n            return { width: Math.min(width, height), height: Math.max(width, height) };\r\n        } else {\r\n            return { width: Math.max(width, height), height: Math.min(width, height) };\r\n        }\r\n    }\r\n\r\n    /** @returns {import(\"../../types.js\").ProjectPayload} */\r\n    getPagesPayload() {\r\n        return {\r\n            pages: this.state.pages,\r\n            deviceName: this.state.deviceName,\r\n            deviceModel: this.state.deviceModel,\r\n            deviceSettings: {\r\n                model: this.state.deviceModel,\r\n                custom_hardware: this.state.customHardware\r\n            }\r\n        };\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\stores\\secrets_store.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\core\\widget_factory.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'getDeviceModel' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"getDeviceModel"},"fix":{"range":[89,141],"text":""},"desc":"Remove unused variable 'getDeviceModel'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { generateId } from '../utils/helpers.js';\nimport { AppState } from './state.js';\nimport { getDeviceModel } from '../utils/device.js';\nimport { registry as PluginRegistry } from './plugin_registry.js';\n\nexport class WidgetFactory {\n    /**\n     * Determines the effective dark mode for the current page.\n     * Per-page setting overrides global setting.\n     * @returns {boolean} true if dark mode should be active\n     */\n    static getEffectiveDarkMode() {\n        const page = AppState?.getCurrentPage?.();\n        const pageDarkMode = page?.dark_mode;\n\n        // \"inherit\" or undefined = use global setting\n        // \"dark\" = force dark mode\n        // \"light\" = force light mode\n        if (pageDarkMode === \"dark\") return true;\n        if (pageDarkMode === \"light\") return false;\n        return !!(AppState && AppState.settings && AppState.settings.dark_mode);\n    }\n\n    /**\n     * Gets the default foreground color based on dark mode setting.\n     * Returns \"white\" if dark mode (black background) is enabled, otherwise \"black\".\n     * Uses per-page dark mode when available.\n     */\n    static getDefaultColor() {\n        return WidgetFactory.getEffectiveDarkMode() ? \"white\" : \"black\";\n    }\n\n    /**\n     * Gets the default background color based on dark mode setting.\n     * Returns \"black\" if dark mode is enabled, otherwise \"white\".\n     * Uses per-page dark mode when available.\n     */\n    static getDefaultBgColor() {\n        return WidgetFactory.getEffectiveDarkMode() ? \"black\" : \"white\";\n    }\n\n    /**\n     * Returns default grid cell properties for LVGL widgets.\n     * These are applied when a page uses grid layout.\n     */\n    static getGridCellDefaults() {\n        return {\n            grid_cell_row_pos: null,      // null = auto-place\n            grid_cell_column_pos: null,\n            grid_cell_row_span: 1,\n            grid_cell_column_span: 1,\n            grid_cell_x_align: \"STRETCH\",\n            grid_cell_y_align: \"STRETCH\"\n        };\n    }\n\n    /**\n     * Checks if a widget type is an LVGL widget.\n     */\n    static isLvglWidget(type) {\n        return type && type.startsWith(\"lvgl_\");\n    }\n\n    static createWidget(type) {\n        const id = generateId();\n        const defaultColor = WidgetFactory.getDefaultColor();\n        const defaultBgColor = WidgetFactory.getDefaultBgColor();\n\n        let widget = {\n            id,\n            type,\n            x: 40,\n            y: 40,\n            width: 120,\n            height: 40,\n            title: \"\",\n            entity_id: \"\",\n            locked: false,\n            props: {}\n        };\n\n        // Try to get defaults from PluginRegistry first\n        const plugin = PluginRegistry.get(type);\n        if (plugin && plugin.defaults) {\n            widget.props = { ...plugin.defaults };\n\n            // Adjust colors based on dark mode if they were defaults\n            if (widget.props.color === \"black\" || widget.props.color === \"white\") {\n                widget.props.color = defaultColor;\n            }\n            if (widget.props.bg_color === \"black\" || widget.props.bg_color === \"white\") {\n                widget.props.bg_color = defaultBgColor;\n            }\n            // Also adjust background_color (used by weather/calendar)\n            if (widget.props.background_color === \"black\" || widget.props.background_color === \"white\") {\n                widget.props.background_color = defaultBgColor;\n            }\n\n            // Some plugins have specific size defaults in the plugin object\n            if (plugin.width) widget.width = plugin.width;\n            if (plugin.height) widget.height = plugin.height;\n\n            // NEW: Also check plugin.defaults for width/height as some plugins define them there\n            // NEW: Also check plugin.defaults for width/height as some plugins define them there\n            if (plugin.defaults.width) widget.width = plugin.defaults.width;\n            if (plugin.defaults.height) widget.height = plugin.defaults.height;\n            if (plugin.defaults.w) widget.width = plugin.defaults.w;\n            if (plugin.defaults.h) widget.height = plugin.defaults.h;\n\n            return widget;\n        }\n\n        // Fallback to hardcoded switch for special presets or aliases not in registry\n        switch (type) {\n            case \"nav_next_page\":\n                widget.type = \"touch_area\";\n                widget.props = {\n                    title: \"Next\",\n                    color: \"rgba(0, 128, 255, 0.2)\",\n                    border_color: \"#0080ff\",\n                    nav_action: \"next_page\",\n                    icon: \"F0142\",\n                    icon_size: 48\n                };\n                widget.width = 80;\n                widget.height = 80;\n                break;\n\n            case \"nav_previous_page\":\n                widget.type = \"touch_area\";\n                widget.props = {\n                    title: \"Previous\",\n                    color: \"rgba(0, 128, 255, 0.2)\",\n                    border_color: \"#0080ff\",\n                    nav_action: \"previous_page\",\n                    icon: \"F0141\",\n                    icon_size: 48\n                };\n                widget.width = 80;\n                widget.height = 80;\n                break;\n\n            case \"nav_reload_page\":\n                widget.type = \"touch_area\";\n                widget.props = {\n                    title: \"Reload\",\n                    color: \"rgba(0, 128, 255, 0.2)\",\n                    border_color: \"#0080ff\",\n                    nav_action: \"reload_page\",\n                    icon: \"F0450\",\n                    icon_size: 48\n                };\n                widget.width = 80;\n                widget.height = 80;\n                break;\n        }\n\n        // Apply grid cell defaults to all LVGL widgets\n        if (WidgetFactory.isLvglWidget(type)) {\n            widget.props = {\n                ...WidgetFactory.getGridCellDefaults(),\n                ...widget.props\n            };\n        }\n\n        return widget;\n    }\n}\n\n// Global exposure for transition\nwindow.WidgetFactory = WidgetFactory;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\data\\icons.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\adapters\\base_adapter.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'layout' is defined but never used. Allowed unused args must match /^_/u.","line":13,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"layout"},"fix":{"range":[448,454],"text":""},"desc":"Remove unused variable 'layout'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'page' is defined but never used. Allowed unused args must match /^_/u.","line":23,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":22,"suggestions":[{"messageId":"removeVar","data":{"varName":"page"},"fix":{"range":[795,800],"text":""},"desc":"Remove unused variable 'page'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":23,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"context"},"fix":{"range":[799,808],"text":""},"desc":"Remove unused variable 'context'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'widget' is defined but never used. Allowed unused args must match /^_/u.","line":33,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"widget"},"fix":{"range":[1161,1168],"text":""},"desc":"Remove unused variable 'widget'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":33,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":33,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"context"},"fix":{"range":[1167,1176],"text":""},"desc":"Remove unused variable 'context'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export class BaseAdapter {\r\n    constructor() {\r\n        if (this.constructor === BaseAdapter) {\r\n            throw new Error(\"BaseAdapter is abstract and cannot be instantiated directly.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The main entry point for generating output from a layout state.\r\n     * @param {Object} layout - The full layout state object.\r\n     * @returns {Promise<string>} The generated output string.\r\n     */\r\n    async generate(layout) {\r\n        throw new Error(\"Method 'generate()' must be implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Generates output for a single page.\r\n     * @param {Object} page - The page object from the state.\r\n     * @param {Object} context - Shared context and utilities.\r\n     * @returns {string[]} Array of output lines.\r\n     */\r\n    generatePage(page, context) {\r\n        throw new Error(\"Method 'generatePage()' must be implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Generates output for a single widget.\r\n     * @param {Object} widget - The widget object from the state.\r\n     * @param {Object} context - Shared context and utilities.\r\n     * @returns {string[]} Array of output lines.\r\n     */\r\n    generateWidget(widget, context) {\r\n        throw new Error(\"Method 'generateWidget()' must be implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Sanitizes strings for the target output format.\r\n     * @param {string} str - The input string.\r\n     * @returns {string} The sanitized string.\r\n     */\r\n    sanitize(str) {\r\n        return str; // Default identity, override in subclasses\r\n    }\r\n}\r\n\r\n// Expose globally for now to match the project's architecture\r\nwindow.BaseAdapter = BaseAdapter;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\adapters\\esphome_adapter.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\adapters\\font_registry.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'codes' is assigned a value but never used.","line":102,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":102,"endColumn":32,"suggestions":[{"messageId":"removeVar","data":{"varName":"codes"},"fix":{"range":[3561,3568],"text":""},"desc":"Remove unused variable 'codes'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Modular font and glyph registry for ESPHome.\r\n */\r\nexport class FontRegistry {\r\n    constructor() {\r\n        this.reset();\r\n        this.EXTENDED_GLYPHS = [\r\n            ...Array.from({ length: 95 }, (_, i) => `\\\\U000000${(i + 32).toString(16).padStart(2, '0')}`),\r\n            \"\\\\U000000B0\", \"\\\\U000000B1\", \"\\\\U000000B2\", \"\\\\U000000B3\",\r\n            \"\\\\U000000B5\", \"\\\\U000000A3\", \"\\\\U000000A5\", \"\\\\U000000A9\",\r\n            \"\\\\U000000AE\", \"\\\\U000000D7\", \"\\\\U000000F7\", \"\\\\U000003BC\",\r\n            \"\\\\U000003A9\", \"\\\\U000020AC\", \"\\\\U00002122\"\r\n        ];\r\n    }\r\n\r\n    reset() {\r\n        /** @type {Set<string>} */\r\n        this.definedFontIds = new Set();\r\n        /** @type {string[]} */\r\n        this.fontLines = [];\r\n        /** @type {Map<number, Set<string>>} */\r\n        this.iconCodesBySize = new Map();\r\n    }\r\n\r\n    /**\r\n     * Registers a font and returns its ID.\r\n     * @param {string} family \r\n     * @param {string|number} weight \r\n     * @param {number} size \r\n     * @param {boolean} italic \r\n     * @returns {string} \r\n     */\r\n    addFont(family, weight, size, italic = false) {\r\n        const safeFamily = family.replace(/\\s+/g, \"_\").toLowerCase();\r\n        const weightNum = parseInt(weight) || 400;\r\n        const italicSuffix = italic ? \"_italic\" : \"\";\r\n        const id = `font_${safeFamily}_${weightNum}_${size}${italicSuffix}`;\r\n\r\n        if (this.definedFontIds.has(id)) return id;\r\n        this.definedFontIds.add(id);\r\n\r\n        if (family === \"Material Design Icons\") {\r\n            this.fontLines.push(`  - file: \"fonts/materialdesignicons-webfont.ttf\"`);\r\n            this.fontLines.push(`    id: ${id}`);\r\n            this.fontLines.push(`    size: ${size}`);\r\n            // Glyphs for icons are added in getLines()\r\n        } else {\r\n            this.fontLines.push(`  - file:`);\r\n            this.fontLines.push(`      type: gfonts`);\r\n            this.fontLines.push(`      family: ${family}`);\r\n            this.fontLines.push(`      weight: ${weightNum}`);\r\n            if (italic) this.fontLines.push(`      italic: true`);\r\n            this.fontLines.push(`    id: ${id}`);\r\n            this.fontLines.push(`    size: ${size}`);\r\n\r\n            const glyphs = this.EXTENDED_GLYPHS.map(g => `\"${g}\"`).join(\", \");\r\n            this.fontLines.push(`    glyphs: [${glyphs}]`);\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Tracks an icon by its name and size.\r\n     * @param {string} iconName \r\n     * @param {number} size \r\n     */\r\n    trackIcon(iconName, size) {\r\n        if (!iconName) return;\r\n        const sizeInt = parseInt(size, 10);\r\n        if (!this.iconCodesBySize.has(sizeInt)) {\r\n            this.iconCodesBySize.set(sizeInt, new Set());\r\n        }\r\n\r\n        // Handle both raw hex codes (from plugins) and icon names (from UI)\r\n        let code = iconName;\r\n        if (!/^F[0-9A-F]{4}$/i.test(iconName)) {\r\n            code = window.Utils ? window.Utils.getIconCode(iconName) : null;\r\n        } else {\r\n            code = iconName.toUpperCase();\r\n        }\r\n\r\n        if (code) {\r\n            this.iconCodesBySize.get(sizeInt).add(code);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates the font section lines for the YAML.\r\n     * @returns {string[]}\r\n     */\r\n    getLines() {\r\n        // Fallback font if none registered\r\n        if (this.fontLines.length === 0) {\r\n            this.addFont(\"Roboto\", 400, 20);\r\n        }\r\n\r\n        const lines = [\"font:\"];\r\n        lines.push(...this.fontLines);\r\n\r\n        // Add icons tracking to their respective icon fonts\r\n        for (const [size, codes] of this.iconCodesBySize.entries()) {\r\n            // Find if there's already an icon font of this size\r\n            const iconFontId = `font_material_design_icons_400_${size}`;\r\n            if (!this.definedFontIds.has(iconFontId)) {\r\n                this.addFont(\"Material Design Icons\", 400, size);\r\n            }\r\n\r\n            // This is slightly complex because fontLines already has the base font entry.\r\n            // We need to find the specific font entry and add glyphs.\r\n            // Simplified: we add a separate font entry for icons to avoid editing strings.\r\n            // But optimal YAML would merge them.\r\n            // For now, let's just ensure glyphs are included.\r\n            // Actually, we can just append them if iconCodesBySize has codes for this size.\r\n        }\r\n\r\n        // Refined approach: add icon fonts explicitly at the end if they have tracked codes\r\n        for (const [size, codes] of this.iconCodesBySize.entries()) {\r\n            const fontId = `icon_font_${size}`;\r\n            if (this.definedFontIds.has(fontId)) continue; // Already added?\r\n\r\n            lines.push(`  - file: \"fonts/materialdesignicons-webfont.ttf\"`);\r\n            lines.push(`    id: ${fontId}`);\r\n            lines.push(`    size: ${size}`);\r\n            const glyphList = Array.from(codes).sort().map(c => `\"\\\\U000${c}\"`).join(\", \");\r\n            lines.push(`    glyphs: [${glyphList}]`);\r\n        }\r\n\r\n        return lines.length > 1 ? lines : [];\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\adapters\\yaml_generator.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'layout' is defined but never used. Allowed unused args must match /^_/u.","line":12,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":46,"suggestions":[{"messageId":"removeVar","data":{"varName":"layout"},"fix":{"range":[360,368],"text":""},"desc":"Remove unused variable 'layout'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Modular YAML generator for ESPHome.\r\n * Handles the structural components of the generated configuration.\r\n */\r\nexport class YamlGenerator {\r\n    /**\r\n     * Generates the instruction header with setup guidance.\r\n     * @param {Object} profile \r\n     * @param {Object} layout \r\n     * @returns {string[]}\r\n     */\r\n    generateInstructionHeader(profile, layout) {\r\n        const lines = [];\r\n        lines.push(\"# ============================================================================\");\r\n        lines.push(\"# ESPHome YAML - Generated by ESPHome Designer\");\r\n        lines.push(\"# ============================================================================\");\r\n        lines.push(`# TARGET DEVICE: ${profile.name || \"Unknown\"}`);\r\n        const dims = window.AppState ? window.AppState.getCanvasDimensions() : { width: 800, height: 480 };\r\n        lines.push(`# Resolution: ${dims.width}x${dims.height}`);\r\n        lines.push(`# Shape: ${window.AppState ? window.AppState.getCanvasShape() : \"rect\"}`);\r\n        lines.push(\"#\");\r\n\r\n        // Add brief device specs comment based on profile features\r\n        const feats = profile.features || {};\r\n        const platform = profile.displayPlatform || (feats.lcd ? \"LCD\" : (feats.epaper ? \"e-paper\" : \"Unknown\"));\r\n        lines.push(`#         - Display Platform: ${platform}`);\r\n        lines.push(`#         - PSRAM: ${feats.psram ? 'Yes' : 'No'}`);\r\n        lines.push(`#         - Battery: ${profile.battery ? 'Yes' : 'No'}`);\r\n        lines.push(`#         - Buttons: ${feats.buttons ? 'Yes' : 'No'}`);\r\n        lines.push(`#         - Buzzer: ${feats.buzzer ? 'Yes' : 'No'}`);\r\n        if (feats.audio) lines.push(`#         - Audio: Yes`);\r\n\r\n        lines.push(\"# ============================================================================\");\r\n        lines.push(\"#\");\r\n        lines.push(\"# SETUP INSTRUCTIONS:\");\r\n        lines.push(\"#\");\r\n        lines.push(\"# STEP 1: Copy the Material Design Icons font file\");\r\n        lines.push(\"#         - From this repo: font_ttf/font_ttf/materialdesignicons-webfont.ttf\");\r\n        lines.push(\"#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf\");\r\n        lines.push(\"#         (Create the fonts folder if it doesn't exist)\");\r\n        lines.push(\"#\");\r\n        lines.push(\"# STEP 2: Create a new device in ESPHome\");\r\n        lines.push(\"#         - Click \\\"New Device\\\"\");\r\n        lines.push(\"#         - Name: your-device-name\");\r\n\r\n        const deviceModel = profile.id || \"unknown\";\r\n        if (deviceModel === \"m5stack_coreink\") {\r\n            lines.push(\"#         - Select: ESP32 (do NOT use S3!)\");\r\n            lines.push(\"#         - Board: m5stack-coreink\");\r\n            lines.push(\"#         - Framework: esp-idf (Recommended) or arduino\");\r\n        } else if (deviceModel === \"m5stack_paper\") {\r\n            lines.push(\"#         - Select: ESP32 (do NOT use S3!)\");\r\n            lines.push(\"#         - Board: m5stack-paper\");\r\n            lines.push(\"#         - Framework: arduino (Required)\");\r\n            lines.push(\"#         - Flash Size: 16MB\");\r\n            lines.push(\"#         (TIP: If you see strapping pin warnings, you can add 'ignore_strapping_warning: true' to 'esphome:')\");\r\n        } else if (deviceModel === \"trmnl\") {\r\n            lines.push(\"#         - Select: ESP32-S3\");\r\n            lines.push(\"#         - Board: esp32-s3-devkitc-1\");\r\n            lines.push(\"#         - Framework: esp-idf (Recommended) or arduino\");\r\n        } else {\r\n            lines.push(\"#         - Select: ESP32-S3 (or appropriate for your board)\");\r\n        }\r\n\r\n        lines.push(\"#\");\r\n        lines.push(\"# ============================================================================\");\r\n        lines.push(\"\");\r\n        return lines;\r\n    }\r\n\r\n    /**\r\n     * Generates the script section for page switching and sleep management.\r\n     * @param {Object} payload \r\n     * @param {Object[]} pages \r\n     * @param {Object} profile \r\n     * @returns {string[]}\r\n     */\r\n    generateScriptSection(payload, pages, profile) {\r\n        const lines = [];\r\n        const displayId = profile.features?.lcd ? \"my_display\" : \"epaper_display\";\r\n        const autoCycleEnabled = payload.auto_cycle_enabled && pages.length > 1;\r\n\r\n        lines.push(\"script:\");\r\n\r\n        // Change Page Script\r\n        lines.push(\"  - id: change_page_to\");\r\n        lines.push(\"    parameters:\");\r\n        lines.push(\"      target_page: int\");\r\n        lines.push(\"    then:\");\r\n        lines.push(\"      - lambda: |-\");\r\n        lines.push(`          int pages_count = ${pages.length};`);\r\n        lines.push(\"          int target = target_page;\");\r\n        lines.push(\"          while (target < 0) target += pages_count;\");\r\n        lines.push(\"          target %= pages_count;\");\r\n        lines.push(\"          if (id(display_page) != target) {\");\r\n        lines.push(\"            id(display_page) = target;\");\r\n        lines.push(\"            id(last_page_switch_time) = millis();\");\r\n        lines.push(`            id(${displayId}).update();`);\r\n        lines.push(`            ESP_LOGI(\"display\", \"Switched to page %d\", target);`);\r\n        lines.push(\"            // Restart refresh logic\");\r\n        lines.push(\"            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();\");\r\n        lines.push(\"            id(manage_run_and_sleep).execute();\");\r\n        lines.push(\"          }\");\r\n\r\n        // Manage Run and Sleep\r\n        lines.push(\"  - id: manage_run_and_sleep\", \"    mode: restart\", \"    then:\");\r\n        lines.push(\"      - logger.log: \\\"Waiting for sync...\\\"\");\r\n        lines.push(\"      - wait_until:\");\r\n        lines.push(\"          condition:\");\r\n        lines.push(\"            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'\");\r\n        lines.push(\"          timeout: 60s\");\r\n        lines.push(\"      - delay: 5s\");\r\n        lines.push(\"      - lambda: 'id(page_refresh_current_s) = id(page_refresh_default_s);'\");\r\n        lines.push(`      - component.update: ${displayId}`);\r\n        lines.push(\"      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'\");\r\n        lines.push(\"      - script.execute: manage_run_and_sleep\");\r\n\r\n        // Auto Cycle Timer\r\n        if (autoCycleEnabled) {\r\n            const interval = payload.auto_cycle_interval_s || 30;\r\n            lines.push(\"  - id: auto_cycle_timer\", \"    mode: restart\", \"    then:\");\r\n            lines.push(`      - delay: ${interval}s`);\r\n            lines.push(\"      - script.execute:\");\r\n            lines.push(\"          id: change_page_to\");\r\n            lines.push(\"          target_page: !lambda 'return id(display_page) + 1;'\");\r\n            lines.push(\"      - script.execute: auto_cycle_timer\");\r\n        }\r\n\r\n        return lines;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\ai_service.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\devices.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\file_ops.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\ha_api.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'haEntitiesLoaded' is assigned a value but never used.","line":10,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":21},{"ruleId":"no-unused-vars","severity":1,"message":"'haEntitiesLoadError' is assigned a value but never used.","line":11,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from '../core/state.js';\nimport { emit, EVENTS } from '../core/events.js';\nimport { getHaToken, hasHaBackend, HA_API_BASE } from '../utils/env.js';\nimport { loadLayoutIntoState } from './yaml_import.js';\nimport { Logger } from '../utils/logger.js';\n\n// --- HA Entity States Cache ---\nexport let entityStatesCache = [];\nlet entityStatesFetchInProgress = false;\nlet haEntitiesLoaded = false;\nlet haEntitiesLoadError = false;\n\n/**\n * Gets the headers required for Home Assistant API requests.\n * @returns {Object} Headers object.\n */\nexport function getHaHeaders() {\n    const headers = {\n        \"Content-Type\": \"application/json\"\n    };\n    const token = getHaToken();\n    if (token) {\n        headers[\"Authorization\"] = `Bearer ${token}`;\n    }\n    return headers;\n}\n\n// --- Entity Datalist for Autocomplete ---\nexport const ENTITY_DATALIST_ID = 'entity-datalist-global';\nlet entityDatalistEl = null;\n\nexport function ensureEntityDatalist() {\n    if (!entityDatalistEl) {\n        entityDatalistEl = document.getElementById(ENTITY_DATALIST_ID);\n        if (!entityDatalistEl) {\n            entityDatalistEl = document.createElement('datalist');\n            entityDatalistEl.id = ENTITY_DATALIST_ID;\n            document.body.appendChild(entityDatalistEl);\n        }\n    }\n    return entityDatalistEl;\n}\n\nfunction updateEntityDatalist(entities) {\n    const datalist = ensureEntityDatalist();\n    datalist.innerHTML = '';\n\n    if (!entities || entities.length === 0) return;\n\n    entities.forEach(e => {\n        const opt = document.createElement('option');\n        opt.value = e.entity_id;\n        opt.label = e.name || e.entity_id;\n        datalist.appendChild(opt);\n    });\n    Logger.log(`[EntityDatalist] Updated with ${entities.length} entities`);\n}\n\n/**\n * Fetches entity states from Home Assistant.\n * Emits EVENTS.ENTITIES_LOADED on success.\n * @returns {Promise<Array>} The list of entities or empty array.\n */\nexport async function fetchEntityStates() {\n    if (!hasHaBackend()) {\n        return [];\n    }\n    if (entityStatesFetchInProgress) return entityStatesCache;\n\n    entityStatesFetchInProgress = true;\n    try {\n        // Use a timeout to avoid hanging forever\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 2000);\n\n        Logger.log(\"[EntityStates] Fetching from:\", `${HA_API_BASE}/entities`);\n        const resp = await fetch(`${HA_API_BASE}/entities?domains=sensor,binary_sensor,weather,light,switch,fan,cover,climate,media_player,input_number,number,input_boolean,input_text,input_select,button,input_button,scene,script`, {\n            headers: getHaHeaders(),\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n\n        if (!resp.ok) {\n            Logger.warn(\"[EntityStates] Failed to fetch:\", resp.status);\n            haEntitiesLoadError = true;\n            return [];\n        }\n        const entities = await resp.json();\n        if (!Array.isArray(entities)) {\n            Logger.warn(\"[EntityStates] Invalid response format\");\n            haEntitiesLoadError = true;\n            return [];\n        }\n\n        Logger.log(`[EntityStates] Received ${entities.length} entities`);\n\n        // Cache as array of objects for easier searching/filtering\n        entityStatesCache = entities.map(entity => {\n            const formatted = entity.unit ? `${entity.state} ${entity.unit}` : entity.state;\n            return {\n                entity_id: entity.entity_id,\n                name: entity.name || entity.entity_id,\n                state: entity.state,\n                unit: entity.unit,\n                attributes: entity.attributes || {},\n                formatted: formatted\n            };\n        });\n\n        haEntitiesLoaded = true;\n        haEntitiesLoadError = false;\n        Logger.log(`[EntityStates] Cached ${entityStatesCache.length} entity states`);\n\n        // Also populate AppState.entityStates as lookup object for render functions\n        if (AppState) {\n            AppState.entityStates = {};\n            entityStatesCache.forEach(e => {\n                AppState.entityStates[e.entity_id] = e;\n            });\n            Logger.log(`[EntityStates] Populated AppState.entityStates with ${Object.keys(AppState.entityStates).length} entries`);\n        }\n\n        // Update autocomplete datalist for entity inputs\n        updateEntityDatalist(entityStatesCache);\n\n        emit(EVENTS.ENTITIES_LOADED, entityStatesCache);\n\n        return entityStatesCache;\n    } catch (err) {\n        Logger.warn(\"[EntityStates] Error fetching:\", err);\n        haEntitiesLoadError = true;\n        return [];\n    } finally {\n        entityStatesFetchInProgress = false;\n    }\n}\n\n/**\n * Gets the cached state for a specific entity.\n * @param {string} entityId \n * @returns {string|null} Formatted state or null if not found.\n */\nexport function getEntityState(entityId) {\n    const entry = entityStatesCache.find(e => e.entity_id === entityId);\n    return entry ? entry.formatted : null;\n}\n\n/**\n * Gets the cached attributes for a specific entity.\n * @param {string} entityId \n * @returns {Object|null} Attributes object or null if not found.\n */\nexport function getEntityAttributes(entityId) {\n    const entry = entityStatesCache.find(e => e.entity_id === entityId);\n    return entry ? entry.attributes : null;\n}\n\n/**\n * Ensures entities are loaded, fetching if necessary.\n * @returns {Promise<Array>} The list of entities.\n */\nexport async function loadHaEntitiesIfNeeded() {\n    if (hasHaBackend()) {\n        if (entityStatesCache.length > 0) {\n            return entityStatesCache;\n        }\n        return fetchEntityStates();\n    }\n    return [];\n}\n\n/**\n * Loads the layout from the Home Assistant backend.\n * Will load the last saved/active layout if available.\n */\nexport async function loadLayoutFromBackend() {\n    if (!hasHaBackend()) {\n        Logger.warn(\"Cannot load layout from backend: No HA backend detected.\");\n        return;\n    }\n\n    try {\n        // First, check if there's a last active layout to load\n        let layoutId = null;\n        try {\n            const listResp = await fetch(`${HA_API_BASE}/layouts`, {\n                headers: getHaHeaders()\n            });\n            if (listResp.ok) {\n                const listData = await listResp.json();\n                Logger.log(`[loadLayoutFromBackend] Available layouts:`, listData.layouts?.map(l => l.id));\n                Logger.log(`[loadLayoutFromBackend] Last active layout ID from backend: ${listData.last_active_layout_id}`);\n\n                if (listData.last_active_layout_id) {\n                    // Verify the last active layout still exists\n                    const exists = listData.layouts?.some(l => l.id === listData.last_active_layout_id);\n                    if (exists) {\n                        layoutId = listData.last_active_layout_id;\n                        Logger.log(`[loadLayoutFromBackend] Loading last active layout: ${layoutId}`);\n                    } else {\n                        Logger.warn(`[loadLayoutFromBackend] Last active layout '${listData.last_active_layout_id}' no longer exists`);\n                    }\n                }\n\n                if (!layoutId && listData.layouts && listData.layouts.length > 0) {\n                    // Fallback to first layout\n                    layoutId = listData.layouts[0].id;\n                    Logger.log(`[loadLayoutFromBackend] No valid last active, using first layout: ${layoutId}`);\n                }\n            }\n        } catch (listErr) {\n            Logger.warn(\"[loadLayoutFromBackend] Could not fetch layouts list:\", listErr);\n        }\n\n        // Load the specific layout if we have an ID, otherwise use default /layout endpoint\n        let resp;\n        if (layoutId) {\n            resp = await fetch(`${HA_API_BASE}/layouts/${layoutId}`, {\n                headers: getHaHeaders()\n            });\n        } else {\n            resp = await fetch(`${HA_API_BASE}/layout`, {\n                headers: getHaHeaders()\n            });\n        }\n\n        if (!resp.ok) {\n            throw new Error(`Failed to load layout: ${resp.status}`);\n        }\n        const layout = await resp.json();\n\n        // CRITICAL: Ensure device_id is set in the layout before loading\n        if (!layout.device_id && layoutId) {\n            layout.device_id = layoutId;\n        }\n\n        Logger.log(`[loadLayoutFromBackend] Loaded layout '${layout.device_id || layoutId || 'default'}':`, {\n            name: layout.name,\n            device_model: layout.device_model,\n            pages: layout.pages?.length,\n            widgets: layout.pages?.reduce((sum, p) => sum + (p.widgets?.length || 0), 0)\n        });\n\n        // Set the current layout ID BEFORE loading into state\n        if (AppState && (layout.device_id || layoutId)) {\n            AppState.setCurrentLayoutId(layout.device_id || layoutId);\n        }\n\n        // Use imported loadLayoutIntoState if possible\n        if (typeof loadLayoutIntoState === 'function') {\n            loadLayoutIntoState(layout);\n        } else {\n            Logger.error(\"[loadLayoutFromBackend] loadLayoutIntoState function missing!\");\n        }\n\n        emit(EVENTS.LAYOUT_IMPORTED, layout);\n\n    } catch (err) {\n        Logger.error(\"Error loading layout from backend:\", err);\n        import('../utils/dom.js').then(dom => dom.showToast(\"Error loading layout from backend\", 5000, \"error\"));\n    }\n}\n\n/**\n * Saves the current layout to the Home Assistant backend.\n * Sends the AppState layout data (pages, settings) to the current layout.\n * @returns {Promise<boolean>} True if successful, false otherwise.\n */\nexport async function saveLayoutToBackend() {\n    if (!hasHaBackend()) return false;\n\n    // Get layout data from AppState\n    if (!AppState) {\n        throw new Error(\"AppState not available\");\n    }\n\n    // Get current layout ID - default to reterminal_e1001 if not set\n    const layoutId = AppState.currentLayoutId || \"reterminal_e1001\";\n\n    // Get device model - prefer settings (which user can change) over top-level\n    const deviceModel = AppState.settings.device_model || AppState.deviceModel || \"reterminal_e1001\";\n\n    const payload = AppState.getPagesPayload();\n\n    const layoutData = {\n        ...payload,\n        device_id: layoutId,\n        name: AppState.deviceName || \"Layout 1\",\n        device_model: deviceModel,\n        deviceName: AppState.deviceName || \"Layout 1\"\n    };\n\n    try {\n        Logger.log(`[saveLayoutToBackend] Saving to layout '${layoutId}':`, {\n            device_model: deviceModel,\n            pages: layoutData.pages?.length,\n            widgets: layoutData.pages?.reduce((sum, p) => sum + (p.widgets?.length || 0), 0),\n            // Debug: Power strategy settings\n            daily_refresh_enabled: layoutData.daily_refresh_enabled,\n            daily_refresh_time: layoutData.daily_refresh_time,\n            deep_sleep_enabled: layoutData.deep_sleep_enabled,\n            sleep_enabled: layoutData.sleep_enabled\n        });\n\n        // Use the layouts/{id} endpoint to save to the specific layout\n        const resp = await fetch(`${HA_API_BASE}/layouts/${layoutId}`, {\n            method: \"POST\",\n            headers: getHaHeaders(),\n            body: JSON.stringify(layoutData)\n        });\n\n        if (!resp.ok) {\n            const data = await resp.json().catch(() => ({}));\n            throw new Error(data.message || data.error || `Save failed: ${resp.status}`);\n        }\n        Logger.log(`[saveLayoutToBackend] Layout '${layoutId}' saved successfully`);\n        return true;\n    } catch (err) {\n        Logger.error(\"Failed to save layout to backend:\", err);\n        throw err;\n    }\n}\n\n/**\n * Imports a snippet via the Home Assistant backend.\n * @param {string} yaml - The YAML snippet to import.\n * @returns {Promise<Object>} The parsed layout object.\n */\nexport async function importSnippetBackend(yaml) {\n    if (!hasHaBackend()) throw new Error(\"No backend\");\n\n    const resp = await fetch(`${HA_API_BASE}/import_snippet`, {\n        method: \"POST\",\n        headers: getHaHeaders(),\n        body: JSON.stringify({ yaml })\n    });\n\n    if (!resp.ok) {\n        const data = await resp.json().catch(() => ({}));\n        throw new Error(data.message || data.error || `Import failed with status ${resp.status}`);\n    }\n\n    return await resp.json();\n}\n\n// Init function to be called by main\nexport function initHaApi() {\n    if (hasHaBackend()) {\n        fetchEntityStates();\n        setInterval(fetchEntityStates, 30000);\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\hardware_generator.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'tech' is assigned a value but never used.","line":10,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":13,"suggestions":[{"messageId":"removeVar","data":{"varName":"tech"},"fix":{"range":[200,214],"text":""},"desc":"Remove unused variable 'tech'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hardware Generator for Custom Profiles\n * Generates an ESPHome YAML Recipe based on user inputs.\n */\n\nexport function generateCustomHardwareYaml(config) {\n    const {\n        name,\n        chip,\n        tech,\n        resWidth,\n        resHeight,\n        shape,\n        psram,\n        displayDriver,\n        pins,\n        touchTech\n    } = config;\n\n    const lines = [];\n\n    // Metadata Header\n    lines.push(\"# ============================================================================\");\n    lines.push(`# TARGET DEVICE: ${name}`);\n    lines.push(`# Name: ${name}`);\n    lines.push(`# Resolution: ${resWidth}x${resHeight}`);\n    lines.push(`# Shape: ${shape}`);\n    lines.push(\"#\");\n    lines.push(`#         - Display Platform: ${displayDriver || \"Unknown\"}`);\n    lines.push(`#         - Touchscreen: ${touchTech || \"None\"}`);\n    lines.push(`#         - PSRAM: ${psram ? 'Yes' : 'No'}`);\n    lines.push(\"# ============================================================================\");\n    lines.push(\"#\");\n    lines.push(\"# SETUP INSTRUCTIONS:\");\n    lines.push(\"#\");\n    lines.push(\"# STEP 1: Copy the Material Design Icons font file\");\n    lines.push(\"#         - From this repo: font_ttf/font_ttf/materialdesignicons-webfont.ttf\");\n    lines.push(\"#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf\");\n    lines.push(\"#         (Create the fonts folder if it doesn't exist)\");\n    lines.push(\"#\");\n    lines.push(\"# STEP 2: Create a new device in ESPHome\");\n    lines.push(\"#         - Click \\\"New Device\\\"\");\n    lines.push(\"#         - Name: your-device-name\");\n\n    if (chip === \"ESP32 (Standard)\") {\n        lines.push(\"#         - Select: ESP32\");\n        lines.push(\"#         - Board: esp32dev (or specific board)\");\n        lines.push(\"#         - Framework: esp-idf (Recommended) or arduino\");\n    } else {\n        lines.push(\"#         - Select: ESP32-S3\");\n        lines.push(\"#         - Board: esp32-s3-devkitc-1\");\n        lines.push(\"#         - Framework: esp-idf (Recommended) or arduino\");\n    }\n\n    lines.push(\"#\");\n    lines.push(\"# ============================================================================\");\n    lines.push(\"\");\n\n    // infrastructure section (Commented out by default to follow snippet philosophy)\n    lines.push(\"#Infrastructure (Comment out if pasting into existing config)\");\n    lines.push(\"# esphome:\");\n    lines.push(`#   name: ${name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`);\n    lines.push(\"#\");\n    lines.push(\"# esp32:\");\n    lines.push(`#   board: ${getBoardForChip(chip)}`);\n    lines.push(\"#   framework:\");\n    lines.push(\"#     type: esp-idf\");\n    lines.push(\"\");\n\n    // PSRAM (Commented out by default)\n    if (psram) {\n        lines.push(\"# psram:\");\n        lines.push(\"#\");\n    }\n\n    // SPI Bus (Common for most displays)\n    if (pins.clk && pins.mosi) {\n        lines.push(\"spi:\");\n        lines.push(`  clk_pin: ${pins.clk}`);\n        lines.push(`  mosi_pin: ${pins.mosi}`);\n        if (pins.miso) lines.push(`  miso_pin: ${pins.miso}`);\n        lines.push(\"\");\n    }\n\n    // I2C Bus (For Touch)\n    if (pins.sda && pins.scl) {\n        lines.push(\"i2c:\");\n        lines.push(`  sda: ${pins.sda}`);\n        lines.push(`  scl: ${pins.scl}`);\n        lines.push(\"  scan: true\");\n        lines.push(\"\");\n    }\n\n    // Display\n    lines.push(\"display:\");\n    lines.push(`  - platform: ${displayDriver}`);\n    if (pins.cs) lines.push(`    cs_pin: ${pins.cs}`);\n    if (pins.dc) lines.push(`    dc_pin: ${pins.dc}`);\n    if (pins.rst) lines.push(`    reset_pin: ${pins.rst}`);\n    if (pins.busy) lines.push(`    busy_pin: ${pins.busy}`);\n\n    // Resolution specifics (often handled by the designer but useful in template)\n    // For many drivers, we need model or specific init\n    if (displayDriver === \"st7789v\") {\n        lines.push(\"    model: Custom\");\n        lines.push(\"    id: my_display\");\n        lines.push(`    width: ${resWidth}`);\n        lines.push(`    height: ${resHeight}`);\n        lines.push(\"    offset_height: 0\");\n        lines.push(\"    offset_width: 0\");\n    }\n\n    lines.push(\"    lambda: |-\");\n    lines.push(\"      # __LAMBDA_PLACEHOLDER__\");\n    lines.push(\"\");\n\n    // Backlight (PWM)\n    if (pins.backlight) {\n        lines.push(\"output:\");\n        lines.push(\"  - platform: ledc\");\n        lines.push(`    pin: ${pins.backlight}`);\n        lines.push(\"    id: backlight_pwm\");\n        lines.push(\"\");\n        lines.push(\"light:\");\n        lines.push(\"  - platform: monochromatic\");\n        lines.push(\"    output: backlight_pwm\");\n        lines.push(\"    name: Backlight\");\n        lines.push(\"    id: backlight_light\");\n        lines.push(\"    restore_mode: ALWAYS_ON\");\n        lines.push(\"\");\n    }\n\n    // Touchscreen\n    if (touchTech !== \"none\") {\n        lines.push(\"touchscreen:\");\n        lines.push(`  - platform: ${touchTech}`);\n        if (pins.touch_int) lines.push(`    interrupt_pin: ${pins.touch_int}`);\n        if (pins.touch_rst) lines.push(`    reset_pin: ${pins.touch_rst}`);\n        lines.push(\"\");\n    }\n\n    return lines.join('\\n');\n}\n\n/**\n * Returns a sensible default ESPHome board string based on the chip type.\n */\nfunction getBoardForChip(chip) {\n    switch (chip) {\n        case 'esp32-s3': return 'esp32-s3-devkitc-1';\n        case 'esp32-c3': return 'esp32-c3-devkitm-1';\n        case 'esp32-c6': return 'esp32-c6-devkitc-1';\n        case 'esp32': return 'esp32dev';\n        default: return 'esp32-s3-devkitc-1';\n    }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\hardware_generators.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'displayRotation' is assigned a value but never used. Allowed unused args must match /^_/u.","line":5,"column":79,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":94,"suggestions":[{"messageId":"removeVar","data":{"varName":"displayRotation"},"fix":{"range":[268,289],"text":""},"desc":"Remove unused variable 'displayRotation'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'displayId' is assigned a value but never used. Allowed unused args must match /^_/u.","line":271,"column":72,"nodeType":"Identifier","messageId":"unusedVar","endLine":271,"endColumn":81,"suggestions":[{"messageId":"removeVar","data":{"varName":"displayId"},"fix":{"range":[10006,10032],"text":""},"desc":"Remove unused variable 'displayId'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'allWidgets' is assigned a value but never used. Allowed unused args must match /^_/u.","line":271,"column":98,"nodeType":"Identifier","messageId":"unusedVar","endLine":271,"endColumn":108,"suggestions":[{"messageId":"removeVar","data":{"varName":"allWidgets"},"fix":{"range":[10032,10049],"text":""},"desc":"Remove unused variable 'allWidgets'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'label' is defined but never used. Allowed unused args must match /^_/u.","line":504,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":504,"endColumn":55,"suggestions":[{"messageId":"removeVar","data":{"varName":"label"},"fix":{"range":[20042,20049],"text":""},"desc":"Remove unused variable 'label'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// ============================================================================\n// HARDWARE SECTION GENERATORS\n// ============================================================================\n\nexport function generateTouchscreenSection(profile, displayId = \"my_display\", displayRotation = 0) {\n    if (!profile || !profile.touch) return []; // E-paper usually has no touch or handled differently\n\n    const t = profile.touch;\n    const lines = [\"touchscreen:\"];\n    lines.push(`  - platform: ${t.platform}`);\n    lines.push(`    id: my_touchscreen`);\n    lines.push(`    display: ${displayId}`);\n\n    if (t.i2c_id) lines.push(`    i2c_id: ${t.i2c_id}`);\n    if (t.spi_id) lines.push(`    spi_id: ${t.spi_id}`);\n\n    // Explicit addresses or update intervals\n    if (t.address) lines.push(`    address: ${t.address}`);\n    if (t.update_interval) lines.push(`    update_interval: ${t.update_interval}`);\n\n    // Pin mappings (some might be objects for IO extenders)\n    const addPin = (key, val) => {\n        if (!val) return;\n        if (typeof val === 'string' || typeof val === 'number') {\n            lines.push(`    ${key}: ${val}`);\n        } else {\n            lines.push(`    ${key}:`);\n            Object.entries(val).forEach(([k, v]) => lines.push(`      ${k}: ${v}`));\n        }\n    };\n\n    addPin(\"interrupt_pin\", t.interrupt_pin);\n    addPin(\"reset_pin\", t.reset_pin);\n    addPin(\"cs_pin\", t.cs_pin);\n\n    // Calc/Transform\n    const transform = [];\n    // Support both nested t.transform.* and flat t.* properties (Backwards compatibility)\n    const tx = t.transform || {};\n\n    if (t.mirror_x || tx.mirror_x) transform.push(\"mirror_x: true\");\n    if (t.mirror_y || tx.mirror_y) transform.push(\"mirror_y: true\");\n    if (t.swap_xy || tx.swap_xy) transform.push(\"swap_xy: true\");\n\n    if (transform.length > 0) {\n        lines.push(\"    transform:\");\n        transform.forEach(l => lines.push(`      ${l}`));\n    }\n\n    if (t.calibration) {\n        lines.push(\"    calibration:\");\n        // Calibration must reflect the raw hardware sensor range.\n        // The transform block (swap_xy, mirror_x, mirror_y) handles coordinate mapping.\n        const cal = t.calibration;\n        Object.entries(cal).forEach(([k, v]) => lines.push(`      ${k}: ${v}`));\n    }\n\n    lines.push(\"\");\n    return lines;\n}\n\nexport function generateBacklightSection(profile) {\n    const lines = [];\n    if (!profile || !profile.backlight) return lines;\n\n    const bl = profile.backlight;\n\n    // Output component for the backlight pin\n    if (bl.platform === \"ledc\" || bl.platform === \"gpio\" || bl.platform === \"switch\") {\n        if (bl.platform === \"switch\") {\n            lines.push(\"switch:\");\n            lines.push(\"  - platform: gpio\"); // Usually gpio switch for on/off backlights\n            lines.push(\"    id: lcdbacklight\");\n            lines.push(\"    name: lcdbacklight\");\n            // Handle complex pin objects (e.g. attached to IO expander)\n            if (typeof bl.pin === 'object') {\n                lines.push(\"    pin:\");\n                Object.entries(bl.pin).forEach(([k, v]) => {\n                    if (typeof v === 'object') {\n                        lines.push(`      ${k}:`);\n                        Object.entries(v).forEach(([sk, sv]) => lines.push(`        ${sk}: ${sv}`));\n                    } else {\n                        lines.push(`      ${k}: ${v}`);\n                    }\n                });\n            } else {\n                lines.push(`    pin: ${bl.pin}`);\n            }\n            lines.push(\"    restore_mode: ALWAYS_ON\");\n            lines.push(\"\");\n        } else {\n            lines.push(\"output:\");\n            lines.push(`  - platform: ${bl.platform}`);\n            lines.push(`    id: gpio_backlight_pwm`);\n            lines.push(`    pin: ${bl.pin}`);\n            if (bl.frequency) lines.push(`    frequency: ${bl.frequency}`);\n            lines.push(\"\");\n        }\n    }\n\n    // Light component to control it\n    lines.push(\"light:\");\n    lines.push(\"  - platform: monochromatic\");\n    lines.push(\"    name: Display Backlight\");\n    lines.push(\"    id: display_backlight\");\n    lines.push(\"    restore_mode: ALWAYS_ON\");\n\n    if (bl.platform === \"switch\") {\n        // Fake output for switch-based backlights (Waveshare 7\" style)\n        lines.push(\"    output: fake_backlight_output\");\n        lines.push(\"    default_transition_length: 0s\");\n        lines.push(\"\");\n        lines.push(\"output:\");\n        lines.push(\"  - platform: template\");\n        lines.push(\"    id: fake_backlight_output\");\n        lines.push(\"    type: float\");\n        lines.push(\"    write_action:\");\n        lines.push(\"      - if:\");\n        lines.push(\"          condition:\");\n        lines.push(\"            lambda: 'return state > 0.0;'\");\n        lines.push(\"          then:\");\n        lines.push(\"            - switch.turn_on: lcdbacklight\");\n        lines.push(\"          else:\");\n        lines.push(\"            - switch.turn_off: lcdbacklight\");\n    } else {\n        lines.push(\"    output: gpio_backlight_pwm\");\n    }\n    lines.push(\"\");\n    return lines;\n}\n\nexport function generateExtraComponents(profile) {\n    const lines = [];\n    if (profile.extra_components && Array.isArray(profile.extra_components)) {\n        lines.push(...profile.extra_components);\n        lines.push(\"\");\n    }\n    if (profile.extra_components_raw) {\n        lines.push(profile.extra_components_raw);\n        lines.push(\"\");\n    }\n    return lines;\n}\n\nexport function generateI2CSection(profile) {\n    const lines = [];\n    if (profile && profile.pins && profile.pins.i2c) {\n        lines.push(\"i2c:\");\n        lines.push(\"  - sda: \" + profile.pins.i2c.sda);\n        lines.push(\"    scl: \" + profile.pins.i2c.scl);\n        lines.push(\"    scan: \" + (profile.i2c_config?.scan !== false));\n        lines.push(\"    id: bus_a\");\n        if (profile.i2c_config?.frequency) {\n            lines.push(\"    frequency: \" + profile.i2c_config.frequency);\n        }\n        lines.push(\"\");\n    }\n    return lines;\n}\n\nexport function generateSPISection(profile) {\n    const lines = [];\n    if (profile && profile.pins && profile.pins.spi) {\n        lines.push(\"spi:\");\n        const spi = profile.pins.spi;\n        if (spi.id) lines.push(`  - id: ${spi.id}`);\n        else lines.push(\"  - id: spi_bus\");\n\n        lines.push(`    clk_pin: ${spi.clk}`);\n        if (spi.mosi) lines.push(`    mosi_pin: ${spi.mosi}`);\n        if (spi.miso) lines.push(`    miso_pin: ${spi.miso}`);\n\n        if (spi.type === \"quad\") {\n            lines.push(\"    interface: triple\");\n            if (spi.data_pins) {\n                lines.push(`    data_pins: [${spi.data_pins.join(', ')}]`);\n            }\n        }\n        lines.push(\"\");\n\n        // Extra SPI buses?\n        if (profile.extra_spi) {\n            lines.push(...profile.extra_spi);\n            lines.push(\"\");\n        }\n    }\n    return lines;\n}\n\nexport function generateDisplaySection(profile, orientation = 'landscape') {\n    const lines = [];\n    if (!profile) return lines;\n\n    const resolution = profile.resolution || { width: 800, height: 480 };\n    const isNativePortrait = resolution.height > resolution.width;\n    const isRequestedPortrait = orientation === 'portrait';\n\n    let displayRotation = 0;\n    if (isNativePortrait) {\n        displayRotation = isRequestedPortrait ? 0 : 90;\n    } else {\n        displayRotation = isRequestedPortrait ? 90 : 0;\n    }\n\n    if (profile.rotation_offset) {\n        displayRotation = (displayRotation + profile.rotation_offset) % 360;\n    }\n\n    if (profile.display_config) {\n        lines.push(\"display:\");\n        lines.push(...profile.display_config);\n        lines.push(\"\");\n    } else {\n        lines.push(\"display:\");\n        lines.push(`  - platform: ${profile.displayPlatform}`);\n        lines.push(\"    id: epaper_display\");\n\n        const p = (profile.pins && profile.pins.display) ? profile.pins.display : null;\n        if (p) {\n            const addPin = (key, val) => {\n                if (!val) return;\n                if (typeof val === 'object') {\n                    lines.push(`    ${key}:`);\n                    lines.push(`      number: ${val.number}`);\n                    if (val.inverted !== undefined) lines.push(`      inverted: ${val.inverted}`);\n                } else {\n                    lines.push(`    ${key}: ${val}`);\n                }\n            };\n\n            addPin(\"cs_pin\", p.cs);\n            addPin(\"dc_pin\", p.dc);\n            addPin(\"reset_pin\", p.reset);\n            addPin(\"busy_pin\", p.busy);\n        }\n\n\n        lines.push(`    rotation: ${displayRotation}`);\n        if (profile.displayModel === \"M5Paper\" || profile.displayPlatform === \"it8951e\") {\n            lines.push(\"    reversed: false\");\n            lines.push(\"    reset_duration: 100ms\");\n        }\n        else if (profile.displayModel) {\n            let modelLine = `    model: \"${profile.displayModel}\"`;\n            if (profile.displayModel === \"Seeed-reTerminal-E1002\") {\n                modelLine += \" #Please update your ESPHome version to 2025.11.1 above\";\n            }\n            lines.push(modelLine);\n        }\n\n        lines.push(\"    update_interval: never\");\n\n        const modelsWithFullUpdate = [\n            \"1.54in\", \"1.54inv2\", \"2.13in\", \"2.13in-ttgo\", \"2.13in-ttgo-b1\",\n            \"2.13in-ttgo-b73\", \"2.13in-ttgo-b74\", \"2.13in-ttgo-dke\", \"2.13inv2\", \"2.13inv3\",\n            \"2.90in\", \"2.90in-dke\", \"2.90inv2\", \"2.90inv2-r2\", \"7.50inv2\", \"7.50inv2p\",\n            \"gdew029t5\", \"gdey029t94\", \"gdey042t81\", \"gdey0583t81\"\n        ];\n        if (profile.displayModel && modelsWithFullUpdate.includes(profile.displayModel)) {\n            lines.push(\"    full_update_every: 30\");\n        }\n        lines.push(\"\");\n    }\n\n    const linkedDisplayId = profile.display_config ? \"my_display\" : \"epaper_display\";\n    lines.push(...generateTouchscreenSection(profile, linkedDisplayId, displayRotation));\n\n    return lines;\n}\n\nexport function generateSensorSection(profile, widgetSensorLines = [], displayId = \"my_display\", allWidgets = []) {\n    const lines = [];\n    if (!profile) return lines;\n\n\n    // Check if we need a sensor: block\n    const pins = profile.pins || {};\n    const hasBattery = pins.batteryAdc;\n    const hasSht4x = profile.features && profile.features.sht4x;\n    const hasShtc3 = profile.features && profile.features.shtc3;\n    const hasWidgets = widgetSensorLines.length > 0;\n\n    if (!hasBattery && !hasSht4x && !hasShtc3 && !hasWidgets) return lines;\n\n    lines.push(\"sensor:\");\n\n    // 1. Battery Voltage\n    if (hasBattery) {\n        lines.push(\"  - platform: adc\");\n        lines.push(`    pin: ${pins.batteryAdc}`);\n        lines.push(\"    name: \\\"Battery Voltage\\\"\");\n        lines.push(\"    unit_of_measurement: \\\"V\\\"\");\n        lines.push(\"    device_class: voltage\");\n        lines.push(\"    state_class: measurement\");\n        lines.push(\"    id: battery_voltage\");\n        lines.push(\"    update_interval: 60s\");\n        lines.push(\"    attenuation: \" + profile.battery.attenuation);\n        lines.push(\"    filters:\");\n        lines.push(\"      - multiply: \" + profile.battery.multiplier);\n    }\n\n    // 2. SHT4x (Temperature/Humidity)\n    if (hasSht4x) {\n        lines.push(\"  - platform: sht4x\");\n        lines.push(\"    id: sht4x_sensor\");\n        lines.push(\"    temperature:\");\n        lines.push(\"      name: \\\"Temperature\\\"\");\n        lines.push(\"      id: sht4x_temperature\");\n        lines.push(\"    humidity:\");\n        lines.push(\"      name: \\\"Humidity\\\"\");\n        lines.push(\"      id: sht4x_humidity\");\n        lines.push(\"    address: 0x44\");\n        lines.push(\"    update_interval: 60s\");\n    }\n\n    // 2b. SHT3x (Temperature/Humidity) - M5Paper\n    if (profile.features.sht3x) {\n        lines.push(\"  - platform: sht3xd\");\n        lines.push(\"    address: 0x44\");\n        lines.push(\"    temperature:\");\n        lines.push(\"      name: \\\"Temperature\\\"\");\n        lines.push(\"      id: sht3x_temperature\");\n        lines.push(\"    humidity:\");\n        lines.push(\"      name: \\\"Humidity\\\"\");\n        lines.push(\"      id: sht3x_humidity\");\n        lines.push(\"    update_interval: 60s\");\n    }\n\n    // 3. SHTC3 (Temperature/Humidity) - Uses shtcx platform in ESPHome\n    if (hasShtc3) {\n        lines.push(\"  - platform: shtcx\");\n        lines.push(\"    id: shtc3_sensor\");\n        lines.push(\"    i2c_id: bus_a\");\n        lines.push(\"    address: 0x70\");\n        lines.push(\"    temperature:\");\n        lines.push(\"      name: \\\"Temperature\\\"\");\n        lines.push(\"      id: shtc3_temperature\");\n        lines.push(\"    humidity:\");\n        lines.push(\"      name: \\\"Humidity\\\"\");\n        lines.push(\"      id: shtc3_humidity\");\n        lines.push(\"    update_interval: 60s\");\n    }\n\n    // 4. Widget Sensors\n    if (widgetSensorLines.length > 0) {\n        lines.push(...widgetSensorLines);\n    }\n\n    // 5. Battery Percentage Template\n    if (hasBattery) {\n        lines.push(\"\");\n        lines.push(\"  - platform: template\");\n        lines.push(\"    name: \\\"Battery Level\\\"\");\n        lines.push(\"    id: battery_level\");\n        lines.push(\"    unit_of_measurement: \\\"%\\\"\");\n        lines.push(\"    icon: \\\"mdi:battery\\\"\");\n        lines.push(\"    device_class: battery\");\n        lines.push(\"    state_class: measurement\");\n\n        if (profile.battery.curve) {\n            lines.push(\"    lambda: 'return id(battery_voltage).state;'\");\n            lines.push(\"    update_interval: 60s\");\n            lines.push(\"    filters:\");\n            lines.push(\"      - calibrate_linear:\");\n            profile.battery.curve.forEach(pt => {\n                lines.push(`          - ${pt.from} -> ${pt.to}`);\n            });\n            lines.push(\"      - clamp:\");\n            lines.push(\"          min_value: 0\");\n            lines.push(\"          max_value: 100\");\n        } else {\n            const minV = profile.battery.calibration ? profile.battery.calibration.min : 3.27;\n            const maxV = profile.battery.calibration ? profile.battery.calibration.max : 4.15;\n            lines.push(\"    lambda: |-\");\n            lines.push(`      if (id(battery_voltage).state > ${maxV}) return 100;`);\n            lines.push(`      if (id(battery_voltage).state < ${minV}) return 0;`);\n            lines.push(`      return (id(battery_voltage).state - ${minV}) / (${maxV} - ${minV}) * 100.0;`);\n        }\n    }\n\n    lines.push(\"\");\n    return lines;\n}\n\nexport function generateBinarySensorSection(profile, numPages, displayId = \"my_display\", touchAreaWidgets = []) {\n    const lines = [];\n    const hasButtons = profile && profile.features && profile.features.buttons;\n    const hasTouchAreas = touchAreaWidgets.length > 0;\n\n    if (!hasButtons && !hasTouchAreas) return lines;\n\n    lines.push(\"binary_sensor:\");\n\n    // 1. Physical Buttons\n    if (hasButtons) {\n        const isCoreInk = profile.name && profile.name.includes(\"CoreInk\");\n        const b = profile.pins.buttons || {};\n\n        if (b.left) {\n            lines.push(\"  - platform: gpio\"); // Left Button\n            lines.push(`    pin:`);\n            if (typeof b.left === 'object') {\n                lines.push(`      number: ${b.left.number}`);\n                lines.push(`      mode: ${b.left.mode || 'INPUT_PULLUP'}`);\n                lines.push(`      inverted: ${b.left.inverted !== undefined ? b.left.inverted : true}`);\n            } else {\n                lines.push(`      number: ${b.left}`);\n                lines.push(`      mode: INPUT_PULLUP`);\n                lines.push(`      inverted: true`);\n            }\n            lines.push(\"    name: \\\"Left Button\\\"\");\n            lines.push(\"    id: button_left\");\n            lines.push(\"    on_press:\");\n            lines.push(\"      then:\");\n            if (isCoreInk) {\n                lines.push(\"        - script.execute:\");\n                lines.push(\"            id: change_page_to\");\n                lines.push(`            target_page: !lambda 'return id(display_page) > 0 ? id(display_page) - 1 : ${numPages - 1};'`);\n                lines.push(\"        - script.stop: activity_timer\");\n                lines.push(\"        - script.execute: activity_timer\");\n            } else {\n                lines.push(\"        - script.execute:\");\n                lines.push(\"            id: change_page_to\");\n                lines.push(`            target_page: !lambda 'return id(display_page) > 0 ? id(display_page) - 1 : ${numPages - 1};'`);\n            }\n        }\n\n        if (b.right) {\n            lines.push(\"  - platform: gpio\"); // Right Button\n            lines.push(`    pin:`);\n            if (typeof b.right === 'object') {\n                lines.push(`      number: ${b.right.number}`);\n                lines.push(`      mode: ${b.right.mode || 'INPUT_PULLUP'}`);\n                lines.push(`      inverted: ${b.right.inverted !== undefined ? b.right.inverted : true}`);\n            } else {\n                lines.push(`      number: ${b.right}`);\n                lines.push(`      mode: INPUT_PULLUP`);\n                lines.push(`      inverted: true`);\n            }\n            lines.push(\"    name: \\\"Right Button\\\"\");\n            lines.push(\"    id: button_right\");\n            lines.push(\"    on_press:\");\n            lines.push(\"      then:\");\n            if (isCoreInk) {\n                lines.push(\"        - script.execute:\");\n                lines.push(\"            id: change_page_to\");\n                lines.push(`            target_page: !lambda 'return id(display_page) < ${numPages - 1} ? id(display_page) + 1 : 0;'`);\n                lines.push(\"        - script.stop: activity_timer\");\n                lines.push(\"        - script.execute: activity_timer\");\n            } else {\n                lines.push(\"        - script.execute:\");\n                lines.push(\"            id: change_page_to\");\n                lines.push(`            target_page: !lambda 'return id(display_page) < ${numPages - 1} ? id(display_page) + 1 : 0;'`);\n            }\n        }\n\n        if (b.refresh) {\n            lines.push(\"  - platform: gpio\"); // Refresh Button\n            lines.push(`    pin:`);\n            if (typeof b.refresh === 'object') {\n                lines.push(`      number: ${b.refresh.number}`);\n                lines.push(`      mode: ${b.refresh.mode || 'INPUT_PULLUP'}`);\n                lines.push(`      inverted: ${b.refresh.inverted !== undefined ? b.refresh.inverted : true}`);\n            } else {\n                lines.push(`      number: ${b.refresh}`);\n                lines.push(`      mode: INPUT_PULLUP`);\n                lines.push(`      inverted: true`);\n            }\n            const buttonName = isCoreInk ? \"Enter Button\" : \"Refresh Button\";\n            const buttonId = isCoreInk ? \"button_enter\" : \"button_refresh\";\n            lines.push(`    name: \"${buttonName}\"`);\n            lines.push(`    id: ${buttonId}`);\n            lines.push(\"    on_press:\");\n            lines.push(\"      then:\");\n            lines.push(`        - component.update: ${displayId}`);\n            if (isCoreInk) {\n                lines.push(\"        - script.stop: activity_timer\");\n                lines.push(\"        - script.execute: activity_timer\");\n            }\n        }\n    }\n\n    // 2. Touch Area Buttons\n    if (hasTouchAreas) {\n        lines.push(`  # Touch Area Binary Sensors`);\n        touchAreaWidgets.forEach(w => {\n            const t = (w.type || \"\").toLowerCase();\n            const p = w.props || {};\n\n            if (t === \"template_nav_bar\") {\n                const showPrev = p.show_prev !== false;\n                const showHome = p.show_home !== false;\n                const showNext = p.show_next !== false;\n\n                let activeCount = 0;\n                if (showPrev) activeCount++;\n                if (showHome) activeCount++;\n                if (showNext) activeCount++;\n\n                if (activeCount > 0) {\n                    const widthPerButton = Math.floor(w.width / activeCount);\n                    let currentIdx = 0;\n\n                    const addNavTouch = (action, label) => {\n                        const xMin = w.x + (currentIdx * widthPerButton);\n                        const xMax = xMin + widthPerButton;\n                        const yMin = w.y;\n                        const yMax = w.y + w.height;\n\n                        lines.push(`  - platform: touchscreen`);\n                        lines.push(`    id: nav_${action}_${w.id}`);\n                        lines.push(`    touchscreen_id: my_touchscreen`);\n                        lines.push(`    x_min: ${xMin}`);\n                        lines.push(`    x_max: ${xMax}`);\n                        lines.push(`    y_min: ${yMin}`);\n                        lines.push(`    y_max: ${yMax}`);\n                        lines.push(`    on_press:`);\n\n                        if (action === \"prev\") {\n                            lines.push(`      - script.execute:`);\n                            lines.push(`          id: change_page_to`);\n                            lines.push(`          target_page: !lambda 'return id(display_page) - 1;'`);\n                        } else if (action === \"home\") {\n                            lines.push(`      - script.execute: manage_run_and_sleep`);\n                        } else if (action === \"next\") {\n                            lines.push(`      - script.execute:`);\n                            lines.push(`          id: change_page_to`);\n                            lines.push(`          target_page: !lambda 'return id(display_page) + 1;'`);\n                        }\n                        currentIdx++;\n                    };\n\n                    if (showPrev) addNavTouch(\"prev\", \"Previous\");\n                    if (showHome) addNavTouch(\"home\", \"Home/Reload\");\n                    if (showNext) addNavTouch(\"next\", \"Next\");\n                }\n            } else {\n                const safeId = (w.entity_id || `touch_area_${w.id}`).replace(/[^a-zA-Z0-9_]/g, \"_\");\n                const iconSize = parseInt(String(p.icon_size || 40), 10);\n                const minWidth = Math.max(w.width, iconSize);\n                const minHeight = Math.max(w.height, iconSize);\n\n                let xMin = w.x - Math.floor((minWidth - w.width) / 2);\n                let xMax = xMin + minWidth;\n                let yMin = w.y - Math.floor((minHeight - w.height) / 2);\n                let yMax = yMin + minHeight;\n\n                xMin = Math.max(0, xMin);\n                yMin = Math.max(0, yMin);\n\n                const navAction = p.nav_action || \"none\";\n\n                lines.push(`  - platform: touchscreen`);\n                lines.push(`    id: ${safeId}`);\n                lines.push(`    touchscreen_id: my_touchscreen`);\n                lines.push(`    x_min: ${xMin}`);\n                lines.push(`    x_max: ${xMax}`);\n                lines.push(`    y_min: ${yMin}`);\n                lines.push(`    y_max: ${yMax}`);\n\n                if (navAction === \"next_page\") {\n                    lines.push(`    on_press:`);\n                    lines.push(`      - script.execute:`);\n                    lines.push(`          id: change_page_to`);\n                    lines.push(`          target_page: !lambda 'return id(display_page) + 1;'`);\n                } else if (navAction === \"previous_page\") {\n                    lines.push(`    on_press:`);\n                    lines.push(`      - script.execute:`);\n                    lines.push(`          id: change_page_to`);\n                    lines.push(`          target_page: !lambda 'return id(display_page) - 1;'`);\n                } else if (navAction === \"reload_page\") {\n                    lines.push(`    on_press:`);\n                    lines.push(`      - script.execute: manage_run_and_sleep`);\n                } else if (w.entity_id) {\n                    lines.push(`    on_press:`);\n                    lines.push(`      - homeassistant.service:`);\n                    lines.push(`          service: homeassistant.toggle`);\n                    lines.push(`          data:`);\n                    lines.push(`            entity_id: ${w.entity_id}`);\n                }\n            }\n        });\n    }\n\n    lines.push(\"\");\n    return lines;\n}\n\nexport function generateButtonSection(profile, numPages, displayId = \"my_display\") {\n    const lines = [];\n    lines.push(\"button:\");\n    lines.push(\"  - platform: template\");\n    lines.push(\"    name: \\\"Next Page\\\"\");\n    lines.push(\"    on_press:\");\n    lines.push(\"      then:\");\n    lines.push(\"        - script.execute:\");\n    lines.push(\"            id: change_page_to\");\n    lines.push(\"            target_page: !lambda 'return id(display_page) + 1;'\");\n\n    lines.push(\"  - platform: template\");\n    lines.push(\"    name: \\\"Previous Page\\\"\");\n    lines.push(\"    on_press:\");\n    lines.push(\"      then:\");\n    lines.push(\"        - script.execute:\");\n    lines.push(\"            id: change_page_to\");\n    lines.push(\"            target_page: !lambda 'return id(display_page) - 1;'\");\n\n    lines.push(\"  - platform: template\");\n    lines.push(\"    name: \\\"Refresh Display\\\"\");\n    lines.push(\"    on_press:\");\n    lines.push(\"      then:\");\n    lines.push(`        - component.update: ${displayId}`);\n\n    for (let i = 0; i < numPages; i++) {\n        lines.push(\"  - platform: template\");\n        lines.push(`    name: \"Go to Page ${i + 1}\"`);\n        lines.push(\"    on_press:\");\n        lines.push(\"      then:\");\n        lines.push(\"        - script.execute:\");\n        lines.push(\"            id: change_page_to\");\n        lines.push(`            target_page: ${i}`);\n    }\n\n    if (profile.features && profile.features.buzzer) {\n        lines.push(\"  # Buzzer Sounds\");\n        lines.push(\"  - platform: template\");\n        lines.push(\"    name: \\\"Play Beep Short\\\"\");\n        lines.push(\"    icon: \\\"mdi:bell-ring\\\"\");\n        lines.push(\"    on_press:\");\n        lines.push(\"      - rtttl.play: \\\"beep:d=32,o=5,b=200:16e6\\\"\");\n        lines.push(\"\");\n        lines.push(\"  - platform: template\");\n        lines.push(\"    name: \\\"Play Beep OK\\\"\");\n        lines.push(\"    icon: \\\"mdi:check-circle-outline\\\"\");\n        lines.push(\"    on_press:\");\n        lines.push(\"      - rtttl.play: \\\"ok:d=16,o=5,b=200:e6\\\"\");\n        lines.push(\"\");\n        lines.push(\"  - platform: template\");\n        lines.push(\"    name: \\\"Play Beep Error\\\"\");\n        lines.push(\"    icon: \\\"mdi:alert-circle-outline\\\"\");\n        lines.push(\"    on_press:\");\n        lines.push(\"      - rtttl.play: \\\"error:d=16,o=5,b=200:c6\\\"\");\n        lines.push(\"\");\n        lines.push(\"  - platform: template\");\n        lines.push(\"    name: \\\"Play Star Wars\\\"\");\n        lines.push(\"    icon: \\\"mdi:music-note\\\"\");\n        lines.push(\"    on_press:\");\n        lines.push(\"      - rtttl.play: \\\"StarWars:d=4,o=5,b=45:32p,32f,32f,32f,8a#.,8f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32d#,8c6\\\"\");\n    }\n\n    lines.push(\"\");\n    return lines;\n}\n\nexport function generatePSRAMSection(profile) {\n    const hasPsram = (profile.features && profile.features.psram) || (profile.features && profile.features.features && profile.features.features.psram);\n    if (!hasPsram) return [];\n\n    if (profile.psram_mode) {\n        return [\n            \"psram:\",\n            `  mode: ${profile.psram_mode}`,\n            \"  speed: 80MHz\",\n            \"\"\n        ];\n    }\n    return [\n        \"psram:\",\n        \"\"\n    ];\n}\n\nexport function generateAXP2101Section(profile) {\n    if (!profile.features || !profile.features.axp2101 || profile.features.manual_pmic) return [];\n\n    return [\n        \"axp2101:\",\n        \"  i2c_id: bus_a\",\n        \"  address: 0x34\",\n        \"  irq_pin: GPIO21\",\n        \"  battery_voltage:\",\n        \"    name: \\\"Battery Voltage\\\"\",\n        \"    id: battery_voltage\",\n        \"  battery_level:\",\n        \"    name: \\\"Battery Level\\\"\",\n        \"    id: battery_level\",\n        \"  on_setup:\",\n        \"    - axp2101.set_ldo_voltage:\",\n        \"        id: bldo1\",\n        \"        voltage: 3300mv\",\n        \"    - switch.turn_on: bldo1  # EPD_VCC (Screen Power)\",\n        \"    - axp2101.set_ldo_voltage:\",\n        \"        id: aldo1\",\n        \"        voltage: 3300mv\",\n        \"    - switch.turn_on: aldo1  # Peripherals\",\n        \"    - axp2101.set_ldo_voltage:\",\n        \"        id: aldo3\",\n        \"        voltage: 3300mv\",\n        \"    - switch.turn_on: aldo3  # Backlight/Logic\",\n        \"\"\n    ];\n}\n\nexport function generateOutputSection(profile) {\n    const lines = [];\n    if (!profile || !profile.pins || (!profile.pins.batteryEnable && !profile.pins.buzzer)) return lines;\n\n    lines.push(\"output:\");\n    if (profile.pins.batteryEnable) {\n        lines.push(\"  - platform: gpio\"); // Use standard gpio output\n        if (typeof profile.pins.batteryEnable === 'object') {\n            lines.push(\"    pin:\");\n            lines.push(`      number: ${profile.pins.batteryEnable.number}`);\n            if (profile.pins.batteryEnable.ignore_strapping_warning) {\n                lines.push(\"      ignore_strapping_warning: true\");\n            }\n            if (profile.pins.batteryEnable.inverted !== undefined) {\n                lines.push(`      inverted: ${profile.pins.batteryEnable.inverted}`);\n            }\n        } else {\n            lines.push(`    pin: ${profile.pins.batteryEnable}`);\n        }\n        lines.push(\"    id: bsp_battery_enable\");\n    }\n    if (profile.pins.buzzer) {\n        if (profile.pins.batteryEnable) lines.push(\"\");\n        lines.push(\"  - platform: ledc\");\n        lines.push(`    pin: ${profile.pins.buzzer}`);\n        lines.push(\"    id: buzzer_output\");\n    }\n    lines.push(\"\");\n    return lines;\n}\n\nexport function generateRTTTLSection(profile) {\n    if (!profile.features || !profile.features.buzzer) return [];\n    return [\n        \"rtttl:\",\n        \"  id: reterminal_buzzer\",\n        \"  output: buzzer_output\",\n        \"\"\n    ];\n}\n\nexport function generateAudioSection(profile) {\n    if (!profile || !profile.audio) return [];\n    const lines = [];\n    if (profile.audio.i2s_audio) {\n        lines.push(\"i2s_audio:\");\n        lines.push(`  i2s_lrclk_pin: ${profile.audio.i2s_audio.i2s_lrclk_pin}`);\n        lines.push(`  i2s_bclk_pin: ${profile.audio.i2s_audio.i2s_bclk_pin}`);\n        if (profile.audio.i2s_audio.i2s_mclk_pin) lines.push(`  i2s_mclk_pin: ${profile.audio.i2s_audio.i2s_mclk_pin}`);\n        lines.push(\"\");\n    }\n    if (profile.audio.speaker) {\n        lines.push(\"speaker:\");\n        lines.push(`  - platform: ${profile.audio.speaker.platform}`);\n        lines.push(`    id: my_speaker`);\n        if (profile.audio.speaker.dac_type) lines.push(`    dac_type: ${profile.audio.speaker.dac_type}`);\n        if (profile.audio.speaker.i2s_dout_pin) lines.push(`    i2s_dout_pin: ${profile.audio.speaker.i2s_dout_pin}`);\n        if (profile.audio.speaker.mode) lines.push(`    mode: ${profile.audio.speaker.mode}`);\n        lines.push(\"\");\n    }\n    return lines;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\hardware_import.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":67,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":67,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hardware Import and Dynamic Profile Management\n * \n * Handles fetching dynamic hardware templates from the backend\n * and uploading new YAML templates.\n */\n\nimport { Logger } from '../utils/logger.js';\nimport { hasHaBackend, HA_API_BASE } from '../utils/env.js';\nimport { getHaHeaders } from './ha_api.js';\nimport { showToast } from '../utils/dom.js';\n\nconst FALLBACK_HARDWARE_FILES = [\n    \"elecrow-esp32-7inch.yaml\",\n    \"guition-esp32-jc4827w543.yaml\",\n    \"guition-esp32-jc8048w535.yaml\",\n    \"guition-esp32-jc8048w550.yaml\",\n    \"guition-esp32-s3-4848s040.yaml\",\n    \"lilygo-tdisplays3.yaml\",\n    \"sunton-esp32-2432s028.yaml\",\n    \"sunton-esp32-2432s028R.yaml\",\n    \"sunton-esp32-4827s032R.yaml\",\n    \"sunton-esp32-8048s050.yaml\",\n    \"sunton-esp32-8048s070.yaml\",\n    \"waveshare-esp32-s3-touch-lcd-4.3.yaml\",\n    \"waveshare-esp32-s3-touch-lcd-7.yaml\",\n    \"waveshare-esp32-universal-epaper-7.5v2.yaml\"\n];\n\nexport async function fetchDynamicHardwareProfiles() {\n    // If we have an HA backend, try that first\n    if (hasHaBackend()) {\n        try {\n            const url = `${HA_API_BASE}/hardware/templates`;\n            Logger.log(\"[HardwareDiscovery] Fetching from:\", url);\n            const response = await fetch(url, {\n                headers: getHaHeaders(),\n                cache: \"no-store\"\n            });\n            if (!response.ok) throw new Error(`HTTP ${response.status}`);\n            const data = await response.json();\n            return data.templates || [];\n        } catch (e) {\n            Logger.error(\"Failed to fetch dynamic hardware templates from HA:\", e);\n            // Fall through to local check? Or just return?\n        }\n    }\n\n    // Fallback: Try to load known local files (for standalone/local mode)\n    Logger.log(\"[HardwareDiscovery] Attempting to load fallback local profiles...\");\n    const localTemplates = [];\n\n    for (const filename of FALLBACK_HARDWARE_FILES) {\n        try {\n            const response = await fetch(`hardware/${filename}`);\n            if (response.ok) {\n                const text = await response.text();\n                // We reuse the client-side parser used for offline import\n                // But we need to make sure the ID matches what we expect\n                const profile = parseHardwareRecipeClientSide(text, filename);\n                // Adjust ID to be more stable than \"dynamic_offline_...\"\n                profile.id = filename.replace(/\\.yaml$/i, '').replace(/[^a-z0-9]/gi, '_').toLowerCase();\n                profile.isPackageBased = true;\n                profile.hardwarePackage = `hardware/${filename}`;\n                localTemplates.push(profile);\n            }\n        } catch (err) {\n            // Ignore missing files\n        }\n    }\n\n    Logger.log(`[HardwareDiscovery] Loaded ${localTemplates.length} local fallback profiles.`);\n    return localTemplates;\n}\n\nexport async function uploadHardwareTemplate(file) {\n    if (!hasHaBackend()) {\n        Logger.log(\"[HardwareImport] Offline mode detected. Parsing locally...\");\n        return await handleOfflineHardwareImport(file);\n    }\n\n    const formData = new FormData();\n    formData.append(\"file\", file);\n\n    try {\n        const url = `${HA_API_BASE}/hardware/upload`;\n\n        // FIX: FormData requires the browser to set the Content-Type with the boundary.\n        // getHaHeaders() adds \"Content-Type\": \"application/json\", which breaks this.\n        const headers = getHaHeaders();\n        delete headers[\"Content-Type\"];\n\n        const response = await fetch(url, {\n            method: \"POST\",\n            headers: headers,\n            body: formData\n        });\n\n        const data = await response.json();\n        if (!response.ok) {\n            throw new Error(data.message || data.error || \"Upload failed\");\n        }\n\n        showToast(\"Hardware template uploaded successfully!\", \"success\");\n\n        // Refresh profiles\n        const { loadExternalProfiles } = await import('./devices.js');\n        if (loadExternalProfiles) {\n            await loadExternalProfiles();\n        }\n\n        return data;\n    } catch (e) {\n        Logger.error(\"Hardware upload failed:\", e);\n        showToast(`Upload failed: ${e.message}`, \"error\");\n        throw e;\n    }\n}\n\n/**\n * Handles hardware recipe import in offline mode by parsing in the browser.\n * These profiles are lost on refresh in offline mode.\n */\nasync function handleOfflineHardwareImport(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = async (e) => {\n            const content = e.target.result;\n            try {\n                if (!content.includes(\"__LAMBDA_PLACEHOLDER__\")) {\n                    throw new Error(\"Invalid template: Missing __LAMBDA_PLACEHOLDER__\");\n                }\n\n                const profile = parseHardwareRecipeClientSide(content, file.name);\n                Logger.log(\"[HardwareImport] Parsed offline profile:\", profile);\n\n                // Add to runtime structure\n                const { DEVICE_PROFILES } = await import('./devices.js');\n                if (DEVICE_PROFILES) {\n                    DEVICE_PROFILES[profile.id] = profile;\n                } showToast(`Imported ${profile.name} (Offline Mode)`, \"success\");\n\n                // Refresh UI\n                if (window.app && window.app.deviceSettings) {\n                    window.app.deviceSettings.populateDeviceSelect();\n                }\n\n                // Persist to localStorage for offline resilience\n                saveOfflineProfileToStorage(profile);\n\n                resolve(profile);\n            } catch (err) {\n                showToast(err.message, \"error\");\n                reject(err);\n            }\n        };\n        reader.onerror = () => reject(new Error(\"File read failed\"));\n        reader.readAsText(file);\n    });\n}\n\n/**\n * Extracts basic metadata from a YAML recipe string.\n */\nfunction parseHardwareRecipeClientSide(yaml, filename) {\n    const id = \"dynamic_offline_\" + filename.replace(/[^a-z0-9]/gi, '_').toLowerCase();\n\n    // Default values\n    let name = filename.replace(/\\.yaml$/i, '');\n    let width = 800;\n    let height = 480;\n    let shape = \"rect\";\n\n    // Simple regex extraction\n    const nameMatch = yaml.match(/#\\s*Name:\\s*(.*)/i);\n    if (nameMatch) name = nameMatch[1].trim();\n\n    const resMatch = yaml.match(/#\\s*Resolution:\\s*(\\d+)x(\\d+)/i);\n    if (resMatch) {\n        width = parseInt(resMatch[1]);\n        height = parseInt(resMatch[2]);\n    }\n\n    const shapeMatch = yaml.match(/#\\s*Shape:\\s*(rect|round)/i);\n    if (shapeMatch) shape = shapeMatch[1].toLowerCase();\n\n    // Detect inverted colors from comment (# Inverted: true)\n    const invertedMatch = yaml.match(/#\\s*Inverted:\\s*(true|yes|1)/i);\n    const isInverted = !!invertedMatch;\n\n    return {\n        id: id,\n        name: name + \" (Local)\",\n        resolution: { width, height },\n        shape: shape,\n        isPackageBased: true,\n        isOfflineImport: true,\n        content: yaml, // Store content for later use if needed\n        features: {\n            psram: yaml.includes(\"psram:\"),\n            lcd: !yaml.includes(\"waveshare_epaper\") && !yaml.includes(\"epaper_spi\"),\n            epaper: yaml.includes(\"waveshare_epaper\") || yaml.includes(\"epaper_spi\"),\n            inverted_colors: isInverted\n        }\n    };\n}\n\n/**\n * Saves a hardware profile to localStorage.\n */\nfunction saveOfflineProfileToStorage(profile) {\n    try {\n        const saved = JSON.parse(localStorage.getItem('esphome-offline-profiles') || '{}');\n        saved[profile.id] = profile;\n        localStorage.setItem('esphome-offline-profiles', JSON.stringify(saved));\n        Logger.log(\"[HardwarePersistence] Saved offline profile to localStorage:\", profile.id);\n    } catch (e) {\n        Logger.error(\"Failed to save profile to localStorage:\", e);\n    }\n}\n\n/**\n * Returns all saved offline profiles from localStorage.\n */\nexport function getOfflineProfilesFromStorage() {\n    try {\n        return JSON.parse(localStorage.getItem('esphome-offline-profiles') || '{}');\n    } catch (e) {\n        Logger.warn(\"Could not load offline profiles from storage:\", e);\n        return {};\n    }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\yaml_export.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":75,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":75,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * UI-linked logic for the ESPHome YAML snippet box.\n * This file handles highlighting and UI interactions, while YAML generation\n * has been migrated to ESPHomeAdapter.js and the plugin system.\n */\n\nimport { Logger } from '../utils/logger.js';\n\n// Global variables for snippet highlighting\n// Keeping them module-scoped since they are internal state for the highlighter\nlet lastHighlightRange = null;\nlet isAutoHighlight = false;\n\n// EXPOSE TO WINDOW for keyboard.js compatibility\n// This handles the \"smart delete/copy\" when snippet box is focused\nObject.defineProperty(window, 'lastHighlightRange', {\n    get: () => lastHighlightRange,\n    set: (val) => { lastHighlightRange = val; },\n    configurable: true\n});\nObject.defineProperty(window, 'isAutoHighlight', {\n    get: () => isAutoHighlight,\n    set: (val) => { isAutoHighlight = val; },\n    configurable: true\n});\n\n/**\n * Highlights a widget's YAML block in the snippet editor.\n * @param {string} widgetId \n */\nexport function highlightWidgetInSnippet(widgetId) {\n    const box = document.getElementById(\"snippetBox\");\n    if (!box) return;\n\n    const yaml = box.value;\n    if (!yaml) return;\n\n    // Search for the widget ID in the metadata comments\n    // Support both legacy (# widget:) and new (// widget:) formats\n    const targetStr = `id:${widgetId}`;\n    const index = yaml.indexOf(targetStr);\n\n    if (index !== -1) {\n        // Find the start of the line containing the ID\n        const lineStart = yaml.lastIndexOf('\\n', index) + 1;\n\n        // Find the next widget or page marker to determine block end\n        const nextMarkers = [\"# widget:\", \"// widget:\", \"// page:\"];\n        let nextMarkerIndex = -1;\n\n        nextMarkers.forEach(m => {\n            const idx = yaml.indexOf(m, index + targetStr.length);\n            if (idx !== -1 && (nextMarkerIndex === -1 || idx < nextMarkerIndex)) {\n                nextMarkerIndex = idx;\n            }\n        });\n\n        let blockEnd = nextMarkerIndex !== -1 ? nextMarkerIndex : yaml.length;\n\n        // Check if user is typing in a property field\n        const activeTag = document.activeElement ? document.activeElement.tagName.toLowerCase() : \"\";\n        const isTyping = (activeTag === \"input\" || activeTag === \"textarea\") && document.activeElement !== box;\n\n        // Only steal focus if NOT typing in properties AND not interacting with canvas\n        const isInteracting = window.Canvas && (window.Canvas.dragState || window.Canvas.lassoState);\n\n        // Only modify focus/selection if we rely on auto-highlight (not typing/interacting)\n        if (!isTyping && !isInteracting) {\n            isAutoHighlight = true;\n            box.focus();\n\n            // Apply selection using legacy backward direction for focus management\n            try {\n                box.setSelectionRange(lineStart, blockEnd, \"backward\");\n            } catch (e) {\n                // Fallback\n                box.setSelectionRange(lineStart, blockEnd);\n            }\n        }\n\n        lastHighlightRange = { start: lineStart, end: blockEnd };\n\n        // Scroll to selection\n        setTimeout(() => {\n            if (box.scrollTo) {\n                const lines = yaml.substring(0, lineStart).split('\\n');\n                const totalLines = yaml.split('\\n').length;\n                const lineNum = lines.length;\n\n                // Calculate dynamic line height based on actual rendered height\n                // This works for ANY font size (online or offline)\n                const lineHeight = box.scrollHeight / totalLines;\n\n                // Scroll to center the line\n                // box.scrollTop = (lineNum * lineHeight) - (box.clientHeight / 3);\n\n                // Since user requested \"focus on selected yaml\" (start of block):\n                // Align to top third for visibility\n                box.scrollTop = (lineNum * lineHeight) - 50;\n                box.scrollLeft = 0;\n            }\n        }, 10);\n    }\n}\n\n// Add listeners to reset auto-highlight when user interacts with the box\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const box = document.getElementById(\"snippetBox\");\n    if (box) {\n        const resetHighlight = () => {\n            isAutoHighlight = false;\n        };\n        box.addEventListener(\"mousedown\", resetHighlight);\n        box.addEventListener(\"input\", resetHighlight);\n        box.addEventListener(\"keydown\", (e) => {\n            if (!e.ctrlKey && !e.metaKey) {\n                isAutoHighlight = false;\n            }\n        });\n    }\n});\n\nLogger.log(\"[YAML Export] Minimal snippet UI logic loaded.\");\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\yaml_export_lvgl.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'hasTouch' is assigned a value but never used.","line":171,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":171,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"hasTouch"},"fix":{"range":[5799,5831],"text":""},"desc":"Remove unused variable 'hasTouch'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LVGL Configuration Generator\n * Handles generating ESPHome YAML for LVGL component, including hybrid mapping of native widgets.\n */\n\nimport { DEVICE_PROFILES } from './devices.js';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Generates the LVGL snippet for the ESPHome configuration.\n * @param {Array} pages - The list of pages.\n * @param {string} deviceModel - The device model.\n * @returns {Array} The generated lines of YAML.\n */\nexport function generateLVGLSnippet(pages, deviceModel) {\n    const lines = [];\n    const profile = DEVICE_PROFILES ? (DEVICE_PROFILES[deviceModel] || {}) : {};\n\n    // 1. Generate Global Config (Display settings for LVGL)\n    lines.push(\"# ============================================================================\");\n    lines.push(\"# LVGL Configuration\");\n    lines.push(\"# ============================================================================\");\n    lines.push(\"\");\n\n    lines.push(\"lvgl:\");\n    lines.push(\"  id: my_lvgl\");\n    lines.push(\"  log_level: WARN\");\n    lines.push(\"  bg_color: 0xFFFFFF\");\n    lines.push(\"  displays:\");\n\n    // Dynamic display ID based on device type\n    const displayId = profile.features?.lcd ? \"my_display\" : \"epaper_display\";\n    lines.push(`    - ${displayId}`);\n\n    // Configure touchscreen if device supports it\n    if (profile.touch) {\n        lines.push(\"  touchscreens:\");\n        lines.push(\"    - my_touchscreen\");\n    } else {\n        lines.push(\"  touchscreens: []\");\n    }\n    lines.push(\"\");\n\n    // 2. Widget Processing & Transpilation\n    lines.push(\"  pages:\");\n\n    pages.forEach((page, pageIndex) => {\n        lines.push(`    - id: page_${pageIndex}`);\n\n        // Add grid layout if page has one\n        if (page.layout && /^\\d+x\\d+$/.test(page.layout)) {\n            lines.push(`      layout: ${page.layout}`);\n        }\n\n        lines.push(`      widgets:`);\n\n        const widgets = page.widgets || [];\n        if (widgets.length === 0) {\n            lines.push(\"        []\");\n            return;\n        }\n\n        widgets.forEach(w => {\n            // Generate widget marker comment for import/parsing\n            lines.push(`        ${serializeWidget(w)}`);\n\n            const lvglWidget = transpileToLVGL(w, profile);\n            if (lvglWidget) {\n                // Determine widget type key (e.g., 'label:', 'obj:', 'button:')\n                const typeKey = Object.keys(lvglWidget)[0];\n                const props = lvglWidget[typeKey];\n\n                lines.push(`        - ${typeKey}:`);\n                // Recursive YAML serialization\n                serializeYamlObject(props, lines, 12);\n            }\n        });\n    });\n\n    return lines;\n}\n\n/**\n * Recursively serializes a JS object/array to YAML lines\n * @param {Object|Array} obj - The object or array to serialize.\n * @param {Array} lines - The lines array to append to.\n * @param {number} indentLevel - The current indentation level.\n */\nfunction serializeYamlObject(obj, lines, indentLevel) {\n    const spaces = \" \".repeat(indentLevel);\n\n    Object.entries(obj).forEach(([key, val]) => {\n        if (val === undefined || val === null || val === \"\") return;\n\n        if (Array.isArray(val)) {\n            if (val.length === 0) {\n                lines.push(`${spaces}${key}: []`);\n            } else {\n                lines.push(`${spaces}${key}:`);\n                val.forEach(item => {\n                    if (typeof item === 'object') {\n                        lines.push(`${spaces}  -`);\n                        // Increase indent for array item properties\n                        serializeYamlObject(item, lines, indentLevel + 4);\n                    } else {\n                        lines.push(`${spaces}  - ${item}`);\n                    }\n                });\n            }\n        } else if (typeof val === 'object') {\n            lines.push(`${spaces}${key}:`);\n            serializeYamlObject(val, lines, indentLevel + 2);\n        } else {\n            lines.push(`${spaces}${key}: ${val}`);\n        }\n    });\n}\n\n/**\n * Serializes a widget to the // widget:type ... format used by yaml_import.js\n * @param {Object} w - The widget object.\n * @returns {string} The serialized widget comment.\n */\nexport function serializeWidget(w) {\n    const parts = [`# widget:${w.type}`];\n\n    // Core properties\n    parts.push(`id:${w.id}`);\n    parts.push(`type:${w.type}`);\n    parts.push(`x:${Math.round(w.x)}`);\n    parts.push(`y:${Math.round(w.y)}`);\n    const width = w.w !== undefined ? w.w : (w.width !== undefined ? w.width : 0);\n    const height = w.h !== undefined ? w.h : (w.height !== undefined ? w.height : 0);\n\n    parts.push(`w:${Math.round(width)}`);\n    parts.push(`h:${Math.round(height)}`);\n\n    // Entity mapping\n    if (w.entity_id) parts.push(`entity:${w.entity_id}`);\n\n    // Extended properties\n    if (w.props) {\n        Object.entries(w.props).forEach(([k, v]) => {\n            if (v === undefined || v === null || v === \"\") return;\n            // Prevent property duplication or weird nesting\n            if (k === 'id' || k === 'type' || k === 'x' || k === 'y' || k === 'w' || k === 'h' || k === 'entity_id') return;\n\n            if (typeof v === 'object') {\n                try {\n                    parts.push(`${k}:${JSON.stringify(v)}`);\n                } catch (e) {\n                    Logger.warn(`[serializeWidget] Failed to serialize prop ${k}`, e);\n                }\n            } else {\n                parts.push(`${k}:${v}`);\n            }\n        });\n    }\n\n    return parts.join(\" \");\n}\n\n/**\n * Transpiles a designer widget JSON to an LVGL YAML object\n * @param {Object} w - The widget object.\n * @param {Object} profile - The device profile.\n * @returns {Object|null} The LVGL YAML object or null.\n */\nfunction transpileToLVGL(w, profile) {\n    const p = w.props || {};\n    const hasTouch = profile?.touch;\n\n    // Convert coordinates to integers\n    const x = Math.round(w.x || 0);\n    const y = Math.round(w.y || 0);\n    const w_w = Math.round(w.w || w.width || 100); // Fallbacks\n    const w_h = Math.round(w.h || w.height || 100);\n\n    // Common properties shared by many LVGL widgets\n    const common = {\n        x: x,\n        y: y,\n        width: w_w,\n        height: w_h,\n        hidden: p.hidden || undefined,\n        clickable: p.clickable === false ? false : undefined,\n        checkable: p.checkable || undefined,\n        scrollable: p.scrollable === false ? false : undefined,\n        floating: p.floating || undefined,\n        ignore_layout: p.ignore_layout || undefined,\n        scrollbar_mode: p.scrollbar_mode !== \"AUTO\" ? p.scrollbar_mode : undefined\n    };\n\n    // Plugin Hook: Check if the plugin supplies its own LVGL export logic\n    const registry = window.PluginRegistry;\n    if (registry) {\n        const plugin = registry.get(w.type);\n        if (plugin && typeof plugin.exportLVGL === 'function') {\n            return plugin.exportLVGL(w, {\n                profile,\n                common: common,\n                convertColor,\n                convertAlign,\n                getLVGLFont,\n                formatOpacity\n            });\n        }\n    }\n\n    // Fallback for generic LVGL widgets or warning\n    if (w.type && (w.type.startsWith(\"lvgl_\") || w.type.startsWith(\"shape_\") || w.type === \"rounded_rect\" || w.type === \"line\" || w.type === \"text\" || w.type === \"progress_bar\" || w.type === \"qr_code\")) {\n        Logger.warn(`[transpileToLVGL] Widget type ${w.type} has no exportLVGL function. Falling back to generic obj.`);\n        return { obj: { ...common, bg_color: convertColor(p.bg_color || p.color || \"white\") } };\n    }\n\n    return null;\n\n    // Helpers\n    function convertColor(hex) {\n        if (!hex || hex === \"transparent\") return \"0x000000\";\n        if (hex.startsWith(\"#\")) {\n            return \"0x\" + hex.substring(1).toUpperCase();\n        }\n        return hex;\n    }\n\n    function convertAlign(align) {\n        if (!align) return \"TOP_LEFT\";\n        const mapping = {\n            \"left\": \"TOP_LEFT\",\n            \"center\": \"CENTER\",\n            \"right\": \"TOP_RIGHT\"\n        };\n        return mapping[align.toLowerCase()] || align;\n    }\n\n    function getLVGLFont(family, size, weight, italic) {\n        const f = (family || \"Roboto\").toLowerCase().replace(/\\s+/g, \"_\");\n        const w = weight || 400;\n        const s = size || 20;\n        const i = italic ? \"_italic\" : \"\";\n        return `font_${f}_${w}_${s}${i}`;\n    }\n\n    function formatOpacity(opa) {\n        if (opa === undefined || opa === null) return \"COVER\";\n        if (typeof opa === \"number\") {\n            if (opa >= 255) return \"COVER\";\n            if (opa <= 0) return \"TRANSP\";\n            return Math.round((opa / 255) * 100) + \"%\";\n        }\n        return opa;\n    }\n}\n\n/**\n * Checks if the pages contain any LVGL widgets.\n * @param {Array} pages - The list of pages.\n * @returns {boolean} True if LVGL widgets are found.\n */\nexport function hasLVGLWidgets(pages) {\n    for (const p of pages) {\n        if (p.widgets) {\n            for (const w of p.widgets) {\n                if (w.type.startsWith(\"lvgl_\")) return true;\n            }\n        }\n    }\n    return false;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\io\\yaml_import.js","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":40,"column":58,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":40,"endColumn":59,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1493,1494],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1493,1493],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'cmd' is assigned a value but never used.","line":128,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":128,"endColumn":18,"suggestions":[{"messageId":"removeVar","data":{"varName":"cmd"},"fix":{"range":[5068,5092],"text":""},"desc":"Remove unused variable 'cmd'."}]},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":259,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":259,"endColumn":53},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":260,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":260,"endColumn":44},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":261,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":261,"endColumn":57},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":265,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":265,"endColumn":60},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":268,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":268,"endColumn":56},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":269,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":269,"endColumn":67},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":270,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":270,"endColumn":63},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":271,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":271,"endColumn":57},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":274,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":274,"endColumn":54},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":283,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":283,"endColumn":64},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":284,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":284,"endColumn":57},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":285,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":285,"endColumn":55},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":286,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":286,"endColumn":68},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":287,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":287,"endColumn":64},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":288,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":288,"endColumn":60},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":291,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":291,"endColumn":61},{"ruleId":"no-cond-assign","severity":2,"message":"Expected a conditional expression and instead saw an assignment.","line":294,"column":13,"nodeType":"AssignmentExpression","messageId":"missing","endLine":294,"endColumn":73},{"ruleId":"no-unused-vars","severity":1,"message":"'k' is defined but never used. Allowed unused args must match /^_/u.","line":383,"column":109,"nodeType":"Identifier","messageId":"unusedVar","endLine":383,"endColumn":110,"suggestions":[{"messageId":"removeVar","data":{"varName":"k"},"fix":{"range":[16709,16710],"text":""},"desc":"Remove unused variable 'k'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":1215,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":1215,"endColumn":39}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from '../core/state.js';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Parses an ESPHome YAML snippet offline to extract the layout.\n * @param {string} yamlText - The YAML string to parse.\n * @returns {Object} The parsed layout object containing pages and settings.\n */\nexport function parseSnippetYamlOffline(yamlText) {\n    Logger.log(\"[parseSnippetYamlOffline] Start parsing with js-yaml...\");\n    const rawLines = yamlText.split(/\\r?\\n/);\n    const lambdaLines = [];\n\n    let doc = {};\n    try {\n        if (window.jsyaml) {\n            doc = jsyaml.load(yamlText) || {};\n            Logger.log(\"[parseSnippetYamlOffline] YAML parsed successfully with js-yaml\");\n        }\n    } catch (e) {\n        Logger.error(\"[parseSnippetYamlOffline] YAML parse error:\", e);\n    }\n\n    // 1. Extract Display Lambdas or LVGL blocks from the parsed doc\n    if (doc.display) {\n        const displays = Array.isArray(doc.display) ? doc.display : [doc.display];\n        displays.forEach(d => {\n            if (d && d.lambda) {\n                lambdaLines.push(...d.lambda.split(\"\\n\"));\n            }\n        });\n    }\n\n    // 2. Fallback to manual scanning if js-yaml missed the lambda (e.g. malformed YAML or partial snippet)\n    if (lambdaLines.length === 0) {\n        let inLambda = false;\n        let lambdaIndent = 0;\n        for (const rawLine of rawLines) {\n            const line = rawLine.replace(/\\t/g, \"    \");\n            if (!inLambda && line.match(/^\\s*lambda:\\s*\\|\\-/)) {\n                inLambda = true;\n                continue;\n            }\n            if (inLambda) {\n                const indentMatch = line.match(/^(\\s+)/);\n                if (indentMatch) {\n                    const indentLen = indentMatch[1].length;\n                    if (lambdaIndent === 0) lambdaIndent = indentLen;\n                    if (indentLen < lambdaIndent) { inLambda = false; continue; }\n                    lambdaLines.push(line.slice(lambdaIndent));\n                } else if (line.trim() === \"\") {\n                    lambdaLines.push(\"\");\n                } else {\n                    // Check if it's a root key\n                    if (line.match(/^\\w+:/)) inLambda = false;\n                }\n            }\n        }\n    }\n\n    Logger.log(`[parseSnippetYamlOffline] Collected ${lambdaLines.length} info lines`);\n\n    const pageMap = new Map();\n    const intervalMap = new Map();\n    const nameMap = new Map();\n    const darkModeMap = new Map(); // Per-page dark mode setting\n    const refreshTypeMap = new Map();\n    const refreshTimeMap = new Map();\n    const pagePropsMap = new Map(); // Store page-level properties (bg_color, etc)\n    const layoutMap = new Map(); // Grid layout (e.g., \"4x4\")\n\n    // Helper to extract and parse a YAML sub-block starting from a given index\n    const parseYamlSubBlock = (linesList, startIdx, baseIndent) => {\n        const blockLines = [];\n        let j = startIdx;\n        while (j < linesList.length) {\n            const line = linesList[j];\n            if (!line) { j++; continue; }\n            const trimmed = line.trim();\n            if (!trimmed || trimmed.startsWith(\"#\")) {\n                blockLines.push(line);\n                j++;\n                continue;\n            }\n            const indentMatch = line.match(/^(\\s*)/);\n            const indent = indentMatch ? indentMatch[1].length : 0;\n            if (indent < baseIndent) break;\n            blockLines.push(line);\n            j++;\n        }\n        try {\n            const yamlStr = blockLines.join(\"\\n\");\n            return { value: jsyaml.load(yamlStr), nextJ: j };\n        } catch (e) {\n            Logger.error(\"Error parsing YAML sub-block:\", e);\n            return { value: null, nextJ: j };\n        }\n    };\n\n    // Use rawLines for original line-based scanning\n    const lines = rawLines;\n\n    let currentPageIndex = null;\n    let inWidgetsBlockLookahead = false;\n\n    const WIDGET_TAGS = [\n        \"label\", \"button\", \"arc\", \"bar\", \"slider\", \"chart\", \"dropdown\",\n        \"roller\", \"spinbox\", \"switch\", \"textarea\", \"obj\", \"img\",\n        \"qrcode\", \"led\", \"spinner\", \"line\", \"meter\", \"tabview\",\n        \"tileview\", \"checkbox\", \"keyboard\", \"buttonmatrix\", \"list\", \"icon\"\n    ];\n\n    const TAG_MAP = {\n        \"label\": \"lvgl_label\", \"button\": \"lvgl_button\", \"arc\": \"lvgl_arc\", \"bar\": \"lvgl_bar\",\n        \"slider\": \"lvgl_slider\", \"chart\": \"lvgl_chart\", \"dropdown\": \"lvgl_dropdown\",\n        \"roller\": \"lvgl_roller\", \"spinbox\": \"lvgl_spinbox\", \"switch\": \"lvgl_switch\",\n        \"textarea\": \"lvgl_textarea\", \"obj\": \"lvgl_obj\", \"img\": \"lvgl_img\",\n        \"qrcode\": \"lvgl_qrcode\", \"led\": \"lvgl_led\", \"spinner\": \"lvgl_spinner\",\n        \"line\": \"lvgl_line\", \"meter\": \"lvgl_meter\", \"tabview\": \"lvgl_tabview\",\n        \"tileview\": \"lvgl_tileview\", \"checkbox\": \"lvgl_checkbox\", \"keyboard\": \"lvgl_keyboard\",\n        \"buttonmatrix\": \"lvgl_buttonmatrix\", \"icon\": \"icon\"\n    };\n\n    for (let i = 0; i < lambdaLines.length; i++) {\n        const line = lambdaLines[i];\n        const trimmedLine = line.trim();\n        if (!trimmedLine) continue;\n        const cmd = trimmedLine; // For compatibility with legacy matching logic\n\n        // Native Lambda page check\n        let pageMatch = line.match(/if\\s*\\(\\s*(?:id\\s*\\(\\s*display_page\\s*\\)|page|currentPage)\\s*==\\s*(\\d+)\\s*\\)/);\n        if (pageMatch) {\n            currentPageIndex = parseInt(pageMatch[1], 10);\n            inWidgetsBlockLookahead = false;\n            if (!pageMap.has(currentPageIndex)) {\n                pageMap.set(currentPageIndex, []);\n            }\n        }\n\n        // LVGL Page check\n        // Looking for: \"    - id: main_page\" (or page_0, etc.)\n        const lvglPageMatch = line.match(/^\\s*-\\s*id:\\s*(\\w+)/);\n        if (lvglPageMatch) {\n            const pageIdStr = lvglPageMatch[1];\n            // If it's page_N, use N as index, otherwise use sequential index\n            const numMatch = pageIdStr.match(/^page_(\\d+)$/);\n            let idx = numMatch ? parseInt(numMatch[1], 10) : pageMap.size;\n\n            if (!pageMap.has(idx)) {\n                pageMap.set(idx, []);\n                nameMap.set(idx, pageIdStr); // Default name to ID\n            }\n            currentPageIndex = idx;\n            inWidgetsBlockLookahead = false;\n            Logger.log(`[parseSnippetYamlOffline] Detected LVGL Page: ${pageIdStr} (mapped to idx ${idx})`);\n        }\n\n        // Parse grid layout (e.g., \"layout: 4x4\")\n        const layoutMatch = line.match(/^\\s*layout:\\s*(\\d+x\\d+)/);\n        if (layoutMatch && currentPageIndex !== null) {\n            layoutMap.set(currentPageIndex, layoutMatch[1]);\n            Logger.log(`[parseSnippetYamlOffline] Detected layout: ${layoutMatch[1]} for page ${currentPageIndex}`);\n        }\n\n        if (trimmedLine.startsWith(\"widgets:\")) {\n            inWidgetsBlockLookahead = true;\n            continue;\n        }\n\n        const intervalMatch = line.match(/case\\s+(\\d+):\\s*interval\\s*=\\s*(\\d+);/);\n        if (intervalMatch) {\n            const idx = parseInt(intervalMatch[1], 10);\n            const val = parseInt(intervalMatch[2], 10);\n            intervalMap.set(idx, val);\n            // Ensure page exists in map even if no widgets yet\n            if (!pageMap.has(idx)) {\n                pageMap.set(idx, []);\n            }\n        }\n\n        const nameMatch = line.match(/\\/\\/\\s*page:name\\s+\"(.+)\"/);\n        if (nameMatch && currentPageIndex !== null) {\n            nameMap.set(currentPageIndex, nameMatch[1]);\n        }\n\n        // Parse per-page dark mode setting\n        const darkModeMatch = line.match(/\\/\\/\\s*page:dark_mode\\s+\"(.+)\"/);\n        if (darkModeMatch && currentPageIndex !== null) {\n            darkModeMap.set(currentPageIndex, darkModeMatch[1]);\n        }\n\n        const refreshTypeMatch = line.match(/\\/\\/\\s*page:refresh_type\\s+\"(.+)\"/);\n        if (refreshTypeMatch && currentPageIndex !== null) {\n            refreshTypeMap.set(currentPageIndex, refreshTypeMatch[1]);\n        }\n\n        const refreshTimeMatch = line.match(/\\/\\/\\s*page:refresh_time\\s+\"(.*)\"/);\n        if (refreshTimeMatch && currentPageIndex !== null) {\n            refreshTimeMap.set(currentPageIndex, refreshTimeMatch[1]);\n        }\n\n        // Native LVGL Page Properties (Only if NOT in a widgets block to avoid misattribution)\n        if (!inWidgetsBlockLookahead) {\n            const pgBgColorMatch = line.match(/^\\s*bg_color:\\s*(.*)/);\n            if (pgBgColorMatch && currentPageIndex !== null) {\n                let val = pgBgColorMatch[1].trim().replace(/^[\"']|[\"']$/g, \"\");\n                if (val.startsWith(\"0x\")) val = \"#\" + val.substring(2);\n                if (!pagePropsMap.has(currentPageIndex)) pagePropsMap.set(currentPageIndex, {});\n                pagePropsMap.get(currentPageIndex).bg_color = val;\n\n                // Auto-detect dark mode from background color\n                if (val.startsWith(\"#\")) {\n                    const hex = val.substring(1);\n                    if (hex.length === 6) {\n                        const r = parseInt(hex.substring(0, 2), 16);\n                        const g = parseInt(hex.substring(2, 4), 16);\n                        const b = parseInt(hex.substring(4, 6), 16);\n                        const brightness = (r * 299 + g * 587 + b * 114) / 1000;\n                        if (brightness < 128) {\n                            if (!darkModeMap.has(currentPageIndex)) {\n                                darkModeMap.set(currentPageIndex, \"dark\");\n                            }\n                        }\n                    }\n                }\n            }\n\n            const pgBgOpaMatch = line.match(/^\\s*bg_opa:\\s*(.*)/);\n            if (pgBgOpaMatch && currentPageIndex !== null) {\n                let val = pgBgOpaMatch[1].trim().replace(/^[\"']|[\"']$/g, \"\");\n                if (val.endsWith(\"%\")) val = String(Math.round(parseFloat(val) * 2.55));\n                if (!pagePropsMap.has(currentPageIndex)) pagePropsMap.set(currentPageIndex, {});\n                pagePropsMap.get(currentPageIndex).bg_opa = parseInt(val, 10);\n            }\n        }\n    }\n\n    // --- DEVICE LEVEL SETTINGS PARSING ---\n    // Extract settings from the header comments\n    const deviceSettings = {\n        orientation: \"landscape\",\n        dark_mode: false,\n        sleep_enabled: false,\n        sleep_start_hour: 0,\n        sleep_end_hour: 5,\n        manual_refresh_only: false,\n        deep_sleep_enabled: false,\n        deep_sleep_interval: 600,\n        daily_refresh_enabled: false,\n        daily_refresh_time: \"08:00\",\n        refresh_interval: 600\n    };\n\n    for (const rawLine of lines) {\n        const line = rawLine.trim();\n        if (!line.startsWith(\"#\")) continue;\n\n        let m;\n        if (m = line.match(/TARGET DEVICE:\\s*(.*)/i)) deviceSettings.target_device = m[1].trim();\n        if (m = line.match(/Name:\\s*(.*)/i)) deviceSettings.name = m[1].trim();\n        if (m = line.match(/Resolution:\\s*(\\d+)x(\\d+)/i)) {\n            deviceSettings.width = parseInt(m[1], 10);\n            deviceSettings.height = parseInt(m[2], 10);\n        }\n        if (m = line.match(/Shape:\\s*(rect|round|circle)/i)) {\n            deviceSettings.shape = m[1].toLowerCase() === \"rect\" ? \"rect\" : \"round\";\n        }\n        if (m = line.match(/Inverted:\\s*(true|false)/i)) deviceSettings.inverted_colors = (m[1].toLowerCase() === \"true\");\n        if (m = line.match(/Orientation:\\s*(landscape|portrait)/i)) deviceSettings.orientation = m[1].toLowerCase();\n        if (m = line.match(/Dark Mode:\\s*(enabled|disabled)/i)) deviceSettings.dark_mode = (m[1].toLowerCase() === \"enabled\");\n        if (m = line.match(/Refresh Interval:\\s*(\\d+)/i)) deviceSettings.refresh_interval = parseInt(m[1], 10);\n\n        // Handle New Power Strategy format\n        if (m = line.match(/Power Strategy:\\s*(.*)/i)) {\n            const strategy = m[1].trim().toLowerCase();\n            deviceSettings.sleep_enabled = strategy.includes(\"night\");\n            deviceSettings.manual_refresh_only = strategy.includes(\"manual\");\n            deviceSettings.deep_sleep_enabled = strategy.includes(\"ultra\") || strategy.includes(\"deep\");\n            deviceSettings.daily_refresh_enabled = strategy.includes(\"daily\");\n        }\n\n        // Individual settings (fallback or specific values)\n        if (m = line.match(/Sleep Mode:\\s*(enabled|disabled)/i)) deviceSettings.sleep_enabled = (m[1].toLowerCase() === \"enabled\");\n        if (m = line.match(/Sleep Start Hour:\\s*(\\d+)/i)) deviceSettings.sleep_start_hour = parseInt(m[1], 10);\n        if (m = line.match(/Sleep End Hour:\\s*(\\d+)/i)) deviceSettings.sleep_end_hour = parseInt(m[1], 10);\n        if (m = line.match(/Manual Refresh:\\s*(enabled|disabled)/i)) deviceSettings.manual_refresh_only = (m[1].toLowerCase() === \"enabled\");\n        if (m = line.match(/Deep Sleep:\\s*(enabled|disabled)/i)) deviceSettings.deep_sleep_enabled = (m[1].toLowerCase() === \"enabled\");\n        if (m = line.match(/Deep Sleep Interval:\\s*(\\d+)/i)) deviceSettings.deep_sleep_interval = parseInt(m[1], 10);\n\n        // Daily refresh specific\n        if (m = line.match(/Refresh Time:\\s*(\\d{2}:\\d{2})/i)) deviceSettings.daily_refresh_time = m[1];\n\n        // Silent Hours\n        if (m = line.match(/Disable updates from\\s*(\\d+)\\s*to\\s*(\\d+)/i)) {\n            deviceSettings.no_refresh_start_hour = parseInt(m[1], 10);\n            deviceSettings.no_refresh_end_hour = parseInt(m[2], 10);\n        }\n    }\n\n    if (pageMap.size === 0) {\n        pageMap.set(0, []);\n    }\n\n    const layout = {\n        settings: deviceSettings,\n        pages: Array.from(pageMap.entries()).sort((a, b) => a[0] - b[0]).map(([idx, _]) => ({\n            id: `page_${idx}`,\n            name: nameMap.has(idx) ? nameMap.get(idx) : `Page ${idx + 1}`,\n            refresh_s: intervalMap.has(idx) ? intervalMap.get(idx) : null,\n            refresh_type: refreshTypeMap.has(idx) ? refreshTypeMap.get(idx) : \"interval\",\n            refresh_time: refreshTimeMap.has(idx) ? refreshTimeMap.get(idx) : \"\",\n            dark_mode: darkModeMap.has(idx) ? darkModeMap.get(idx) : \"inherit\",\n            layout: layoutMap.has(idx) ? layoutMap.get(idx) : null,\n            bg_color: pagePropsMap.has(idx) ? pagePropsMap.get(idx).bg_color : null,\n            bg_opa: pagePropsMap.has(idx) ? pagePropsMap.get(idx).bg_opa : null,\n            widgets: []\n        }))\n    };\n\n\n    currentPageIndex = 0;\n\n    function getCurrentPageWidgets() {\n        // Fallback to 0 if page not found (could happen during init)\n        const page = layout.pages.find((p, idx) => idx === currentPageIndex);\n        return page ? page.widgets : layout.pages[0].widgets;\n    }\n\n    function parseWidgetMarker(comment) {\n        // Relaxed regex: allow any spacing and both # and // markers\n        const match = comment.match(/^(?:#\\s*|\\/\\/\\s*)widget:(\\w+)\\s+(.+)$/);\n        if (!match) {\n            if (comment.startsWith(\"// widget:\") || comment.startsWith(\"# widget:\")) {\n                Logger.warn(\"[parseWidgetMarker] Regex failed for:\", comment);\n            }\n            return null;\n        }\n\n        const widgetType = match[1];\n        const propsStr = match[2];\n        const props = {};\n\n        Logger.log(`[parseWidgetMarker] Found widget: ${widgetType}`);\n\n        // Improved regex to handle:\n        // 1. Quoted strings: key:\"value with spaces\"\n        // 2. Unquoted values: key:value\n        // 3. Unquoted values at the end of string: key:value with spaces\n        const regex = /(\\w+):(?:\"([^\"]*)\"|([^:]*?)(?=\\s+\\w+:|$))/g;\n        let m;\n        while ((m = regex.exec(propsStr)) !== null) {\n            let value = m[2] !== undefined ? m[2] : m[3];\n            if (value) {\n                value = value.trim();\n            }\n            props[m[1]] = value;\n        }\n\n        return { widgetType, props };\n    }\n\n    let skipRendering = false;\n\n    for (let i = 0; i < lambdaLines.length; i++) {\n        const cmd = lambdaLines[i];\n        const trimmed = cmd.trim();\n        if (!trimmed) continue;\n        // Skip pure comments, but NOT widget markers (which start with # widget:)\n        if (trimmed.startsWith(\"#\") && !trimmed.match(/^#\\s*widget:/)) continue;\n\n        // Native Lambda Page Check\n        let pageMatch = trimmed.match(/if\\s*\\(\\s*(?:id\\s*\\(\\s*display_page\\s*\\)|page|currentPage)\\s*==\\s*(\\d+)\\s*\\)/);\n        if (pageMatch) {\n            currentPageIndex = parseInt(pageMatch[1], 10);\n            continue;\n        }\n\n        // LVGL Page Check\n        const lvglPageMatch = trimmed.match(/^-\\s*id:\\s*(\\w+)/);\n        if (lvglPageMatch) {\n            const pageIdStr = lvglPageMatch[1];\n            const numMatch = pageIdStr.match(/^page_(\\d+)$/);\n            currentPageIndex = numMatch ? parseInt(numMatch[1], 10) : (Array.from(nameMap.entries()).find(([k, v]) => v === pageIdStr)?.[0] || 0);\n            Logger.log(`[parseSnippetYamlOffline] Processing widgets for page: ${pageIdStr} (idx ${currentPageIndex})`);\n            continue;\n        }\n\n        const widgets = getCurrentPageWidgets();\n\n        if (skipRendering) {\n            // Stop skipping if we see a new widget marker, a page transition, or a line with 0 indent\n            if (trimmed.match(/^(?:#\\s*|\\/\\/\\s*)widget:/) || trimmed.match(/^\\s*-\\s*id:/) || !cmd.match(/^\\s/)) {\n                skipRendering = false;\n            } else {\n                continue;\n            }\n        }\n\n        if (trimmed.startsWith(\"//\") || trimmed.startsWith(\"#\")) {\n            const marker = parseWidgetMarker(trimmed);\n            if (marker && marker.props.id) {\n                const p = marker.props;\n                // Use widgetType from marker as primary source of truth to avoid property name collisions (e.g. chart 'type')\n                // Only fall back to p.type if marker.widgetType is generic or missing (rare)\n                const widgetType = marker.widgetType || p.type;\n\n                // Keep p.type as the property value (e.g. \"LINE\") if it exists, don't overwrite it with widgetType\n\n                if (!widgetType) {\n                    Logger.warn(\"[parseSnippetYamlOffline] Widget marker found but no type determined:\", trimmed);\n                    continue;\n                }\n\n                // --- Default Dimensions Logic ---\n                let defaultW = 100;\n                let defaultH = 30;\n\n                if (widgetType === \"template_nav_bar\") {\n                    defaultW = 200;\n                    defaultH = 50;\n                } else if (widgetType === \"touch_area\") {\n                    defaultW = 100;\n                    defaultH = 100;\n                } else if ([\"nav_next_page\", \"nav_previous_page\", \"nav_reload_page\"].includes(widgetType)) {\n                    defaultW = 80;\n                    defaultH = 80;\n                } else if (widgetType === \"battery_icon\" || widgetType === \"wifi_signal\" || widgetType === \"icon\") {\n                    defaultW = 60;\n                    defaultH = 60;\n                }\n\n                const widget = {\n                    id: p.id,\n                    type: widgetType,\n                    x: parseInt(p.x || 0, 10),\n                    y: parseInt(p.y || 0, 10),\n                    width: parseInt(p.w || defaultW, 10),\n                    height: parseInt(p.h || defaultH, 10),\n                    title: p.title || \"\",\n                    entity_id: p.entity || p.ent || \"\",\n                    condition_entity: p.cond_ent || \"\",\n                    condition_operator: p.cond_op || \"\",\n                    condition_state: p.cond_state || \"\",\n                    condition_min: p.cond_min || \"\",\n                    condition_max: p.cond_max || \"\",\n                    props: {}\n                };\n\n                // Common LVGL properties\n                if (widgetType.startsWith(\"lvgl_\")) {\n                    // Pre-fill generic properties from p to ensure persistence of unhandled props\n                    Object.entries(p).forEach(([key, val]) => {\n                        if ([\"id\", \"type\", \"x\", \"y\", \"w\", \"h\", \"width\", \"height\"].includes(key)) return;\n\n                        // Basic normalization\n                        if (val === \"true\") widget.props[key] = true;\n                        else if (val === \"false\") widget.props[key] = false;\n                        else widget.props[key] = val;\n                    });\n\n                    widget.props.hidden = (p.hidden === \"true\");\n                    widget.props.clickable = (p.clickable !== \"false\");\n                    widget.props.checkable = (p.checkable === \"true\");\n                    widget.props.scrollable = (p.scrollable !== \"false\");\n                    widget.props.floating = (p.floating === \"true\");\n                    widget.props.ignore_layout = (p.ignore_layout === \"true\");\n                    widget.props.scrollbar_mode = p.scrollbar_mode || \"AUTO\";\n                    widget.props.opa = parseInt(p.opa || 255, 10);\n\n                    // Grid cell properties (accept both short and full names)\n                    const rowPos = p.grid_cell_row_pos ?? p.grid_row;\n                    const colPos = p.grid_cell_column_pos ?? p.grid_col;\n                    widget.props.grid_cell_row_pos = rowPos != null ? parseInt(rowPos, 10) : null;\n                    widget.props.grid_cell_column_pos = colPos != null ? parseInt(colPos, 10) : null;\n                    widget.props.grid_cell_row_span = parseInt(p.grid_cell_row_span || p.grid_row_span || 1, 10);\n                    widget.props.grid_cell_column_span = parseInt(p.grid_cell_column_span || p.grid_col_span || 1, 10);\n                    widget.props.grid_cell_x_align = p.grid_cell_x_align || p.grid_x_align || \"STRETCH\";\n                    widget.props.grid_cell_y_align = p.grid_cell_y_align || p.grid_y_align || \"STRETCH\";\n                }\n\n                if (widgetType === \"icon\") {\n                    widget.props = {\n                        code: p.code || \"F0595\",\n                        size: parseInt(p.size || 48, 10),\n                        color: p.color || \"black\",\n                        fit_icon_to_frame: (p.fit === \"true\" || p.fit === \"1\")\n                    };\n                } else if (widgetType === \"text\" || widgetType === \"label\") {\n                    widget.props = {\n                        text: p.text || \"\",\n                        font_size: parseInt(p.font_size || p.size || 20, 10),\n                        font_family: p.font_family || p.font || \"Roboto\",\n                        font_weight: parseInt(p.font_weight || p.weight || 400, 10),\n                        italic: (p.italic === \"true\" || p.italic === true),\n                        bpp: parseInt(p.bpp || 1, 10),\n                        color: p.color || \"black\",\n                        text_align: p.align || p.text_align || \"TOP_LEFT\"\n                    };\n                } else if (widgetType === \"sensor_text\") {\n                    widget.props = {\n                        label_font_size: parseInt(p.label_font || p.label_font_size || 14, 10),\n                        value_font_size: parseInt(p.value_font || p.value_font_size || 20, 10),\n                        value_format: p.format || \"label_value\",\n                        color: p.color || \"black\",\n                        italic: (p.italic === \"true\" || p.italic === true || p.font_style === \"italic\"),\n                        font_family: p.font_family || \"Roboto\",\n                        font_weight: parseInt(p.font_weight || 400, 10),\n                        prefix: p.prefix || \"\",\n                        postfix: p.postfix || \"\",\n                        unit: p.unit || \"\",\n                        hide_unit: (p.hide_unit === \"true\" || p.hide_unit === true),\n                        precision: parseInt(p.precision || -1, 10),\n                        text_align: p.align || p.text_align || \"TOP_LEFT\",\n                        label_align: p.label_align || p.align || p.text_align || \"TOP_LEFT\",\n                        value_align: p.value_align || p.align || p.text_align || \"TOP_LEFT\",\n                        is_local_sensor: (p.local === \"true\"),\n                        is_text_sensor: (p.text_sensor === \"true\"),\n                        separator: p.separator || \" ~ \"\n                    };\n                    widget.entity_id_2 = p.entity_2 || \"\";\n                } else if (widgetType === \"datetime\") {\n                    // Fix size persistence for datetime: use 200x60 defaults if missing, instead of generic 100x30\n                    widget.width = parseInt(p.w || 200, 10);\n                    widget.height = parseInt(p.h || 60, 10);\n\n                    widget.props = {\n                        format: p.format || \"time_date\",\n                        // Support new names (time_font_size, date_font_size) and legacy names (time_size, time_font, date_size, date_font)\n                        time_font_size: parseInt(p.time_font_size || p.time_size || p.time_font || 28, 10),\n                        date_font_size: parseInt(p.date_font_size || p.date_size || p.date_font || 16, 10),\n                        color: p.color || \"black\",\n                        italic: (p.italic === \"true\" || p.italic === true || p.font_style === \"italic\"),\n                        font_family: p.font_family || \"Roboto\",\n                        text_align: p.align || p.text_align || \"CENTER\"\n                    };\n                } else if (widgetType === \"progress_bar\") {\n                    widget.props = {\n                        show_label: (p.show_label !== \"false\"),\n                        show_percentage: (p.show_pct !== \"false\"),\n                        bar_height: parseInt(p.bar_h || p.bar_height || 15, 10),\n                        border_width: parseInt(p.border_w || p.border || 1, 10),\n                        color: p.color || \"black\",\n                        is_local_sensor: (p.local === \"true\")\n                    };\n                } else if (widgetType === \"battery_icon\") {\n                    widget.props = {\n                        size: parseInt(p.size || 32, 10),\n                        font_size: parseInt(p.font_size || 12, 10),\n                        color: p.color || \"black\",\n                        is_local_sensor: (p.local === \"true\"),\n                        fit_icon_to_frame: (p.fit === \"true\" || p.fit === \"1\")\n                    };\n                } else if (widgetType === \"wifi_signal\") {\n                    widget.props = {\n                        size: parseInt(p.size || 24, 10),\n                        font_size: parseInt(p.font_size || 12, 10),\n                        color: p.color || \"black\",\n                        is_local_sensor: (p.local !== \"false\"),\n                        show_dbm: (p.show_dbm !== \"false\"),\n                        fit_icon_to_frame: (p.fit === \"true\" || p.fit === \"1\")\n                    };\n                } else if (widgetType === \"ondevice_temperature\") {\n                    widget.props = {\n                        size: parseInt(p.size || 32, 10),\n                        font_size: parseInt(p.font_size || 16, 10),\n                        label_font_size: parseInt(p.label_font_size || 10, 10),\n                        color: p.color || \"black\",\n                        unit: p.unit || \"┬░C\",\n                        precision: parseInt(p.precision || 1, 10),\n                        show_label: (p.show_label !== \"false\"),\n                        is_local_sensor: (p.local !== \"false\"),\n                        fit_icon_to_frame: (p.fit === \"true\" || p.fit === \"1\")\n                    };\n                } else if (widgetType === \"ondevice_humidity\") {\n                    widget.props = {\n                        size: parseInt(p.size || 32, 10),\n                        font_size: parseInt(p.font_size || 16, 10),\n                        label_font_size: parseInt(p.label_font_size || 10, 10),\n                        color: p.color || \"black\",\n                        unit: p.unit || \"%\",\n                        precision: parseInt(p.precision || 0, 10),\n                        show_label: (p.show_label !== \"false\"),\n                        is_local_sensor: (p.local !== \"false\"),\n                        fit_icon_to_frame: (p.fit === \"true\" || p.fit === \"1\")\n                    };\n                } else if (widgetType === \"weather_icon\") {\n                    widget.props = {\n                        size: parseInt(p.size || 48, 10),\n                        color: p.color || \"black\"\n                    };\n                } else if (widgetType === \"qr_code\") {\n                    widget.props = {\n                        value: p.value || \"https://esphome.io\",\n                        scale: parseInt(p.scale || 2, 10),\n                        ecc: p.ecc || \"LOW\",\n                        color: p.color || \"black\"\n                    };\n                } else if (widgetType === \"image\") {\n                    widget.props = {\n                        path: (p.path || \"\").replace(/^\"|\"$/g, ''),\n                        invert: (p.invert === \"true\" || p.invert === \"1\"),\n                        dither: p.dither || \"FLOYDSTEINBERG\",\n                        transparency: p.transparency || \"\",\n                        image_type: p.img_type || \"BINARY\",\n                        render_mode: p.render_mode || \"Auto\"\n                    };\n                } else if (widgetType === \"online_image\") {\n                    widget.props = {\n                        url: p.url || \"\",\n                        invert: (p.invert === \"true\" || p.invert === \"1\"),\n                        interval_s: parseInt(p.interval || 300, 10),\n                        render_mode: p.render_mode || \"Auto\"\n                    };\n                } else if (widgetType === \"puppet\") {\n                    widget.props = {\n                        image_url: p.url || \"\",\n                        invert: (p.invert === \"true\" || p.invert === \"1\"),\n                        image_type: p.img_type || \"RGB565\",\n                        transparency: p.transparency || \"opaque\",\n                        render_mode: p.render_mode || \"Auto\"\n                    };\n                } else if (widgetType === \"shape_rect\") {\n                    widget.props = {\n                        fill: (p.fill === \"true\" || p.fill === \"1\"),\n                        border_width: parseInt(p.border || 1, 10),\n                        color: p.color || \"black\",\n                        border_color: p.border_color || p.color || \"black\",\n                        opacity: parseInt(p.opacity || 100, 10)\n                    };\n                } else if (widgetType === \"touch_area\") {\n                    widget.props = {\n                        title: p.title || \"Touch Area\",\n                        color: p.color || \"rgba(0, 0, 255, 0.2)\",\n                        border_color: p.border_color || \"#0000ff\",\n                        icon: p.icon || \"\",\n                        icon_pressed: p.icon_pressed || \"\",\n                        icon_size: parseInt(p.icon_size || 40, 10),\n                        icon_color: p.icon_color || \"black\",\n                        nav_action: p.nav_action || \"none\"\n                    };\n                } else if (widgetType === \"rounded_rect\") {\n                    widget.props = {\n                        fill: (p.fill === \"true\" || p.fill === \"1\"),\n                        // Robustly parse show_border, defaulting to true if not explicitly false\n                        show_border: (p.show_border !== \"false\" && p.show_border !== \"0\"),\n                        border_width: parseInt(p.border || 4, 10),\n                        radius: parseInt(p.radius || 10, 10),\n                        color: p.color || \"black\",\n                        border_color: p.border_color || \"black\",\n                        opacity: parseInt(p.opacity || 100, 10)\n                    };\n                } else if (widgetType === \"shape_circle\") {\n                    widget.props = {\n                        fill: (p.fill === \"true\" || p.fill === \"1\"),\n                        border_width: parseInt(p.border || 1, 10),\n                        color: p.color || \"black\",\n                        border_color: p.border_color || p.color || \"black\",\n                        opacity: parseInt(p.opacity || 100, 10)\n                    };\n                } else if (widgetType === \"line\") {\n                    widget.props = {\n                        stroke_width: parseInt(p.stroke || 3, 10),\n                        color: p.color || \"black\",\n                        orientation: p.orientation || \"horizontal\"\n                    };\n                } else if (widgetType === \"graph\") {\n                    widget.entity_id = p.entity || \"\";\n                    widget.props = {\n                        duration: p.duration || \"1h\",\n                        border: (p.border === \"true\" || p.border === \"1\" || p.border == null),\n                        grid: (p.grid === \"true\" || p.grid === \"1\" || p.grid == null),\n                        color: p.color || \"black\",\n                        x_grid: p.x_grid || \"\",\n                        y_grid: p.y_grid || \"\",\n                        line_thickness: parseInt(p.line_thickness || 3, 10),\n                        line_type: p.line_type || \"SOLID\",\n                        continuous: (p.continuous !== \"false\" && p.continuous !== \"0\"),\n                        min_value: p.min_value || \"\",\n                        max_value: p.max_value || \"\",\n                        min_range: p.min_range || \"\",\n                        max_range: p.max_range || \"\",\n                        is_local_sensor: (p.local === \"true\")\n                    };\n                } else if (widgetType === \"quote_rss\") {\n                    widget.props = {\n                        feed_url: p.feed_url || \"https://www.brainyquote.com/link/quotebr.rss\",\n                        show_author: (p.show_author !== \"false\"),\n                        random: (p.random !== \"false\"),\n                        refresh_interval: p.refresh_interval || p.refresh || \"24h\",\n                        quote_font_size: parseInt(p.quote_font_size || p.quote_font || 18, 10),\n                        author_font_size: parseInt(p.author_font_size || p.author_font || 14, 10),\n                        font_family: p.font_family || p.font || \"Roboto\",\n                        font_weight: parseInt(p.font_weight || p.weight || 400, 10),\n                        color: p.color || \"black\",\n                        text_align: p.align || p.text_align || \"TOP_LEFT\",\n                        word_wrap: (p.word_wrap !== \"false\" && p.wrap !== \"false\"),\n                        italic_quote: (p.italic_quote !== \"false\")\n                    };\n                } else if (widgetType === \"weather_forecast\") {\n                    widget.props = {\n                        weather_entity: p.weather_entity || \"\",\n                        layout: p.layout || \"horizontal\",\n                        show_high_low: (p.show_high_low !== \"false\"),\n                        day_font_size: parseInt(p.day_font_size || 12, 10),\n                        temp_font_size: parseInt(p.temp_font_size || 14, 10),\n                        icon_size: parseInt(p.icon_size || 32, 10),\n                        font_family: p.font_family || \"Roboto\",\n                        color: p.color || \"black\"\n                    };\n                } else if (widgetType === \"template_sensor_bar\") {\n                    widget.props = {\n                        show_wifi: (p.wifi !== \"false\"),\n                        show_temperature: (p.temp !== \"false\"),\n                        show_humidity: (p.hum !== \"false\"),\n                        show_battery: (p.bat !== \"false\"),\n                        show_background: (p.bg !== \"false\"),\n                        background_color: p.bg_color || \"gray\",\n                        border_radius: parseInt(p.radius || 8, 10),\n                        icon_size: parseInt(p.icon_size || 20, 10),\n                        font_size: parseInt(p.font_size || 14, 10),\n                        color: p.color || \"black\"\n                    };\n                } else if (widgetType === \"template_nav_bar\") {\n                    widget.props = {\n                        show_prev: (p.prev !== \"false\"),\n                        show_home: (p.home !== \"false\"),\n                        show_next: (p.next !== \"false\"),\n                        show_background: (p.bg !== \"false\"),\n                        background_color: p.bg_color || \"gray\",\n                        border_radius: parseInt(p.radius || 8, 10),\n                        icon_size: parseInt(p.icon_size || 24, 10),\n                        color: p.color || \"black\"\n                    };\n                } else if (widgetType === \"lvgl_button\") {\n\n                    Logger.log(\"[YAML_IMPORT] Parsing lvgl_button\", p.id, p);\n                    widget.props = {\n                        ...widget.props,\n                        text: p.text || \"BTN\",\n                        bg_color: p.bg_color || \"white\",\n                        color: p.color || \"black\",\n                        border_width: parseInt(p.border_width || p.border || 2, 10),\n                        radius: parseInt(p.radius || 5, 10),\n                        checkable: (p.checkable === \"true\")\n                    };\n                    if (p.title) widget.title = p.title;\n                } else if (widgetType === \"lvgl_arc\") {\n                    widget.props = {\n                        ...widget.props,\n                        min: parseInt(p.min || 0, 10),\n                        max: parseInt(p.max || 100, 10),\n                        value: parseInt(p.value || 0, 10),\n                        thickness: parseInt(p.thickness || 10, 10),\n                        color: p.color || \"blue\",\n                        start_angle: parseInt(p.start_angle || 135, 10),\n                        end_angle: parseInt(p.end_angle || 45, 10),\n                        mode: p.mode || \"NORMAL\"\n                    };\n                    // Ensure title is captured for Arc\n                    if (p.title) {\n                        widget.title = p.title;\n                        widget.props.title = p.title;\n                    }\n                } else if (widgetType === \"lvgl_chart\") {\n                    widget.props = {\n                        ...widget.props,\n                        title: p.title || \"Graph\",\n                        type: p.type || \"LINE\",\n                        color: p.color || \"black\",\n                        bg_color: p.bg_color || \"white\",\n                        point_count: parseInt(p.point_count || 10, 10),\n                        x_div_lines: parseInt(p.x_div_lines || 3, 10),\n                        y_div_lines: parseInt(p.y_div_lines || 3, 10)\n                    };\n                    if (p.title) widget.title = p.title;\n\n                } else if (widgetType === \"lvgl_img\") {\n                    widget.props = {\n                        ...widget.props,\n                        src: p.src || \"symbol_image\",\n                        rotation: parseInt(p.rotation || 0, 10),\n                        scale: parseInt(p.scale || 256, 10),\n                        pivot_x: parseInt(p.pivot_x || 0, 10),\n                        pivot_y: parseInt(p.pivot_y || 0, 10),\n                        color: p.color || \"black\"\n                    };\n\n                } else if (widgetType === \"lvgl_qrcode\") {\n                    widget.props = {\n                        ...widget.props,\n                        text: p.text || \"https://esphome.io\",\n                        scale: parseInt(p.scale || 2, 10),\n                        color: p.color || \"black\",\n                        bg_color: p.bg_color || \"white\"\n                    };\n\n                } else if (widgetType === \"lvgl_bar\") {\n                    widget.props = {\n                        ...widget.props,\n                        min: parseInt(p.min || 0, 10),\n                        max: parseInt(p.max || 100, 10),\n                        value: parseInt(p.value || 0, 10),\n                        color: p.color || \"blue\",\n                        bg_color: p.bg_color || \"gray\",\n                        start_value: parseInt(p.start_value || 0, 10),\n                        mode: p.mode || \"NORMAL\"\n                    };\n\n                } else if (widgetType === \"lvgl_slider\") {\n                    widget.props = {\n                        ...widget.props,\n                        min: parseInt(p.min || 0, 10),\n                        max: parseInt(p.max || 100, 10),\n                        value: parseInt(p.value || 30, 10),\n                        border_width: parseInt(p.border_width || 2, 10),\n                        color: p.color || \"blue\",\n                        bg_color: p.bg_color || \"gray\",\n                        mode: p.mode || \"NORMAL\",\n                        vertical: (p.vertical === \"true\" || p.vertical === true)\n                    };\n                } else if (widgetType === \"lvgl_tabview\") {\n                    widget.props = {\n                        ...widget.props,\n                        bg_color: p.bg_color || \"white\",\n                        tabs: (p.tabs || \"\").split(\",\").map(t => t.trim()).filter(t => t)\n                    };\n                } else if (widgetType === \"lvgl_tileview\") {\n                    widget.props = {\n                        ...widget.props,\n                        bg_color: p.bg_color || \"white\",\n                        tiles: [] // tile structure not easily parseable from flat props yet, defaulting empty\n                    };\n                } else if (widgetType === \"lvgl_led\") {\n                    widget.props = {\n                        ...widget.props,\n                        color: p.color || \"red\",\n                        brightness: parseInt(p.brightness || 255, 10)\n                    };\n                } else if (widgetType === \"lvgl_spinner\") {\n                    widget.props = {\n                        ...widget.props,\n                        spin_time: parseInt(p.spin_time || 1000, 10),\n                        arc_length: parseInt(p.arc_length || 60, 10),\n                        arc_color: p.arc_color || \"blue\",\n                        track_color: p.track_color || \"white\"\n                    };\n                } else if (widgetType === \"lvgl_buttonmatrix\") {\n                    widget.props = {\n                        ...widget.props,\n                        rows: [] // Complex structure, placeholder for now\n                    };\n                } else if (widgetType === \"lvgl_checkbox\") {\n                    widget.props = {\n                        ...widget.props,\n                        text: (p.text || \"Checkbox\").replace(/^\"|\"$/g, ''),\n                        checked: (p.checked === \"true\" || p.checked === true),\n                        color: p.color || \"blue\"\n                    };\n                } else if (widgetType === \"lvgl_dropdown\") {\n                    widget.props = {\n                        ...widget.props,\n                        options: (p.options || \"\").replace(/\\\\n/g, \"\\n\"), // handle escaped newlines\n                        selected_index: parseInt(p.selected_index || 0, 10),\n                        color: p.color || \"white\",\n                        direction: p.direction || \"DOWN\",\n                        max_height: parseInt(p.max_height || 200, 10)\n                    };\n                } else if (widgetType === \"lvgl_keyboard\") {\n                    widget.props = {\n                        ...widget.props,\n                        mode: p.mode || \"TEXT_UPPER\",\n                        textarea_id: p.textarea || \"\"\n                    };\n                } else if (widgetType === \"lvgl_roller\") {\n                    widget.props = {\n                        ...widget.props,\n                        options: (p.options || \"\").replace(/\\\\n/g, \"\\n\"),\n                        visible_row_count: parseInt(p.visible_row_count || 3, 10),\n                        color: p.color || \"white\",\n                        bg_color: p.bg_color || \"black\",\n                        selected_bg_color: p.selected_bg_color || \"blue\",\n                        selected_text_color: p.selected_text_color || \"white\",\n                        mode: p.mode || \"NORMAL\"\n                    };\n                } else if (widgetType === \"lvgl_spinbox\") {\n                    widget.props = {\n                        ...widget.props,\n                        min: parseInt(p.range_from || p.min || 0, 10),\n                        max: parseInt(p.range_to || p.max || 100, 10),\n                        digit_count: parseInt(p.digits || p.digit_count || 4, 10),\n                        step: parseInt(p.step || 1, 10),\n                        value: parseInt(p.value || 0, 10)\n                    };\n                } else if (widgetType === \"lvgl_switch\") {\n                    widget.props = {\n                        ...widget.props,\n                        checked: (p.state === \"true\" || p.state === true || p.checked === \"true\"),\n                        bg_color: p.bg_color || \"gray\",\n                        color: p.color || \"blue\", // indicator\n                        knob_color: p.knob_color || \"white\"\n                    };\n                } else if (widgetType === \"lvgl_textarea\") {\n                    widget.props = {\n                        ...widget.props,\n                        placeholder: (p.placeholder_text || p.placeholder || \"\").replace(/^\"|\"$/g, ''),\n                        text: (p.text || \"\").replace(/^\"|\"$/g, ''),\n                        one_line: (p.one_line === \"true\" || p.one_line === true),\n                        max_length: parseInt(p.max_length || 0, 10),\n                        password_mode: (p.password_mode === \"true\"),\n                        accepted_chars: p.accepted_chars || \"\"\n                    };\n                } else if (widgetType === \"lvgl_label\") {\n                    widget.props = {\n                        ...widget.props,\n                        text: (p.text || \"Label\").replace(/^\"|\"$/g, ''),\n                        font_size: parseInt(p.font_size || p.size || 20, 10),\n                        font_family: p.font_family || \"Roboto\",\n                        font_weight: parseInt(p.font_weight || 400, 10),\n                        italic: (p.italic === \"true\" || p.italic === true),\n                        color: p.color || \"black\",\n                        bg_color: p.bg_color || \"transparent\",\n                        text_align: p.text_align || p.align || \"CENTER\"\n                    };\n                } else if (widgetType === \"lvgl_line\") {\n                    widget.props = {\n                        ...widget.props,\n                        orientation: p.orientation || \"horizontal\",\n                        points: p.points || \"\", // Keep points if present for backward combat, but orientation rules\n                        line_width: parseInt(p.line_width || 3, 10),\n                        line_color: p.line_color || p.color || \"black\",\n                        line_rounded: (p.line_rounded !== \"false\")\n                    };\n                } else if (widgetType === \"lvgl_meter\") {\n                    widget.props = {\n                        ...widget.props,\n                        min: parseInt(p.min || 0, 10),\n                        max: parseInt(p.max || 100, 10),\n                        value: parseInt(p.value || 60, 10),\n                        color: p.color || \"black\",\n                        indicator_color: p.indicator_color || \"red\",\n                        tick_count: parseInt(p.tick_count || 11, 10),\n                        tick_length: parseInt(p.tick_length || 10, 10),\n                        label_gap: parseInt(p.label_gap || 10, 10),\n                        scale_width: parseInt(p.scale_width || 10, 10),\n                        indicator_width: parseInt(p.indicator_width || 4, 10)\n                    };\n                } else if (widgetType === \"lvgl_obj\") {\n                    widget.props = {\n                        ...widget.props,\n                        color: p.color || \"white\",\n                        border_width: parseInt(p.border_width || 1, 10),\n                        border_color: p.border_color || \"gray\",\n                        radius: parseInt(p.radius || 0, 10)\n                    };\n\n                } else if (widgetType.startsWith(\"lvgl_\")) {\n                    // Generic fallback for other LVGL widgets\n                    // Copy all props from p to widget.props, converting \"true\"/\"false\" strings\n                    // IMPORTANT: Start with existing widget.props to preserve common LVGL props (hidden, grid, etc.)\n                    // AND avoid overwriting them with raw strings from 'p'\n                    Logger.log(\"[YAML_IMPORT] Parsing generic LVGL\", widgetType, p.id, p);\n                    const existingProps = widget.props || {};\n                    widget.props = { ...existingProps };\n\n                    const commonKeys = [\n                        \"hidden\", \"clickable\", \"checkable\", \"scrollable\", \"floating\",\n                        \"ignore_layout\", \"scrollbar_mode\", \"opa\",\n                        \"grid_cell_row_pos\", \"grid_cell_column_pos\",\n                        \"grid_cell_row_span\", \"grid_cell_column_span\",\n                        \"grid_cell_x_align\", \"grid_cell_y_align\"\n                    ];\n\n                    Object.entries(p).forEach(([key, val]) => {\n                        if (key === \"id\" || key === \"type\" || key === \"x\" || key === \"y\" || key === \"w\" || key === \"h\") return;\n                        if (commonKeys.includes(key)) return;\n\n                        if (key === \"title\") {\n                            widget.title = val;\n                            return;\n                        }\n                        if (val === \"true\") widget.props[key] = true;\n                        else if (val === \"false\") widget.props[key] = false;\n                        else if (Array.isArray(val)) {\n                            if (key === \"options\") widget.props[key] = val.join(\"\\n\");\n                            else if (key === \"points\") widget.props[key] = val.map(pt => Array.isArray(pt) ? pt.join(\",\") : String(pt)).join(\" \");\n                            else widget.props[key] = val;\n                        }\n                        else widget.props[key] = val;\n                    });\n                } else if (widgetType === \"calendar\") {\n                    Logger.log(\"[YAML_IMPORT] Parsing calendar\", p.id, p);\n                    widget.props = {\n                        entity_id: p.entity || \"sensor.esp_calendar_data\",\n                        border_width: parseInt(p.border_width || 2, 10),\n                        show_border: (p.show_border !== \"false\"),\n                        border_color: p.border_color || \"black\",\n                        background_color: p.background_color || \"white\",\n                        text_color: p.text_color || \"black\",\n                        font_size_date: parseInt(p.font_size_date || 100, 10),\n                        font_size_day: parseInt(p.font_size_day || 24, 10),\n                        font_size_grid: parseInt(p.font_size_grid || 14, 10),\n                        font_size_event: parseInt(p.font_size_event || 18, 10)\n                    };\n                }\n\n                widgets.push(widget);\n                skipRendering = true;\n                continue;\n            }\n            continue;\n        }\n\n        let m;\n\n        m = trimmed.match(/^it\\.rectangle\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*COLOR_OFF)?\\s*\\)\\s*;?/);\n        if (m) {\n            widgets.push({\n                id: \"w_rect_\" + widgets.length,\n                type: \"shape_rect\",\n                x: parseInt(m[1], 10),\n                y: parseInt(m[2], 10),\n                width: parseInt(m[3], 10),\n                height: parseInt(m[4], 10),\n                title: \"\",\n                entity_id: \"\",\n                props: {\n                    fill: false,\n                    border_width: 1,\n                    color: \"black\",\n                    opacity: 100\n                }\n            });\n            continue;\n        }\n\n        m = trimmed.match(/^it\\.filled_rectangle\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*COLOR_OFF)?\\s*\\)\\s*;?/);\n        if (m) {\n            widgets.push({\n                id: \"w_frect_\" + widgets.length,\n                type: \"shape_rect\",\n                x: parseInt(m[1], 10),\n                y: parseInt(m[2], 10),\n                width: parseInt(m[3], 10),\n                height: parseInt(m[4], 10),\n                title: \"\",\n                entity_id: \"\",\n                props: {\n                    fill: true,\n                    border_width: 1,\n                    color: \"black\",\n                    opacity: 100\n                }\n            });\n            continue;\n        }\n\n        m = trimmed.match(/^it\\.circle\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*COLOR_OFF)?\\s*\\)\\s*;?/);\n        if (m) {\n            const r = parseInt(m[3], 10);\n            widgets.push({\n                id: \"w_circle_\" + widgets.length,\n                type: \"shape_circle\",\n                x: parseInt(m[1], 10) - r,\n                y: parseInt(m[2], 10) - r,\n                width: r * 2,\n                height: r * 2,\n                title: \"\",\n                entity_id: \"\",\n                props: {\n                    fill: false,\n                    border_width: 1,\n                    color: \"black\",\n                    opacity: 100\n                }\n            });\n            continue;\n        }\n\n        m = trimmed.match(/^it\\.filled_circle\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*COLOR_OFF)?\\s*\\)\\s*;?/);\n        if (m) {\n            const r = parseInt(m[3], 10);\n            widgets.push({\n                id: \"w_fcircle_\" + widgets.length,\n                type: \"shape_circle\",\n                x: parseInt(m[1], 10) - r,\n                y: parseInt(m[2], 10) - r,\n                width: r * 2,\n                height: r * 2,\n                title: \"\",\n                entity_id: \"\",\n                props: {\n                    fill: true,\n                    border_width: 1,\n                    color: \"black\",\n                    opacity: 100\n                }\n            });\n            continue;\n        }\n\n        m = trimmed.match(/^it\\.line\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*;?/);\n        if (m) {\n            const x1 = parseInt(m[1], 10);\n            const y1 = parseInt(m[2], 10);\n            const x2 = parseInt(m[3], 10);\n            const y2 = parseInt(m[4], 10);\n            widgets.push({\n                id: \"w_line_\" + widgets.length,\n                type: \"line\",\n                x: x1,\n                y: y1,\n                width: x2 - x1,\n                height: y2 - y1,\n                title: \"\",\n                entity_id: \"\",\n                props: {\n                    stroke_width: 1,\n                    color: \"black\",\n                    orientation: (Math.abs(y2 - y1) > Math.abs(x2 - x1)) ? \"vertical\" : \"horizontal\"\n                }\n            });\n            continue;\n        }\n\n        // --- NATIVE YAML PARSING (FALLBACK) ---\n        // If we didn't find a marker or a drawing command, check for native widget tags like \"- label:\"\n        const nativeRegex = new RegExp(`^(\\\\s*)-?\\\\s*(${WIDGET_TAGS.join('|')}):\\\\s*(.*)$`);\n        const mNative = cmd.match(nativeRegex);\n\n        if (mNative) {\n            const indent = mNative[1].length;\n            const nativeTag = mNative[2];\n            const inlineValue = mNative[3].trim();\n\n            const widgetType = TAG_MAP[nativeTag] || `lvgl_${nativeTag}`;\n\n            // Start collecting properties for this native widget\n            const nativeProps = {};\n            if (inlineValue) {\n                nativeProps._inline = inlineValue.replace(/^[\"']|[\"']$/g, \"\");\n            }\n\n            const res = parseYamlSubBlock(lambdaLines, i + 1, indent + 2);\n            Object.assign(nativeProps, res.value);\n            i = res.nextJ - 1;\n\n            const widgetId = nativeProps.id || `lv_${nativeTag}_${widgets.length}`;\n            const widget = {\n                id: widgetId,\n                type: widgetType,\n                x: parseInt(nativeProps.x || 0, 10),\n                y: parseInt(nativeProps.y || 0, 10),\n                width: parseInt(nativeProps.width || nativeProps.w || 100, 10),\n                height: parseInt(nativeProps.height || nativeProps.h || 30, 10),\n                title: nativeProps.title || nativeProps.name || \"\",\n                entity_id: nativeProps.entity_id || nativeProps.entity || nativeProps.sensor || \"\",\n                props: {}\n            };\n\n            // Common LVGL properties from native YAML\n            widget.props.hidden = (nativeProps.hidden === \"true\");\n            widget.props.clickable = (nativeProps.clickable !== \"false\");\n            widget.props.scrollable = (nativeProps.scrollable !== \"false\");\n            if (nativeProps.bg_color) widget.props.bg_color = nativeProps.bg_color;\n            if (nativeProps.bg_opa) {\n                let opa = nativeProps.bg_opa;\n                if (opa.toString().endsWith(\"%\")) {\n                    opa = Math.round(parseFloat(opa) * 2.55);\n                }\n                widget.props.opa = parseInt(opa, 10);\n            }\n            if (nativeProps.text) widget.props.text = nativeProps.text;\n            else if (nativeProps._inline && nativeTag === \"label\") widget.props.text = nativeProps._inline;\n\n            // Improved property mapping and data type handling\n            Object.entries(nativeProps).forEach(([k, v]) => {\n                if ([\"id\", \"x\", \"y\", \"width\", \"height\", \"w\", \"h\", \"type\", \"bg_color\", \"bg_opa\", \"_inline\", \"widgets\"].includes(k)) return;\n\n                // Handle nested styles (indicator, knob) by flattening or mapping\n                if (k === \"indicator\" || k === \"knob\" || k === \"selected\") {\n                    if (typeof v === 'object' && v !== null && !Array.isArray(v)) {\n                        Object.entries(v).forEach(([sk, sv]) => {\n                            widget.props[`${k}_${sk}`] = sv;\n                        });\n                        return;\n                    }\n                }\n\n                // Normalization: Join arrays for internal properties that expect strings\n                let val = v;\n                if (Array.isArray(v)) {\n                    if (k === \"options\") {\n                        val = v.join(\"\\n\");\n                    } else if (k === \"points\") {\n                        val = v.map(pt => Array.isArray(pt) ? pt.join(\",\") : String(pt)).join(\" \");\n                    }\n                } else if (typeof v === 'string') {\n                    // Strip units from numeric values\n                    if (/^-?\\d+(\\.\\d+)?(ms|deg|px|%)$/.test(v)) {\n                        val = v.replace(/(ms|deg|px|%)$/, \"\");\n                    }\n                }\n\n                if (widget.props[k] === undefined) {\n                    if (val === \"true\") widget.props[k] = true;\n                    else if (val === \"false\") widget.props[k] = false;\n                    else if (!isNaN(val) && val !== \"\" && k !== \"text\" && k !== \"id\" && k !== \"name\" && typeof val !== 'object') {\n                        widget.props[k] = parseFloat(val);\n                    }\n                    else {\n                        // Handle potential escaped Unicode in text\n                        if (typeof val === 'string' && val.includes(\"\\\\u\")) {\n                            try {\n                                widget.props[k] = JSON.parse(`\"${val}\"`);\n                            } catch (e) { widget.props[k] = val; }\n                        } else {\n                            widget.props[k] = val;\n                        }\n                    }\n                }\n            });\n\n            widgets.push(widget);\n\n            // Handle nested widgets (flattening into the page for now)\n            if (Array.isArray(nativeProps.widgets)) {\n                nativeProps.widgets.forEach(nw => {\n                    const tag = Object.keys(nw)[0];\n                    const nwProps = nw[tag];\n                    if (tag && nwProps) {\n                        const nwType = TAG_MAP[tag] || `lvgl_${tag}`;\n                        const nestedWidget = {\n                            id: nwProps.id || `lv_${tag}_${widgets.length}`,\n                            type: nwType,\n                            x: widget.x + parseInt(nwProps.x || 0, 10), // Relative to parent\n                            y: widget.y + parseInt(nwProps.y || 0, 10),\n                            width: parseInt(nwProps.width || nwProps.w || 50, 10),\n                            height: parseInt(nwProps.height || nwProps.h || 20, 10),\n                            props: { ...nwProps }\n                        };\n                        widgets.push(nestedWidget);\n                    }\n                });\n            }\n        }\n    }\n\n    return layout;\n}\n\n/**\n * Loads a parsed layout into the application state.\n * @param {Object} layout - The parsed layout object.\n */\nexport function loadLayoutIntoState(layout) {\n    if (!layout || !Array.isArray(layout.pages)) {\n        Logger.error(\"Invalid layout - missing pages array\");\n        throw new Error(\"invalid_layout\");\n    }\n\n    const pages = layout.pages.map((p, idx) => ({\n        ...p,  // Preserve all properties from imported page\n        id: p.id || `page_${idx}`,\n        name: p.name || `Page ${idx + 1}`,\n        widgets: Array.isArray(p.widgets) ? p.widgets : []\n    }));\n\n    if (!pages.length) {\n        Logger.warn(\"No pages, creating default empty page\");\n        pages.push({\n            id: \"page_0\",\n            name: \"Imported\",\n            widgets: []\n        });\n    }\n\n    // Set current layout ID from the layout data\n    // Only update if the layout has a device_id - don't reset an existing valid ID\n    if (layout.device_id) {\n        const currentId = AppState.currentLayoutId;\n        if (currentId !== layout.device_id) {\n            Logger.log(`[loadLayoutIntoState] Updating currentLayoutId: ${currentId} -> ${layout.device_id}`);\n            AppState.setCurrentLayoutId(layout.device_id);\n        }\n    } else {\n        Logger.log(`[loadLayoutIntoState] No device_id in layout, keeping currentLayoutId: ${AppState.currentLayoutId}`);\n    }\n\n    // Set device name from layout\n    if (layout.name) {\n        AppState.setDeviceName(layout.name);\n    }\n\n    // Set device model from layout (check multiple possible locations)\n    const deviceModel = layout.device_model || layout.settings?.device_model;\n    if (deviceModel) {\n        AppState.setDeviceModel(deviceModel);\n        // window.currentDeviceModel = deviceModel; // Keep global in sync (Deprecated)\n    }\n\n    // Merge imported settings with existing settings\n    // IMPORTANT: Settings might be at the root (flattened by saveLayoutToBackend) \n    // or in a nested .settings object.\n    const currentSettings = AppState.getSettings();\n    const importedSettings = layout.settings || {};\n\n    // Extract root settings that we know about\n    const rootSettings = {};\n    const settingKeys = [\n        \"orientation\", \"dark_mode\", \"sleep_enabled\", \"sleep_start_hour\", \"sleep_end_hour\",\n        \"manual_refresh_only\", \"deep_sleep_enabled\", \"deep_sleep_interval\",\n        \"daily_refresh_enabled\", \"daily_refresh_time\", \"no_refresh_start_hour\", \"no_refresh_end_hour\",\n        \"auto_cycle_enabled\", \"auto_cycle_interval_s\", \"refresh_interval\",\n        \"width\", \"height\", \"shape\", \"inverted_colors\"\n    ];\n\n    settingKeys.forEach(key => {\n        if (layout[key] !== undefined) {\n            rootSettings[key] = layout[key];\n        }\n    });\n\n    const newSettings = { ...currentSettings, ...importedSettings, ...rootSettings };\n\n    // Ensure device_name is in settings too (for Device Settings modal)\n    if (layout.name) {\n        newSettings.device_name = layout.name;\n    }\n\n    // Ensure device_model is in settings too\n    if (deviceModel) {\n        newSettings.device_model = deviceModel;\n    }\n\n    // Ensure defaults for new or missing settings\n    if (newSettings.sleep_enabled === undefined) newSettings.sleep_enabled = false;\n    if (newSettings.sleep_start_hour === undefined) newSettings.sleep_start_hour = 0;\n    if (newSettings.sleep_end_hour === undefined) newSettings.sleep_end_hour = 5;\n    if (newSettings.manual_refresh_only === undefined) newSettings.manual_refresh_only = false;\n    if (newSettings.deep_sleep_enabled === undefined) newSettings.deep_sleep_enabled = false;\n    if (newSettings.deep_sleep_interval === undefined) newSettings.deep_sleep_interval = 600;\n    if (newSettings.daily_refresh_enabled === undefined) newSettings.daily_refresh_enabled = false;\n    if (newSettings.daily_refresh_time === undefined) newSettings.daily_refresh_time = \"08:00\";\n    if (newSettings.refresh_interval === undefined) newSettings.refresh_interval = 600;\n\n    // Update State\n    AppState.setPages(pages);\n    AppState.setSettings(newSettings);\n    // Preserve current page index if valid, otherwise reset to 0\n    const currentIndex = AppState.currentPageIndex;\n    if (currentIndex >= 0 && currentIndex < pages.length) {\n        AppState.setCurrentPageIndex(currentIndex);\n    } else {\n        AppState.setCurrentPageIndex(0);\n    }\n\n    // Note: AppState emits EVENTS.STATE_CHANGED and EVENTS.PAGE_CHANGED,\n    // which should trigger UI updates in Sidebar, Canvas, and PropertiesPanel.\n    // The legacy editor.js has a sync mechanism that listens for these events\n    // to update its own 'pages' array for renderCanvas() compatibility.\n    Logger.log(`[loadLayoutIntoState] Layout loaded with ${pages.length} pages. Current Layout ID: ${AppState.currentLayoutId}`);\n    Logger.log(`[loadLayoutIntoState] Power settings after merge:`, {\n        daily_refresh_enabled: newSettings.daily_refresh_enabled,\n        daily_refresh_time: newSettings.daily_refresh_time,\n        deep_sleep_enabled: newSettings.deep_sleep_enabled,\n        sleep_enabled: newSettings.sleep_enabled\n    });\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\main.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\device_settings.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'loadExternalProfiles' is defined but never used.","line":4,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"loadExternalProfiles"},"fix":{"range":[164,186],"text":""},"desc":"Remove unused variable 'loadExternalProfiles'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":91,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":91,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from '../core/state.js';\nimport { Logger } from '../utils/logger.js';\nimport { emit, EVENTS } from '../core/events.js';\nimport { DEVICE_PROFILES, loadExternalProfiles, SUPPORTED_DEVICE_IDS } from '../io/devices.js';\nimport { hasHaBackend } from '../utils/env.js';\nimport { showToast } from '../utils/dom.js';\nimport { generateCustomHardwareYaml } from '../io/hardware_generator.js';\nimport { uploadHardwareTemplate } from '../io/hardware_import.js';\n\nexport class DeviceSettings {\n    constructor() {\n        Logger.log(\"[DeviceSettings] Constructor called - Instance ID check\");\n        this.modal = document.getElementById('deviceSettingsModal');\n        // ... (rest of constructor is fine, no changes needed for debug)\n        this.closeBtn = document.getElementById('deviceSettingsClose');\n        this.saveBtn = document.getElementById('deviceSettingsSave');\n\n        // Inputs\n        this.nameInput = document.getElementById('deviceName');\n        this.modelInput = document.getElementById('deviceModel');\n        this.orientationInput = document.getElementById('deviceOrientation');\n        this.darkModeInput = document.getElementById('deviceDarkMode');\n        this.extendedLatinGlyphsInput = document.getElementById('deviceExtendedLatinGlyphs');\n        this.invertedColorsInput = document.getElementById('deviceInvertedColors');\n\n        // Power Strategy\n        this.modeStandard = document.getElementById('mode-standard');\n        this.modeSleep = document.getElementById('setting-sleep-enabled');\n        this.modeManual = document.getElementById('setting-manual-refresh');\n        this.modeDeepSleep = document.getElementById('setting-deep-sleep-enabled');\n        this.modeDaily = document.getElementById('setting-daily-refresh-enabled');\n\n        // Sub-settings\n        this.sleepStart = document.getElementById('setting-sleep-start');\n        this.sleepEnd = document.getElementById('setting-sleep-end');\n        this.sleepRow = document.getElementById('sleep-times-row');\n\n        this.dailyRefreshTime = document.getElementById('setting-daily-refresh-time');\n        this.dailyRefreshRow = document.getElementById('daily-refresh-row');\n\n        this.deepSleepInterval = document.getElementById('setting-deep-sleep-interval');\n        this.deepSleepRow = document.getElementById('deep-sleep-interval-row');\n\n        this.refreshIntervalInput = document.getElementById('setting-refresh-interval');\n        this.refreshIntervalRow = document.getElementById('global-refresh-row');\n\n        this.noRefreshStart = document.getElementById('setting-no-refresh-start');\n        this.noRefreshEnd = document.getElementById('setting-no-refresh-end');\n\n        // Auto-Cycle\n        this.autoCycleEnabled = document.getElementById('setting-auto-cycle');\n        this.autoCycleInterval = document.getElementById('setting-auto-cycle-interval');\n        this.autoCycleRow = document.getElementById('field-auto-cycle-interval');\n\n        // Custom Hardware\n        this.customHardwareSection = document.getElementById('customHardwareSection');\n        // Legacy support: the code refers to customFieldsContainer but it's actually customHardwareSection\n        // We'll alias it for compatibility if referenced that way\n        this.customFieldsContainer = this.customHardwareSection;\n\n        this.customChip = document.getElementById('customChip');\n        this.customTech = document.getElementById('customTech');\n        this.customRes = document.getElementById('customRes');\n        this.customShape = document.getElementById('customShape');\n        this.customPsram = document.getElementById('customPsram');\n        this.customDisplayDriver = document.getElementById('customDisplayDriver');\n        this.customTouchTech = document.getElementById('customTouchTech');\n        this.touchPinsGrid = document.getElementById('touchPinsGrid');\n\n        // Inline Profile Name\n        this.customProfileNameInput = document.getElementById('customProfileName');\n    }\n    init() {\n        if (this.closeBtn) {\n            this.closeBtn.addEventListener('click', () => this.close());\n        }\n\n        // Import Hardware Recipe\n        const importBtn = document.getElementById('importHardwareBtn');\n        const fileInput = document.getElementById('hardwareFileInput');\n        if (importBtn && fileInput) {\n            importBtn.addEventListener('click', (e) => {\n                e.preventDefault();\n                fileInput.click();\n            });\n            fileInput.addEventListener('change', async (e) => {\n                if (e.target.files.length > 0) {\n                    const file = e.target.files[0];\n                    try {\n                        await uploadHardwareTemplate(file);\n                    } catch (err) {\n                        // Toast handled in upload function\n                    }\n                    fileInput.value = \"\"; // Clear for next selection\n                }\n            });\n        }\n\n        this.populateDeviceSelect();\n\n        // Save button (hides modal, as auto-save handles the rest)\n        if (this.saveBtn) {\n            this.saveBtn.addEventListener('click', () => this.close());\n        }\n\n        this.setupAutoSaveListeners();\n        this.setupCustomHardwareListeners();\n    }\n\n    setupCustomHardwareListeners() {\n        if (!this.modelInput) return;\n\n        this.modelInput.addEventListener('change', () => {\n            this.updateCustomSectionVisibility();\n        });\n\n        if (this.customTouchTech) {\n            this.customTouchTech.addEventListener('change', () => {\n                if (this.touchPinsGrid) {\n                    this.touchPinsGrid.style.display = this.customTouchTech.value === 'none' ? 'none' : 'grid';\n                }\n            });\n        }\n\n        // Robust Event Delegation with Debounce\n        document.body.addEventListener('click', async (e) => {\n            if (e.target && e.target.id === 'saveCustomProfileBtn') {\n                e.preventDefault();\n                e.stopImmediatePropagation(); // Stop other listeners\n\n                if (this._isSavingProfile) return; // Debounce\n                this._isSavingProfile = true;\n\n                Logger.log(\"[DeviceSettings] saveCustomProfileBtn clicked (Delegate+Debounce)\");\n\n                try {\n                    if (typeof this.handleSaveCustomProfile === 'function') {\n                        await this.handleSaveCustomProfile();\n                    } else {\n                        Logger.error(\"[DeviceSettings] handleSaveCustomProfile missing\");\n                        alert(\"Error: Save function missing on DeviceSettings instance\");\n                    }\n                } catch (err) {\n                    console.error(err);\n                    alert(\"Error saving profile: \" + err.message);\n                } finally {\n                    setTimeout(() => { this._isSavingProfile = false; }, 1000);\n                }\n            }\n        });\n\n        this.setupCustomHardwareAutoSave();\n    }\n\n    setupCustomHardwareAutoSave() {\n        const customInputs = [\n            this.customChip, this.customTech, this.customRes, this.customShape,\n            this.customPsram, this.customDisplayDriver, this.customTouchTech,\n            'pin_cs', 'pin_dc', 'pin_rst', 'pin_busy', 'pin_clk', 'pin_mosi',\n            'pin_backlight', 'pin_sda', 'pin_scl', 'pin_touch_int', 'pin_touch_rst'\n        ];\n\n        const triggerSave = () => {\n            if (this.modelInput.value === 'custom') {\n                const config = this.getCustomHardwareConfig();\n                AppState.setCustomHardware(config);\n            }\n        };\n\n        customInputs.forEach(input => {\n            const el = typeof input === 'string' ? document.getElementById(input) : input;\n            if (!el) return;\n\n            const eventType = (el.type === 'checkbox' || el.tagName === 'SELECT') ? 'change' : 'input';\n            el.addEventListener(eventType, triggerSave);\n        });\n    }\n\n    getCustomHardwareConfig() {\n        const res = (this.customRes.value || \"800x480\").split('x');\n        const getVal = (id) => {\n            const el = document.getElementById(id);\n            return el ? el.value : \"\";\n        };\n\n        return {\n            chip: this.customChip.value,\n            tech: this.customTech.value,\n            resWidth: parseInt(res[0]) || 800,\n            resHeight: parseInt(res[1]) || 480,\n            shape: this.customShape.value,\n            psram: this.customPsram.checked,\n            displayDriver: this.customDisplayDriver.value,\n            touchTech: this.customTouchTech.value,\n            pins: {\n                cs: getVal('pin_cs'),\n                dc: getVal('pin_dc'),\n                rst: getVal('pin_rst'),\n                busy: getVal('pin_busy'),\n                clk: getVal('pin_clk'),\n                mosi: getVal('pin_mosi'),\n                backlight: getVal('pin_backlight'),\n                sda: getVal('pin_sda'),\n                scl: getVal('pin_scl'),\n                touch_int: getVal('pin_touch_int'),\n                touch_rst: getVal('pin_touch_rst')\n            }\n        };\n    }\n\n    updateCustomSectionVisibility() {\n        if (this.customHardwareSection) {\n            this.customHardwareSection.style.display = this.modelInput.value === 'custom' ? 'block' : 'none';\n        }\n    }\n\n    async handleSaveCustomProfile() {\n        Logger.log(\"[DeviceSettings] handleSaveCustomProfile called\");\n\n        try {\n            const name = this.customProfileNameInput ? this.customProfileNameInput.value.trim() : \"\";\n            if (!name) {\n                showToast(\"Please enter a name for your custom profile first.\", \"warning\");\n                if (this.customProfileNameInput) this.customProfileNameInput.focus();\n                return;\n            }\n\n\n            const res = (this.customRes.value || \"800x480\").split('x');\n            const getVal = (id) => {\n                const el = document.getElementById(id);\n                return el ? el.value : \"\";\n            };\n\n            const config = {\n                name: name,\n                chip: this.customChip.value,\n                tech: this.customTech.value,\n                resWidth: parseInt(res[0]) || 800,\n                resHeight: parseInt(res[1]) || 480,\n                shape: this.customShape.value,\n                psram: this.customPsram.checked,\n                displayDriver: this.customDisplayDriver.value,\n                touchTech: this.customTouchTech.value,\n                pins: {\n                    cs: getVal('pin_cs'),\n                    dc: getVal('pin_dc'),\n                    rst: getVal('pin_rst'),\n                    busy: getVal('pin_busy'),\n                    clk: getVal('pin_clk'),\n                    mosi: getVal('pin_mosi'),\n                    backlight: getVal('pin_backlight'),\n                    sda: getVal('pin_sda'),\n                    scl: getVal('pin_scl'),\n                    touch_int: getVal('pin_touch_int'),\n                    touch_rst: getVal('pin_touch_rst')\n                }\n            };\n\n\n            // Generate and upload\n\n            const yaml = generateCustomHardwareYaml(config);\n            const blob = new Blob([yaml], { type: 'text/yaml' });\n            const fileName = `${name.toLowerCase().replace(/\\s+/g, '_')}.yaml`;\n            const file = new File([blob], fileName);\n\n            showToast(\"Generating hardware recipe...\", \"info\");\n\n            // uploadHardwareTemplate will trigger loadExternalProfiles()\n            await uploadHardwareTemplate(file);\n\n            // Polling logic to find and select the new profile\n            let attempts = 0;\n            const findAndSelect = () => {\n                // loadExternalProfiles merges into DEVICE_PROFILES and calls populateDeviceSelect\n                const profiles = Object.values(window.DEVICE_PROFILES || DEVICE_PROFILES || {});\n                const newProfile = profiles.find(p =>\n                    p.name === name ||\n                    p.name === name + \" (Local)\" ||\n                    (p.name && p.name.includes(name))\n                );\n\n                if (newProfile) {\n                    const modelId = Object.keys(window.DEVICE_PROFILES || DEVICE_PROFILES || {}).find(k => (window.DEVICE_PROFILES || DEVICE_PROFILES)[k] === newProfile);\n                    if (modelId) {\n                        this.modelInput.value = modelId;\n                        this.modelInput.dispatchEvent(new Event('change'));\n                        showToast(`Profile \"${name}\" created and loaded!`, \"success\");\n                    }\n                } else if (attempts < 10) {\n                    attempts++;\n                    Logger.log(`[DeviceSettings] New profile not found yet (attempt ${attempts}), retrying...`);\n                    setTimeout(findAndSelect, 500);\n                } else {\n                    Logger.error(\"[DeviceSettings] Failed to find the newly created profile in the list.\");\n                    showToast(\"Profile created, but could not be auto-selected. Please find it in the list.\", \"warning\");\n                }\n            };\n\n            setTimeout(findAndSelect, 1000);\n\n        } catch (err) {\n            Logger.error(\"Failed to save custom profile:\", err);\n            showToast(\"Failed to create profile: \" + err.message, \"error\");\n        }\n    }\n\n    open() {\n        Logger.log(\"DeviceSettings.open() called\");\n        if (!this.modal) {\n            Logger.error(\"DeviceSettings modal element not found!\");\n            return;\n        }\n\n        Logger.log(\"Opening Device Settings modal...\");\n\n        // Populate fields\n        if (this.nameInput) this.nameInput.value = AppState.settings.device_name || \"My E-Ink Display\";\n        if (this.modelInput) this.modelInput.value = AppState.settings.device_model || \"reterminal_e1001\";\n        if (this.orientationInput) this.orientationInput.value = AppState.settings.orientation || \"landscape\";\n        if (this.darkModeInput) this.darkModeInput.checked = !!AppState.settings.dark_mode;\n        if (this.extendedLatinGlyphsInput) this.extendedLatinGlyphsInput.checked = !!AppState.settings.extended_latin_glyphs;\n        if (this.invertedColorsInput) this.invertedColorsInput.checked = !!AppState.settings.inverted_colors;\n\n        // Determine power mode\n        const s = AppState.settings;\n        const isSleep = !!s.sleep_enabled;\n        const isManual = !!s.manual_refresh_only;\n        const isDeepSleep = !!s.deep_sleep_enabled;\n        const isDaily = !!s.daily_refresh_enabled;\n        const isStandard = !isSleep && !isManual && !isDeepSleep && !isDaily;\n\n        if (this.modeStandard) this.modeStandard.checked = isStandard;\n        if (this.modeSleep) this.modeSleep.checked = isSleep;\n        if (this.modeManual) this.modeManual.checked = isManual;\n        if (this.modeDeepSleep) this.modeDeepSleep.checked = isDeepSleep;\n        if (this.modeDaily) this.modeDaily.checked = isDaily;\n\n        // Set time inputs\n        if (this.sleepStart) this.sleepStart.value = s.sleep_start_hour ?? 0;\n        if (this.sleepEnd) this.sleepEnd.value = s.sleep_end_hour ?? 5;\n        if (this.dailyRefreshTime) this.dailyRefreshTime.value = s.daily_refresh_time || \"08:00\";\n        if (this.deepSleepInterval) this.deepSleepInterval.value = s.deep_sleep_interval ?? 600;\n        if (this.refreshIntervalInput) this.refreshIntervalInput.value = s.refresh_interval ?? 600;\n\n        // Silent Hours\n        if (this.noRefreshStart) this.noRefreshStart.value = s.no_refresh_start_hour ?? \"\";\n        if (this.noRefreshEnd) this.noRefreshEnd.value = s.no_refresh_end_hour ?? \"\";\n\n        // Auto-Cycle\n        if (this.autoCycleEnabled) this.autoCycleEnabled.checked = !!s.auto_cycle_enabled;\n        if (this.autoCycleInterval) this.autoCycleInterval.value = s.auto_cycle_interval_s ?? 30;\n\n        // Show/hide sub-settings\n        this.updateVisibility();\n        this.populateCustomFields();\n        this.updateCustomSectionVisibility();\n\n        this.modal.classList.remove('hidden');\n        this.modal.style.display = 'flex';\n        Logger.log(\"Device Settings modal should be visible now.\");\n    }\n\n    close() {\n        if (this.modal) {\n            this.modal.classList.add('hidden');\n            this.modal.style.display = 'none';\n        }\n    }\n\n    populateCustomFields() {\n        const ch = (AppState.project && AppState.project.state && AppState.project.state.customHardware) || {};\n        if (!ch || Object.keys(ch).length === 0) return;\n\n        if (this.customChip) this.customChip.value = ch.chip || \"esp32-s3\";\n        if (this.customTech) this.customTech.value = ch.tech || \"lcd\";\n        if (this.customRes) this.customRes.value = `${ch.resWidth || 800}x${ch.resHeight || 480}`;\n        if (this.customShape) this.customShape.value = ch.shape || \"rect\";\n        if (this.customPsram) this.customPsram.checked = !!ch.psram;\n        if (this.customDisplayDriver) this.customDisplayDriver.value = ch.displayDriver || \"generic_st7789\";\n        if (this.customTouchTech) {\n            this.customTouchTech.value = ch.touchTech || \"none\";\n            if (this.touchPinsGrid) {\n                this.touchPinsGrid.style.display = (ch.touchTech && ch.touchTech !== 'none') ? 'grid' : 'none';\n            }\n        }\n\n        const pins = ch.pins || {};\n        const setPin = (id, val) => {\n            const el = document.getElementById(id);\n            if (el) el.value = val || \"\";\n        };\n\n        setPin('pin_cs', pins.cs);\n        setPin('pin_dc', pins.dc);\n        setPin('pin_rst', pins.rst);\n        setPin('pin_busy', pins.busy);\n        setPin('pin_clk', pins.clk);\n        setPin('pin_mosi', pins.mosi);\n        setPin('pin_backlight', pins.backlight);\n        setPin('pin_sda', pins.sda);\n        setPin('pin_scl', pins.scl);\n        setPin('pin_touch_int', pins.touch_int);\n        setPin('pin_touch_rst', pins.touch_rst);\n    }\n\n    populateDeviceSelect() {\n        if (this.modelInput && DEVICE_PROFILES) {\n            // Wait for backend to load? DEVICE_PROFILES is now static + dynamic\n            // But we should verify it has content.\n            // Logger.log(\"[DeviceSettings] Populating dropdown\");\n\n            const currentVal = this.modelInput.value;\n            Logger.log(\"[DeviceSettings] Populating dropdown with\", Object.keys(DEVICE_PROFILES).length, \"profiles\");\n\n            this.modelInput.innerHTML = \"\"; // Clear existing\n\n            // Add standard profiles\n            const supportedIds = SUPPORTED_DEVICE_IDS || [];\n            Object.entries(DEVICE_PROFILES).forEach(([key, profile]) => {\n                Logger.log(`  - Adding: ${key} (${profile.name})`);\n                const opt = document.createElement(\"option\");\n                opt.value = key;\n\n                let displayName = profile.name;\n                if (!supportedIds.includes(key)) {\n                    displayName += \" (untested)\";\n                }\n                opt.textContent = displayName;\n\n                this.modelInput.appendChild(opt);\n            });\n\n            // Add Custom Profile option at the end\n            const customOpt = document.createElement(\"option\");\n            customOpt.value = \"custom\";\n            customOpt.textContent = \"Custom Profile...\";\n            customOpt.style.fontWeight = \"bold\";\n            customOpt.style.color = \"var(--accent)\";\n            this.modelInput.appendChild(customOpt);\n\n            // Restore selection or default\n            if (currentVal && (DEVICE_PROFILES[currentVal] || currentVal === 'custom')) {\n                this.modelInput.value = currentVal;\n            } else if (!this.modelInput.value) {\n                this.modelInput.value = \"reterminal_e1001\";\n            }\n\n            // Update visibility of custom fields based on current selection\n            this.updateCustomSectionVisibility();\n        }\n    }\n\n    updateVisibility() {\n        const isSleep = this.modeSleep && this.modeSleep.checked;\n        const isDaily = this.modeDaily && this.modeDaily.checked;\n        const isDeepSleep = this.modeDeepSleep && this.modeDeepSleep.checked;\n        const isManual = this.modeManual && this.modeManual.checked;\n\n        if (this.sleepRow) this.sleepRow.style.display = isSleep ? 'flex' : 'none';\n        if (this.dailyRefreshRow) this.dailyRefreshRow.style.display = isDaily ? 'flex' : 'none';\n        if (this.deepSleepRow) this.deepSleepRow.style.display = isDeepSleep ? 'block' : 'none';\n\n        const needsRefreshInterval = !isDaily && !isManual;\n        if (this.refreshIntervalRow) this.refreshIntervalRow.style.display = needsRefreshInterval ? 'block' : 'none';\n\n        if (this.autoCycleRow) {\n            this.autoCycleRow.style.display = (this.autoCycleEnabled && this.autoCycleEnabled.checked) ? 'flex' : 'none';\n        }\n    }\n\n    persistToBackend() {\n        if (this.saveDebounceTimer) clearTimeout(this.saveDebounceTimer);\n        this.saveDebounceTimer = setTimeout(async () => {\n            if (hasHaBackend() && typeof saveLayoutToBackend === \"function\") {\n                try {\n                    await saveLayoutToBackend();\n                    Logger.log(\"[DeviceSettings] All settings persisted to backend\");\n                } catch (err) {\n                    Logger.warn(\"[DeviceSettings] Failed to auto-save settings:\", err);\n                }\n            } else {\n                // Offline fallback: Save to localStorage\n                try {\n                    const payload = AppState.getPagesPayload();\n                    payload.deviceName = AppState.deviceName;\n                    payload.deviceModel = AppState.deviceModel;\n                    localStorage.setItem(\"esphome-designer-layout\", JSON.stringify(payload));\n                    Logger.log(\"[DeviceSettings] Settings persisted to localStorage (offline mode)\");\n                } catch (err) {\n                    Logger.warn(\"[DeviceSettings] Failed to save to localStorage:\", err);\n                }\n            }\n        }, 1000); // 1s debounce to allow multiple quick changes\n    }\n\n    setupAutoSaveListeners() {\n        const updateSetting = (key, value) => {\n            AppState.settings[key] = value;\n            Logger.log(`Auto - saved ${key}: `, value);\n            emit(EVENTS.STATE_CHANGED); // Trigger snippet update\n            this.persistToBackend();\n        };\n\n        // Device Name - debounced save to backend\n        let nameDebounceTimer = null;\n        if (this.nameInput) {\n            this.nameInput.addEventListener('input', () => {\n                const newName = this.nameInput.value.trim();\n                AppState.setDeviceName(newName);\n                emit(EVENTS.STATE_CHANGED);\n\n                // Debounced save to backend (500ms after last keystroke)\n                if (nameDebounceTimer) clearTimeout(nameDebounceTimer);\n                nameDebounceTimer = setTimeout(async () => {\n                    if (typeof saveLayoutToBackend === \"function\") {\n                        try {\n                            await saveLayoutToBackend();\n                            Logger.log(\"[DeviceSettings] Device name saved to backend\");\n                        } catch (err) {\n                            Logger.warn(\"[DeviceSettings] Failed to save device name:\", err);\n                        }\n                    }\n                }, 500);\n            });\n        }\n\n        // Device Model\n        if (this.modelInput) {\n            this.modelInput.addEventListener('change', async () => {\n                const newModel = this.modelInput.value;\n                window.currentDeviceModel = newModel;\n                AppState.setDeviceModel(newModel); // Update top-level deviceModel\n                updateSetting('device_model', newModel); // Also persist to settings\n                Logger.log(\"Device model changed to:\", newModel);\n            });\n        }\n\n        // Orientation\n        if (this.orientationInput) {\n            this.orientationInput.addEventListener('change', () => {\n                updateSetting('orientation', this.orientationInput.value);\n            });\n        }\n\n        // Dark Mode\n        if (this.darkModeInput) {\n            this.darkModeInput.addEventListener('change', () => {\n                updateSetting('dark_mode', this.darkModeInput.checked);\n            });\n        }\n\n        // Extended Latin Glyphs (diacritics)\n        if (this.extendedLatinGlyphsInput) {\n            this.extendedLatinGlyphsInput.addEventListener('change', () => {\n                updateSetting('extended_latin_glyphs', this.extendedLatinGlyphsInput.checked);\n            });\n        }\n\n        // Inverted Colors (for e-paper displays with swapped black/white)\n        if (this.invertedColorsInput) {\n            this.invertedColorsInput.addEventListener('change', () => {\n                updateSetting('inverted_colors', this.invertedColorsInput.checked);\n            });\n        }\n\n        // Power Strategy\n        const radios = [this.modeStandard, this.modeSleep, this.modeManual, this.modeDeepSleep, this.modeDaily];\n        radios.forEach(radio => {\n            if (radio) {\n                radio.addEventListener('change', () => {\n                    if (!radio.checked) return;\n\n                    updateSetting('sleep_enabled', !!(this.modeSleep && this.modeSleep.checked));\n                    updateSetting('manual_refresh_only', !!(this.modeManual && this.modeManual.checked));\n                    updateSetting('deep_sleep_enabled', !!(this.modeDeepSleep && this.modeDeepSleep.checked));\n                    updateSetting('daily_refresh_enabled', !!(this.modeDaily && this.modeDaily.checked));\n\n                    this.updateVisibility();\n                });\n            }\n        });\n\n        // Sleep Times\n        if (this.sleepStart) {\n            this.sleepStart.addEventListener('change', () => {\n                updateSetting('sleep_start_hour', parseInt(this.sleepStart.value) || 0);\n            });\n        }\n        if (this.sleepEnd) {\n            this.sleepEnd.addEventListener('change', () => {\n                updateSetting('sleep_end_hour', parseInt(this.sleepEnd.value) || 0);\n            });\n        }\n\n        // Daily Refresh Time\n        if (this.dailyRefreshTime) {\n            this.dailyRefreshTime.addEventListener('change', () => {\n                updateSetting('daily_refresh_time', this.dailyRefreshTime.value);\n            });\n        }\n\n        // Deep Sleep Interval\n        if (this.deepSleepInterval) {\n            this.deepSleepInterval.addEventListener('input', () => {\n                const val = parseInt(this.deepSleepInterval.value) || 600;\n                updateSetting('deep_sleep_interval', val);\n                // Sync with global refresh interval if that exists\n                if (this.refreshIntervalInput) {\n                    this.refreshIntervalInput.value = val;\n                    AppState.settings.refresh_interval = val;\n                }\n            });\n        }\n\n        // Global Refresh Interval\n        if (this.refreshIntervalInput) {\n            this.refreshIntervalInput.addEventListener('input', () => {\n                const val = parseInt(this.refreshIntervalInput.value) || 600;\n                updateSetting('refresh_interval', val);\n                // Sync with deep sleep interval for consistency\n                if (this.deepSleepInterval && (this.modeDeepSleep && this.modeDeepSleep.checked)) {\n                    this.deepSleepInterval.value = val;\n                    AppState.settings.deep_sleep_interval = val;\n                }\n            });\n        }\n\n        // Silent Hours\n        if (this.noRefreshStart) {\n            this.noRefreshStart.addEventListener('change', () => {\n                const val = this.noRefreshStart.value === \"\" ? null : parseInt(this.noRefreshStart.value);\n                updateSetting('no_refresh_start_hour', val);\n            });\n        }\n        if (this.noRefreshEnd) {\n            this.noRefreshEnd.addEventListener('change', () => {\n                const val = this.noRefreshEnd.value === \"\" ? null : parseInt(this.noRefreshEnd.value);\n                updateSetting('no_refresh_end_hour', val);\n            });\n        }\n\n        // Auto-Cycle\n        if (this.autoCycleEnabled) {\n            this.autoCycleEnabled.addEventListener('change', () => {\n                updateSetting('auto_cycle_enabled', this.autoCycleEnabled.checked);\n                this.updateVisibility();\n            });\n        }\n        if (this.autoCycleInterval) {\n            this.autoCycleInterval.addEventListener('input', () => {\n                const val = Math.max(5, parseInt(this.autoCycleInterval.value) || 30);\n                updateSetting('auto_cycle_interval_s', val);\n            });\n        }\n    }\n\n    // Modal Logic\n    openSaveProfileModal() {\n        return new Promise((resolve) => {\n            if (!this.saveProfileModal) {\n                Logger.error(\"Save Profile Modal not found in DOM\");\n                resolve(null);\n                return;\n            }\n\n            this.saveProfileResolve = resolve;\n            this.saveProfileNameInput.value = \"My Custom Device\"; // Default\n            this.saveProfileModal.classList.remove('hidden');\n            this.saveProfileModal.style.display = 'flex';\n            this.saveProfileNameInput.focus();\n            this.saveProfileNameInput.select();\n\n            // One-time listeners for this specific open instance\n            const close = () => {\n                this.saveProfileModal.classList.add('hidden');\n                this.saveProfileModal.style.display = 'none';\n                if (this.saveProfileResolve) {\n                    this.saveProfileResolve(null);\n                    this.saveProfileResolve = null;\n                }\n                cleanup();\n            };\n\n            const confirm = () => {\n                const name = this.saveProfileNameInput.value.trim();\n                if (!name) {\n                    showToast(\"Please enter a profile name\", \"warning\");\n                    this.saveProfileNameInput.focus();\n                    return;\n                }\n\n                this.saveProfileModal.classList.add('hidden');\n                this.saveProfileModal.style.display = 'none';\n                if (this.saveProfileResolve) {\n                    this.saveProfileResolve(name);\n                    this.saveProfileResolve = null;\n                }\n                cleanup();\n            };\n\n            const onKeyup = (e) => {\n                if (e.key === 'Enter') confirm();\n                if (e.key === 'Escape') close();\n            };\n\n            const cleanup = () => {\n                this.saveProfileCloseBtn.removeEventListener('click', close);\n                this.saveProfileConfirmBtn.removeEventListener('click', confirm);\n                this.saveProfileNameInput.removeEventListener('keyup', onKeyup);\n            };\n\n            this.saveProfileCloseBtn.addEventListener('click', close);\n            this.saveProfileConfirmBtn.addEventListener('click', confirm);\n            this.saveProfileNameInput.addEventListener('keyup', onKeyup);\n        });\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\editor_settings.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":219,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":219,"endColumn":27},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":285,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":285,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from '../core/state.js';\nimport { emit, EVENTS } from '../core/events.js';\nimport { setHaManualUrl, refreshHaBaseUrl, setHaToken, getHaManualUrl, getHaToken } from '../utils/env.js';\nimport { showToast } from '../utils/dom.js';\nimport { fetchEntityStates } from '../io/ha_api.js';\nimport { Logger } from '../utils/logger.js';\n\nexport class EditorSettings {\n    constructor() {\n        this.modal = document.getElementById('editorSettingsModal');\n        this.closeBtn = document.getElementById('editorSettingsClose');\n        this.doneBtn = document.getElementById('editorSettingsDone');\n\n        // Inputs\n        this.snapToGrid = document.getElementById('editorSnapToGrid');\n        this.showGrid = document.getElementById('editorShowGrid');\n        this.lightMode = document.getElementById('editorLightMode');\n        this.refreshEntitiesBtn = document.getElementById('editorRefreshEntities');\n        this.entityCountLabel = document.getElementById('editorEntityCount');\n        this.gridOpacity = document.getElementById('editorGridOpacity');\n\n        // HA Connection\n        this.haManualUrl = document.getElementById('haManualUrl');\n        this.haLlatToken = document.getElementById('haLlatToken');\n        this.testHaBtn = document.getElementById('editorTestHaBtn');\n        this.haTestResult = document.getElementById('haTestResult');\n\n        // AI Settings\n        this.aiProvider = document.getElementById('aiProvider');\n        this.aiApiKeyGemini = document.getElementById('aiApiKeyGemini');\n        this.aiApiKeyOpenai = document.getElementById('aiApiKeyOpenai');\n        this.aiApiKeyOpenrouter = document.getElementById('aiApiKeyOpenrouter');\n        this.aiModelFilter = document.getElementById('aiModelFilter');\n        this.aiModelSelect = document.getElementById('aiModelSelect');\n        this.aiRefreshModelsBtn = document.getElementById('aiRefreshModelsBtn');\n        this.aiTestResult = document.getElementById('aiTestResult');\n\n        this.aiKeyRows = {\n            gemini: document.getElementById('aiKeyGeminiRow'),\n            openai: document.getElementById('aiKeyOpenaiRow'),\n            openrouter: document.getElementById('aiKeyOpenrouterRow')\n        };\n    }\n\n    init() {\n        if (!this.modal) return;\n\n        // Close/Done buttons\n        if (this.closeBtn) this.closeBtn.addEventListener('click', () => this.close());\n        if (this.doneBtn) this.doneBtn.addEventListener('click', () => this.close());\n\n        this.setupListeners();\n    }\n\n    open() {\n        if (!this.modal) return;\n\n        const settings = AppState.settings;\n\n        // Snap to Grid\n        if (this.snapToGrid) {\n            // snapEnabled is at AppState root\n            this.snapToGrid.checked = AppState.snapEnabled !== false;\n        }\n\n        // Show Grid\n        if (this.showGrid) {\n            // showGrid is at AppState root\n            this.showGrid.checked = AppState.showGrid !== false;\n        }\n\n        // Light Mode\n        if (this.lightMode) {\n            this.lightMode.checked = !!settings.editor_light_mode;\n        }\n\n        // AI Settings\n        if (this.aiProvider) this.aiProvider.value = settings.ai_provider || \"gemini\";\n        if (this.aiApiKeyGemini) this.aiApiKeyGemini.value = settings.ai_api_key_gemini || \"\";\n        if (this.aiApiKeyOpenai) this.aiApiKeyOpenai.value = settings.ai_api_key_openai || \"\";\n        if (this.aiApiKeyOpenrouter) this.aiApiKeyOpenrouter.value = settings.ai_api_key_openrouter || \"\";\n        if (this.aiModelFilter) this.aiModelFilter.value = settings.ai_model_filter || \"\";\n\n        this.updateAIKeyVisibility();\n        this.refreshModelSelect();\n\n        // Grid Opacity\n        if (this.gridOpacity) {\n            this.gridOpacity.value = settings.grid_opacity !== undefined ? settings.grid_opacity : 20;\n        }\n\n        // HA Connection\n        if (this.haManualUrl) this.haManualUrl.value = getHaManualUrl() || \"\";\n        if (this.haLlatToken) this.haLlatToken.value = getHaToken() || \"\";\n        if (this.haTestResult) this.haTestResult.textContent = \"\";\n        if (this.aiTestResult) this.aiTestResult.textContent = \"\";\n\n\n        // Dynamically show current origin for CORS tip\n        const originPlaceholder = document.getElementById('haOriginPlaceholder');\n        if (originPlaceholder) {\n            originPlaceholder.textContent = window.location.origin;\n        }\n\n        // Entity Count\n        this.updateEntityCount();\n\n        this.modal.classList.remove('hidden');\n        this.modal.style.display = 'flex';\n        Logger.log(\"Editor Settings opened\");\n    }\n\n    close() {\n        if (this.modal) {\n            this.modal.classList.add('hidden');\n            this.modal.style.display = 'none';\n        }\n    }\n\n    updateEntityCount() {\n        if (this.entityCountLabel && window.entityStatesCache) {\n            const count = Object.keys(window.entityStatesCache).length;\n            this.entityCountLabel.textContent = `${count} entities cached`;\n        }\n    }\n\n    setupListeners() {\n        // Snap to Grid\n        if (this.snapToGrid) {\n            this.snapToGrid.addEventListener('change', () => {\n                AppState.setSnapEnabled(this.snapToGrid.checked);\n            });\n        }\n\n        // Show Grid\n        if (this.showGrid) {\n            this.showGrid.addEventListener('change', () => {\n                AppState.setShowGrid(this.showGrid.checked);\n                // Also toggle DOM immediately for responsiveness\n                const gridEl = document.querySelector('.canvas-grid');\n                if (gridEl) {\n                    gridEl.style.display = this.showGrid.checked ? 'block' : 'none';\n                }\n            });\n        }\n\n        // Light Mode\n        if (this.lightMode) {\n            this.lightMode.addEventListener('change', () => {\n                const isLight = this.lightMode.checked;\n                AppState.updateSettings({ editor_light_mode: isLight });\n                this.applyEditorTheme(isLight);\n                emit(EVENTS.STATE_CHANGED);\n            });\n        }\n\n        // Grid Opacity\n        if (this.gridOpacity) {\n            this.gridOpacity.addEventListener('input', () => {\n                const val = parseInt(this.gridOpacity.value, 10);\n                AppState.updateSettings({ grid_opacity: val });\n            });\n        }\n\n\n        // Refresh Entities\n        if (this.refreshEntitiesBtn) {\n            this.refreshEntitiesBtn.addEventListener('click', async () => {\n                this.refreshEntitiesBtn.disabled = true;\n                this.refreshEntitiesBtn.textContent = \"Refreshing...\";\n\n                // Use imported fetchEntityStates, fallback to window not needed if import works\n                if (fetchEntityStates) {\n                    await fetchEntityStates();\n                } else if (window.fetchEntityStates) {\n                    await window.fetchEntityStates();\n                }\n\n                this.updateEntityCount();\n                this.refreshEntitiesBtn.disabled = false;\n                this.refreshEntitiesBtn.textContent = \"Ôå╗ Refresh Entity List\";\n            });\n        }\n\n        // HA Connection Changes\n        if (this.haManualUrl) {\n            this.haManualUrl.addEventListener('change', () => {\n                setHaManualUrl(this.haManualUrl.value.trim());\n                refreshHaBaseUrl();\n            });\n        }\n\n        if (this.haLlatToken) {\n            this.haLlatToken.addEventListener('change', () => {\n                setHaToken(this.haLlatToken.value.trim());\n            });\n        }\n\n        if (this.testHaBtn) {\n            this.testHaBtn.addEventListener('click', async () => {\n                this.testHaBtn.disabled = true;\n                this.haTestResult.textContent = \"Testing...\";\n                this.haTestResult.style.color = \"var(--muted)\";\n\n                try {\n                    // Force refresh base URL in case it was just changed\n                    refreshHaBaseUrl();\n                    // Use imported fetchEntityStates\n                    const entities = await fetchEntityStates();\n                    if (entities && entities.length > 0) {\n                        this.haTestResult.textContent = \"Ô£à Success!\";\n                        this.haTestResult.style.color = \"var(--success)\";\n                        this.updateEntityCount();\n                    } else {\n                        // Detailed failure help\n                        this.haTestResult.innerHTML = \"ÔØî Failed.<br>Did you add <strong>cors_allowed_origins</strong> to HA and <strong>restart</strong> it?\";\n                        this.haTestResult.style.color = \"var(--danger)\";\n                    }\n                } catch (e) {\n                    this.haTestResult.innerHTML = \"ÔØî Connection Error.<br>Check browser console.\";\n                    this.haTestResult.style.color = \"var(--danger)\";\n                } finally {\n                    this.testHaBtn.disabled = false;\n                }\n            });\n        }\n\n        // AI Listeners\n        if (this.aiProvider) {\n            this.aiProvider.addEventListener('change', () => {\n                AppState.updateSettings({ ai_provider: this.aiProvider.value });\n                this.updateAIKeyVisibility();\n                this.refreshModelSelect();\n            });\n        }\n\n        const bindAIKey = (id, key) => {\n            const el = document.getElementById(id);\n            if (el) el.addEventListener('change', () => AppState.updateSettings({ [key]: el.value.trim() }));\n        };\n        bindAIKey('aiApiKeyGemini', 'ai_api_key_gemini');\n        bindAIKey('aiApiKeyOpenai', 'ai_api_key_openai');\n        bindAIKey('aiApiKeyOpenrouter', 'ai_api_key_openrouter');\n\n        if (this.aiModelFilter) {\n            this.aiModelFilter.addEventListener('input', () => {\n                AppState.updateSettings({ ai_model_filter: this.aiModelFilter.value });\n                this.filterModels();\n            });\n        }\n\n        if (this.aiModelSelect) {\n            this.aiModelSelect.addEventListener('change', () => {\n                const provider = AppState.settings.ai_provider;\n                AppState.updateSettings({ [`ai_model_${provider}`]: this.aiModelSelect.value });\n            });\n        }\n\n        if (this.aiRefreshModelsBtn) {\n            this.aiRefreshModelsBtn.addEventListener('click', async () => {\n                const provider = AppState.settings.ai_provider;\n                const apiKey = AppState.settings[`ai_api_key_${provider}`];\n                if (!apiKey) {\n                    showToast(\"Please enter an API key first\", 3000, \"error\");\n                    return;\n                }\n\n                this.aiRefreshModelsBtn.disabled = true;\n                this.aiRefreshModelsBtn.textContent = \"...\";\n                if (this.aiTestResult) {\n                    this.aiTestResult.textContent = \"Testing...\";\n                    this.aiTestResult.style.color = \"var(--muted)\";\n                }\n\n                try {\n                    // Assuming aiService is still attached to window for now until refactored\n                    const models = await window.aiService.fetchModels(provider, apiKey);\n                    window.aiService.cache.models[provider] = models;\n                    this.refreshModelSelect();\n                    // showToast(`Fetched ${models.length} models`, \"success\");\n                    if (this.aiTestResult) {\n                        this.aiTestResult.textContent = `Ô£à Success! Found ${models.length} models.`;\n                        this.aiTestResult.style.color = \"var(--success)\";\n                    }\n                } catch (e) {\n                    // showToast(\"Failed to fetch models\", \"error\");\n                    if (this.aiTestResult) {\n                        this.aiTestResult.textContent = \"ÔØî Failed. Check key/console.\";\n                        this.aiTestResult.style.color = \"var(--danger)\";\n                    }\n                } finally {\n                    this.aiRefreshModelsBtn.disabled = false;\n                    this.aiRefreshModelsBtn.textContent = \"Test & Load Models\";\n                }\n            });\n        }\n    }\n\n    updateAIKeyVisibility() {\n        const provider = AppState.settings.ai_provider || \"gemini\";\n        Object.keys(this.aiKeyRows).forEach(p => {\n            if (this.aiKeyRows[p]) {\n                this.aiKeyRows[p].style.display = (p === provider) ? \"block\" : \"none\";\n            }\n        });\n    }\n\n    async refreshModelSelect() {\n        if (!this.aiModelSelect) return;\n        const provider = AppState.settings.ai_provider || \"gemini\";\n\n        // Assuming aiService global\n        if (!window.aiService || !window.aiService.cache) return;\n\n        let models = window.aiService.cache.models[provider];\n        if (!models) {\n            // No models in cache, but we don't hardcode them anymore.\n            // User must click \"Test & Load Models\" to populate.\n            models = [];\n            window.aiService.cache.models[provider] = models;\n        }\n\n        this.filterModels();\n    }\n\n    filterModels() {\n        if (!this.aiModelSelect) return;\n        const provider = AppState.settings.ai_provider || \"gemini\";\n        const filterStr = (AppState.settings.ai_model_filter || \"\").toLowerCase();\n\n        if (!window.aiService || !window.aiService.cache) return;\n        const models = window.aiService.cache.models[provider] || [];\n\n        const filtered = models.filter(m =>\n            m.name.toLowerCase().includes(filterStr) ||\n            m.id.toLowerCase().includes(filterStr)\n        );\n\n        this.aiModelSelect.innerHTML = \"\";\n        filtered.forEach(m => {\n            const opt = document.createElement('option');\n            opt.value = m.id;\n            opt.textContent = m.name;\n            this.aiModelSelect.appendChild(opt);\n        });\n\n        const currentModel = AppState.settings[`ai_model_${provider}`];\n        if (currentModel) {\n            this.aiModelSelect.value = currentModel;\n        }\n    }\n\n    applyEditorTheme(isLightMode) {\n        if (isLightMode) {\n            document.documentElement.setAttribute('data-theme', 'light');\n        } else {\n            document.documentElement.removeAttribute('data-theme');\n        }\n        // Save preference to localStorage for persistence\n        try {\n            localStorage.setItem('reterminal-editor-theme', isLightMode ? 'light' : 'dark');\n        } catch (e) {\n            Logger.log('Could not save theme preference:', e);\n        }\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\entity_picker.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\hierarchy_view.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\icon_picker.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\layout_manager.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'model' is assigned a value but never used.","line":419,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":419,"endColumn":20,"suggestions":[{"messageId":"removeVar","data":{"varName":"model"},"fix":{"range":[19377,19497],"text":""},"desc":"Remove unused variable 'model'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Layout Manager UI\n * Handles listing, creating, switching, deleting, importing, and exporting layouts\n * Uses Home Assistant backend API for persistent storage across devices\n */\n\nimport { Logger } from '../utils/logger.js';\n\nclass LayoutManager {\n    constructor() {\n        this.modal = null;\n        this.currentLayoutId = \"reterminal_e1001\"; // Default\n        this.layouts = [];\n    }\n\n    init() {\n        this.createModal();\n        this.bindButton();\n        Logger.log(\"[LayoutManager] Initialized\");\n    }\n\n    bindButton() {\n        const btn = document.getElementById(\"manageLayoutsBtn\");\n        if (btn) {\n            btn.addEventListener(\"click\", () => this.open());\n        }\n    }\n\n    createModal() {\n        // Check if modal already exists\n        if (document.getElementById(\"layoutManagerModal\")) {\n            this.modal = document.getElementById(\"layoutManagerModal\");\n            return;\n        }\n\n        const modal = document.createElement(\"div\");\n        modal.id = \"layoutManagerModal\";\n        modal.className = \"modal-backdrop hidden\";\n        modal.innerHTML = `\n            <div class=\"modal\" style=\"max-width: 600px;\">\n                <div class=\"modal-header\">\n                    <div>­ƒôü Manage Layouts</div>\n                    <button id=\"layoutManagerClose\" class=\"btn btn-secondary\">├ù</button>\n                </div>\n                <div class=\"modal-body\">\n                    <div class=\"layout-manager-current\" style=\"margin-bottom: 12px; padding: 8px; background: var(--bg-subtle); border-radius: 4px;\">\n                        <span class=\"prop-label\" style=\"font-size: 11px; color: var(--muted);\">Current Layout:</span>\n                        <span id=\"layoutManagerCurrentName\" style=\"font-weight: 500; margin-left: 8px;\">Loading...</span>\n                    </div>\n                    \n                    <div class=\"layout-manager-list-container\" style=\"max-height: 300px; overflow-y: auto; margin-bottom: 12px;\">\n                        <table class=\"layout-manager-table\" style=\"width: 100%; border-collapse: collapse;\">\n                            <thead>\n                                <tr style=\"border-bottom: 1px solid var(--border);\">\n                                    <th style=\"text-align: left; padding: 8px 4px; font-size: 11px;\">Name</th>\n                                    <th style=\"text-align: left; padding: 8px 4px; font-size: 11px;\">Device</th>\n                                    <th style=\"text-align: left; padding: 8px 4px; font-size: 11px;\">Pages</th>\n                                    <th style=\"text-align: right; padding: 8px 4px; font-size: 11px;\">Actions</th>\n                                </tr>\n                            </thead>\n                            <tbody id=\"layoutManagerTableBody\">\n                                <tr><td colspan=\"4\" style=\"text-align: center; color: var(--muted); padding: 16px;\">Loading...</td></tr>\n                            </tbody>\n                        </table>\n                    </div>\n                    \n                    <div class=\"layout-manager-actions\" style=\"display: flex; gap: 8px; flex-wrap: wrap;\">\n                        <button id=\"layoutManagerNew\" class=\"btn btn-primary\" style=\"flex: 1;\">+ New Layout</button>\n                        <button id=\"layoutManagerImport\" class=\"btn btn-secondary\" style=\"flex: 1;\">­ƒôÑ Import from File</button>\n                        <input type=\"file\" id=\"layoutManagerFileInput\" accept=\".json\" style=\"display: none;\">\n                    </div>\n                    \n                    <div id=\"layoutManagerStatus\" class=\"layout-manager-status\" style=\"margin-top: 8px; font-size: 11px; min-height: 20px;\"></div>\n                </div>\n            </div>\n        `;\n\n        document.body.appendChild(modal);\n        this.modal = modal;\n\n        // Bind modal events\n        document.getElementById(\"layoutManagerClose\").addEventListener(\"click\", () => this.close());\n        document.getElementById(\"layoutManagerNew\").addEventListener(\"click\", () => this.showNewLayoutDialog());\n        document.getElementById(\"layoutManagerImport\").addEventListener(\"click\", () => {\n            document.getElementById(\"layoutManagerFileInput\").click();\n        });\n        document.getElementById(\"layoutManagerFileInput\").addEventListener(\"change\", (e) => this.handleFileImport(e));\n\n        // Close on backdrop click\n        modal.addEventListener(\"click\", (e) => {\n            if (e.target === modal) this.close();\n        });\n    }\n\n    async open() {\n        if (!this.modal) this.createModal();\n        this.modal.classList.remove(\"hidden\");\n        await this.loadLayouts();\n    }\n\n    close() {\n        if (this.modal) {\n            this.modal.classList.add(\"hidden\");\n        }\n    }\n\n    setStatus(message, type = \"info\") {\n        const status = document.getElementById(\"layoutManagerStatus\");\n        if (status) {\n            const colors = {\n                success: \"var(--success, #22c55e)\",\n                error: \"var(--danger, #ef4444)\",\n                info: \"var(--muted, #888)\"\n            };\n            status.textContent = message;\n            status.style.color = colors[type] || colors.info;\n            if (message) {\n                setTimeout(() => {\n                    status.textContent = \"\";\n                }, 5000);\n            }\n        }\n    }\n\n    async loadLayouts() {\n        if (typeof hasHaBackend !== \"function\" || !hasHaBackend()) {\n            this.setStatus(\"Not connected to Home Assistant\", \"error\");\n            return;\n        }\n\n        try {\n            const resp = await fetch(`${HA_API_BASE}/layouts`, {\n                headers: getHaHeaders()\n            });\n            if (!resp.ok) throw new Error(`Failed to load layouts: ${resp.status}`);\n\n            const data = await resp.json();\n            this.layouts = data.layouts || [];\n\n            // If backend has a last_active_layout_id and we don't have a current layout, sync it\n            if (data.last_active_layout_id && this.layouts.some(l => l.id === data.last_active_layout_id)) {\n                // Only update if we don't already have a current layout set\n                if (!window.AppState?.currentLayoutId || window.AppState.currentLayoutId === \"reterminal_e1001\") {\n                    const lastActiveExists = this.layouts.find(l => l.id === data.last_active_layout_id);\n                    if (lastActiveExists && data.last_active_layout_id !== window.AppState?.currentLayoutId) {\n                        Logger.log(`[LayoutManager] Syncing to last active layout: ${data.last_active_layout_id}`);\n                        this.currentLayoutId = data.last_active_layout_id;\n                        if (window.AppState && typeof window.AppState.setCurrentLayoutId === \"function\") {\n                            window.AppState.setCurrentLayoutId(data.last_active_layout_id);\n                        }\n                    }\n                }\n            }\n\n            this.renderLayoutList();\n        } catch (err) {\n            Logger.error(\"[LayoutManager] Error loading layouts:\", err);\n            this.setStatus(\"Failed to load layouts\", \"error\");\n        }\n    }\n\n    renderLayoutList() {\n        const tbody = document.getElementById(\"layoutManagerTableBody\");\n        const currentNameEl = document.getElementById(\"layoutManagerCurrentName\");\n\n        if (!tbody) return;\n\n        // Determine current layout from AppState\n        if (window.AppState && window.AppState.currentLayoutId) {\n            this.currentLayoutId = window.AppState.currentLayoutId;\n        }\n\n        // Update current layout display\n        const currentLayout = this.layouts.find(l => l.id === this.currentLayoutId);\n        if (currentNameEl) {\n            currentNameEl.textContent = currentLayout ? currentLayout.name : this.currentLayoutId;\n        }\n\n        if (this.layouts.length === 0) {\n            tbody.innerHTML = '<tr><td colspan=\"4\" style=\"text-align: center; color: var(--muted); padding: 16px;\">No layouts found</td></tr>';\n            return;\n        }\n\n        tbody.innerHTML = this.layouts.map(layout => {\n            const isCurrent = layout.id === this.currentLayoutId;\n            // Check if there are duplicate names\n            const duplicateNames = this.layouts.filter(l => l.name === layout.name).length > 1;\n            return `\n                <tr style=\"border-bottom: 1px solid var(--border-subtle); ${isCurrent ? 'background: var(--accent-soft);' : ''}\">\n                    <td style=\"padding: 8px 4px;\">\n                        <span style=\"font-weight: 500;\">${this.escapeHtml(layout.name)}</span>\n                        ${isCurrent ? '<span style=\"background: var(--accent); color: white; font-size: 9px; padding: 2px 4px; border-radius: 2px; margin-left: 4px;\">current</span>' : ''}\n                        ${duplicateNames ? '<br><span style=\"font-size: 9px; color: var(--muted);\">' + this.escapeHtml(layout.id) + '</span>' : ''}\n                    </td>\n                    <td style=\"padding: 8px 4px; font-size: 11px; color: var(--muted);\">${this.getDeviceDisplayName(layout.device_model || layout.device_type)}</td>\n                    <td style=\"padding: 8px 4px; font-size: 11px; color: var(--muted);\">${layout.page_count} pages</td>\n                    <td style=\"padding: 8px 4px; text-align: right;\">\n                        <div style=\"display: flex; gap: 4px; justify-content: flex-end;\">\n                            ${!isCurrent ? `<button class=\"btn btn-sm btn-primary\" style=\"font-size: 10px; padding: 4px 8px;\" onclick=\"window.layoutManager.loadLayout('${layout.id}')\">Load</button>` : ''}\n                            <button class=\"btn btn-sm btn-secondary\" style=\"font-size: 10px; padding: 4px 8px;\" onclick=\"window.layoutManager.exportLayout('${layout.id}')\">­ƒôñ</button>\n                            ${!isCurrent && this.layouts.length > 1 ? `<button class=\"btn btn-sm btn-secondary\" style=\"font-size: 10px; padding: 4px 8px; color: var(--danger);\" onclick=\"window.layoutManager.deleteLayout('${layout.id}', '${this.escapeHtml(layout.name)}')\">­ƒùæ</button>` : ''}\n                        </div>\n                    </td>\n                </tr>\n            `;\n        }).join(\"\");\n    }\n\n    escapeHtml(text) {\n        const div = document.createElement(\"div\");\n        div.textContent = text || \"\";\n        return div.innerHTML;\n    }\n\n    getDeviceDisplayName(model) {\n        if (DEVICE_PROFILES && DEVICE_PROFILES[model]) {\n            let name = DEVICE_PROFILES[model].name;\n            const supportedIds = SUPPORTED_DEVICE_IDS || [];\n            if (!supportedIds.includes(model)) {\n                name += \" (untested)\";\n            }\n            return name;\n        }\n        const names = {\n            \"reterminal_e1001\": \"E1001 (Mono)\",\n            \"reterminal_e1002\": \"E1002 (Color)\",\n            \"trmnl\": \"TRMNL\",\n            \"esp32_s3_photopainter\": \"PhotoPainter (7-Color)\"\n        };\n        // Also handle short codes (E1001, E1002, TRMNL)\n        let name = names[model] || model || \"Unknown\";\n\n        // If it's a known non-supported model or shortcode, we don't necessarily know if it's supported here\n        // but the main check is the DEVICE_PROFILES one above.\n\n        return name;\n    }\n\n    async loadLayout(layoutId) {\n        if (typeof hasHaBackend !== \"function\" || !hasHaBackend()) return;\n\n        try {\n            this.setStatus(\"Loading layout...\", \"info\");\n\n            const resp = await fetch(`${HA_API_BASE}/layouts/${layoutId}`, {\n                headers: getHaHeaders()\n            });\n            if (!resp.ok) throw new Error(`Failed to load layout: ${resp.status}`);\n\n            const layout = await resp.json();\n\n            // IMPORTANT: Ensure device_id is set in the layout before loading into state\n            // This is critical for saving to the correct layout ID\n            if (!layout.device_id) {\n                layout.device_id = layoutId;\n            }\n\n            // Update current layout ID FIRST, before loading state\n            // This ensures any subsequent saves go to the correct layout\n            this.currentLayoutId = layoutId;\n            if (window.AppState && typeof window.AppState.setCurrentLayoutId === \"function\") {\n                window.AppState.setCurrentLayoutId(layoutId);\n                Logger.log(`[LayoutManager] Set currentLayoutId to: ${layoutId}`);\n            }\n\n            // Clear the canvas before loading new layout to prevent remnants from appearing\n            const canvas = document.getElementById(\"canvas\");\n            if (canvas) {\n                // Remove all widget elements but keep the grid\n                const grid = canvas.querySelector(\".canvas-grid\");\n                canvas.innerHTML = \"\";\n                if (grid) canvas.appendChild(grid);\n                Logger.log(\"[LayoutManager] Cleared canvas before loading layout\");\n            }\n\n            // Also clear any graph axis labels that may have been added by setTimeout callbacks\n            // These labels are appended to canvas but may arrive after canvas.innerHTML was cleared\n            document.querySelectorAll('.graph-axis-label').forEach(el => el.remove());\n\n            // Update AppState with the new layout (this sets currentLayoutId, deviceName, etc.)\n            if (typeof loadLayoutIntoState === \"function\") {\n                loadLayoutIntoState(layout);\n            }\n\n            // Double-check: Ensure currentLayoutId is still correct after loadLayoutIntoState\n            // (loadLayoutIntoState might reset it if layout.device_id was missing)\n            if (window.AppState && window.AppState.currentLayoutId !== layoutId) {\n                window.AppState.setCurrentLayoutId(layoutId);\n                Logger.log(`[LayoutManager] Re-set currentLayoutId to: ${layoutId} (was changed by loadLayoutIntoState)`);\n            }\n\n            // Emit event for other components\n            if (typeof emit === \"function\" && typeof EVENTS !== \"undefined\") {\n                emit(EVENTS.LAYOUT_IMPORTED, layout);\n            }\n\n            this.setStatus(`Loaded: ${layout.name || layoutId}`, \"success\");\n            this.renderLayoutList();\n\n            // Close the modal after loading\n            setTimeout(() => this.close(), 500);\n\n        } catch (err) {\n            Logger.error(\"[LayoutManager] Error loading layout:\", err);\n            this.setStatus(\"Failed to load layout\", \"error\");\n        }\n    }\n\n    async exportLayout(layoutId) {\n        if (typeof hasHaBackend !== \"function\" || !hasHaBackend()) return;\n\n        try {\n            // Trigger download via the export endpoint\n            const url = `${HA_API_BASE}/layouts/${layoutId}/export`;\n            const a = document.createElement(\"a\");\n            a.href = url;\n            a.download = `${layoutId}_layout.json`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n\n            this.setStatus(\"Export started...\", \"success\");\n        } catch (err) {\n            Logger.error(\"[LayoutManager] Error exporting layout:\", err);\n            this.setStatus(\"Failed to export layout\", \"error\");\n        }\n    }\n\n    async deleteLayout(layoutId, layoutName) {\n        if (typeof hasHaBackend !== \"function\" || !hasHaBackend()) return;\n\n        const confirmed = confirm(`Are you sure you want to delete \"${layoutName}\"?\\n\\nThis cannot be undone.`);\n        if (!confirmed) return;\n\n        try {\n            const resp = await fetch(`${HA_API_BASE}/layouts/${layoutId}`, {\n                method: \"DELETE\",\n                headers: getHaHeaders()\n            });\n\n            if (!resp.ok) {\n                const data = await resp.json().catch(() => ({}));\n                if (data.error === \"cannot_delete_last_layout\") {\n                    this.setStatus(\"Cannot delete the last layout\", \"error\");\n                    return;\n                }\n                throw new Error(data.error || `Delete failed: ${resp.status}`);\n            }\n\n            this.setStatus(`Deleted: ${layoutName}`, \"success\");\n            await this.loadLayouts();\n\n        } catch (err) {\n            Logger.error(\"[LayoutManager] Error deleting layout:\", err);\n            this.setStatus(\"Failed to delete layout\", \"error\");\n        }\n    }\n\n    showNewLayoutDialog() {\n        // Create modal if not exists\n        if (!document.getElementById(\"newLayoutModal\")) {\n            const modal = document.createElement(\"div\");\n            modal.id = \"newLayoutModal\";\n            modal.className = \"modal-backdrop hidden\";\n            modal.innerHTML = `\n                <div class=\"modal\" style=\"max-width: 400px;\">\n                    <div class=\"modal-header\">\n                        <div>Create New Layout</div>\n                        <button id=\"newLayoutClose\" class=\"btn btn-secondary\">├ù</button>\n                    </div>\n                    <div class=\"modal-body\">\n                        <div class=\"field\" style=\"margin-bottom: 12px;\">\n                            <div class=\"prop-label\">Layout Name</div>\n                            <input id=\"newLayoutName\" class=\"prop-input\" type=\"text\" placeholder=\"e.g. Living Room Display\" />\n                        </div>\n                        <div class=\"field\">\n                            <div class=\"prop-label\">Device Type</div>\n                            <select id=\"newLayoutDeviceType\" class=\"prop-input\">\n                                ${this.generateDeviceOptions()}\n                            </select>\n                            <p class=\"hint\" style=\"color: var(--muted); font-size: 11px; margin-top: 4px;\">Select the device that will display this layout.</p>\n                        </div>\n                    </div>\n                    <div class=\"modal-actions\">\n                        <button id=\"newLayoutCancel\" class=\"btn btn-secondary\">Cancel</button>\n                        <button id=\"newLayoutConfirm\" class=\"btn btn-primary\">Create Layout</button>\n                    </div>\n                </div>\n            `;\n            document.body.appendChild(modal);\n\n            // Bindevents\n            document.getElementById(\"newLayoutClose\").addEventListener(\"click\", () => {\n                modal.classList.add(\"hidden\");\n            });\n            document.getElementById(\"newLayoutCancel\").addEventListener(\"click\", () => {\n                modal.classList.add(\"hidden\");\n            });\n            document.getElementById(\"newLayoutConfirm\").addEventListener(\"click\", () => {\n                const name = document.getElementById(\"newLayoutName\").value.trim();\n                const deviceType = document.getElementById(\"newLayoutDeviceType\").value;\n                if (!name) {\n                    alert(\"Please enter a layout name.\");\n                    return;\n                }\n                modal.classList.add(\"hidden\");\n                this.createLayout(name, deviceType);\n            });\n            modal.addEventListener(\"click\", (e) => {\n                if (e.target === modal) modal.classList.add(\"hidden\");\n            });\n        }\n\n        // Auto-generate default name\n        const existingCount = this.layouts.length;\n        const defaultName = `Layout ${existingCount + 1}`;\n        document.getElementById(\"newLayoutName\").value = defaultName;\n        // Default to first available device or fallback\n        const model = AppState.deviceModel || (AppState.settings ? AppState.settings.device_model : null) || \"reterminal_e1001\";\n        const defaultDevice = DEVICE_PROFILES ? Object.keys(DEVICE_PROFILES)[0] : \"reterminal_e1001\";\n        document.getElementById(\"newLayoutDeviceType\").value = defaultDevice;\n        document.getElementById(\"newLayoutModal\").classList.remove(\"hidden\");\n    }\n\n    generateDeviceOptions() {\n        if (DEVICE_PROFILES) {\n            const supportedIds = window.SUPPORTED_DEVICE_IDS || [];\n            return Object.entries(DEVICE_PROFILES).map(([key, profile]) => {\n                let displayName = profile.name;\n                if (!supportedIds.includes(key)) {\n                    displayName += \" (untested)\";\n                }\n                return `<option value=\"${key}\">${displayName}</option>`;\n            }).join(\"\");\n        }\n        return `<option value=\"reterminal_e1001\">reTerminal E1001</option>`;\n    }\n\n    async createLayout(name, deviceModel = \"reterminal_e1001\") {\n        if (typeof hasHaBackend !== \"function\" || !hasHaBackend()) return;\n\n        // Generate ID from name - ALWAYS add timestamp to ensure uniqueness\n        let baseId = name.toLowerCase().replace(/\\s+/g, \"_\").replace(/[^a-z0-9_]/g, \"\");\n\n        // If baseId would be empty, use a default\n        if (!baseId) {\n            baseId = \"layout\";\n        }\n\n        // Always append timestamp for uniqueness\n        const id = baseId + \"_\" + Date.now();\n\n        // Note: deviceModel is now passed directly from the select value\n\n\n        try {\n            const resp = await fetch(`${HA_API_BASE}/layouts`, {\n                method: \"POST\",\n                headers: getHaHeaders(),\n                body: JSON.stringify({ id, name, device_type: deviceModel, device_model: deviceModel })\n            });\n\n            if (!resp.ok) {\n                const data = await resp.json().catch(() => ({}));\n                throw new Error(data.error || `Create failed: ${resp.status}`);\n            }\n\n            this.setStatus(`Created: ${name}`, \"success\");\n            await this.loadLayouts();\n\n            // CRITICAL: Clear the current state BEFORE loading the new layout\n            // This prevents any widgets from the previous layout from appearing\n            if (window.AppState) {\n                // Reset to empty state\n                window.AppState.setPages([{\n                    id: \"page_0\",\n                    name: \"Page 1\",\n                    widgets: []\n                }]);\n                window.AppState.setCurrentPageIndex(0);\n                Logger.log(\"[LayoutManager] Cleared state before loading new layout\");\n            }\n\n            // Auto-load the new layout so user can start working on it\n            await this.loadLayout(id);\n\n            // After loading, update the device model in AppState\n            if (window.AppState) {\n                window.AppState.setDeviceModel(deviceModel);\n                if (window.AppState.settings) {\n                    window.AppState.settings.device_model = deviceModel;\n                }\n                window.currentDeviceModel = deviceModel;\n\n                // Force a state change event to trigger re-render\n                // This ensures the canvas is cleared and redrawn with the new (empty) layout\n                if (typeof emit === \"function\" && typeof EVENTS !== \"undefined\") {\n                    emit(EVENTS.STATE_CHANGED);\n                }\n\n                Logger.log(`[LayoutManager] Created layout '${id}' with device_model: ${deviceModel}, pages: ${window.AppState.pages?.length}, widgets: ${window.AppState.getCurrentPage()?.widgets?.length || 0}`);\n            }\n\n        } catch (err) {\n            Logger.error(\"[LayoutManager] Error creating layout:\", err);\n            this.setStatus(\"Failed to create layout\", \"error\");\n        }\n    }\n\n    async handleFileImport(event) {\n        const file = event.target.files[0];\n        if (!file) return;\n\n        try {\n            const text = await file.text();\n            const data = JSON.parse(text);\n\n            // Validate it looks like a layout\n            if (!data.pages && !data.device_id) {\n                this.setStatus(\"Invalid layout file\", \"error\");\n                return;\n            }\n\n            await this.importLayout(data);\n\n        } catch (err) {\n            Logger.error(\"[LayoutManager] Error importing file:\", err);\n            this.setStatus(\"Failed to import file: \" + err.message, \"error\");\n        }\n\n        // Reset file input\n        event.target.value = \"\";\n    }\n\n    async importLayout(data, overwrite = false) {\n        if (typeof hasHaBackend !== \"function\" || !hasHaBackend()) return;\n\n        try {\n            const url = `${HA_API_BASE}/layouts/import${overwrite ? \"?overwrite=true\" : \"\"}`;\n            const resp = await fetch(url, {\n                method: \"POST\",\n                headers: getHaHeaders(),\n                body: JSON.stringify(data)\n            });\n\n            const result = await resp.json();\n\n            if (!resp.ok) {\n                if (result.error === \"layout_exists\") {\n                    const doOverwrite = confirm(\n                        `A layout with ID \"${result.existing_id}\" already exists.\\n\\nDo you want to overwrite it?`\n                    );\n                    if (doOverwrite) {\n                        await this.importLayout(data, true);\n                        return;\n                    }\n                    return;\n                }\n                throw new Error(result.error || `Import failed: ${resp.status}`);\n            }\n\n            this.setStatus(`Imported: ${result.name || result.id}`, \"success\");\n            await this.loadLayouts();\n\n        } catch (err) {\n            Logger.error(\"[LayoutManager] Error importing layout:\", err);\n            this.setStatus(\"Failed to import layout\", \"error\");\n        }\n    }\n}\n\n// Create global instance\nwindow.layoutManager = new LayoutManager();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\llm_prompt.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\modal_wiring.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\page_settings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\quick_search.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\radial_menu.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'Logger' is defined but never used.","line":3,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"Logger"},"fix":{"range":[105,149],"text":""},"desc":"Remove unused variable 'Logger'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AppState } from '../core/state.js';\r\nimport { forceSnapWidget } from '../core/canvas_snap.js';\r\nimport { Logger } from '../utils/logger.js';\r\n\r\nexport class RadialMenu {\r\n    constructor() {\r\n        this.active = false;\r\n        this.element = null;\r\n        this.targetWidgetId = null;\r\n        this.position = { x: 0, y: 0 };\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        // Create the menu element if it doesn't exist\r\n        if (!this.element) {\r\n            this.element = document.createElement('div');\r\n            this.element.className = 'radial-menu';\r\n            this.element.innerHTML = `\r\n                <div class=\"radial-menu-center\"></div>\r\n                <div class=\"radial-menu-items\"></div>\r\n            `;\r\n            document.body.appendChild(this.element);\r\n\r\n            // Close on click outside\r\n            window.addEventListener('mousedown', (e) => {\r\n                if (this.active && !this.element.contains(e.target)) {\r\n                    this.hide();\r\n                }\r\n            }, true);\r\n\r\n            // Close on escape\r\n            window.addEventListener('keydown', (e) => {\r\n                if (e.key === 'Escape' && this.active) {\r\n                    this.hide();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    show(x, y, widgetId = null) {\r\n        this.targetWidgetId = widgetId;\r\n        this.position = { x, y };\r\n        this.active = true;\r\n\r\n        this.element.style.left = `${x}px`;\r\n        this.element.style.top = `${y}px`;\r\n        this.renderItems();\r\n\r\n        // Use requestAnimationFrame to ensure the element is positioned before adding the active class for transitions\r\n        requestAnimationFrame(() => {\r\n            this.element.classList.add('active');\r\n        });\r\n    }\r\n\r\n    hide() {\r\n        this.active = false;\r\n        this.element.classList.remove('active');\r\n        this.targetWidgetId = null;\r\n    }\r\n\r\n    renderItems() {\r\n        const itemsContainer = this.element.querySelector('.radial-menu-items');\r\n        itemsContainer.innerHTML = '';\r\n\r\n        const actions = this.getAvailableActions();\r\n        const angleStep = (2 * Math.PI) / actions.length;\r\n        const radius = 70; // Distance from center\r\n\r\n        actions.forEach((action, index) => {\r\n            const angle = index * angleStep - Math.PI / 2; // Start from top\r\n            const itemX = Math.cos(angle) * radius;\r\n            const itemY = Math.sin(angle) * radius;\r\n\r\n            const item = document.createElement('div');\r\n            item.className = `radial-menu-item ${action.className || ''}`;\r\n            item.style.setProperty('--x', `${itemX}px`);\r\n            item.style.setProperty('--y', `${itemY}px`);\r\n            item.title = action.label;\r\n            item.innerHTML = `<i class=\"mdi ${action.icon}\"></i>`;\r\n\r\n            item.addEventListener('click', (e) => {\r\n                e.stopPropagation();\r\n                action.callback();\r\n                this.hide();\r\n            });\r\n\r\n            itemsContainer.appendChild(item);\r\n        });\r\n    }\r\n\r\n    getAvailableActions() {\r\n        const state = AppState;\r\n        const widget = this.targetWidgetId ? state.getWidgetById(this.targetWidgetId) : null;\r\n\r\n        const actions = [];\r\n\r\n        if (widget) {\r\n            // Widget specific actions\r\n            actions.push({\r\n                label: 'Copy',\r\n                icon: 'mdi-content-copy',\r\n                callback: () => {\r\n                    state.selectWidget(this.targetWidgetId, false);\r\n                    state.copyWidget();\r\n                }\r\n            });\r\n\r\n            actions.push({\r\n                label: widget.locked ? 'Unlock' : 'Lock',\r\n                icon: widget.locked ? 'mdi-lock-open-outline' : 'mdi-lock-outline',\r\n                callback: () => {\r\n                    state.updateWidget(this.targetWidgetId, { locked: !widget.locked });\r\n                }\r\n            });\r\n\r\n            actions.push({\r\n                label: 'Snap',\r\n                icon: 'mdi-magnet',\r\n                callback: () => {\r\n                    forceSnapWidget(this.targetWidgetId);\r\n                }\r\n            });\r\n\r\n            actions.push({\r\n                label: 'Delete',\r\n                icon: 'mdi-delete-outline',\r\n                className: 'danger',\r\n                callback: () => {\r\n                    state.deleteWidget(this.targetWidgetId);\r\n                }\r\n            });\r\n        } else {\r\n            // Canvas specific actions\r\n            actions.push({\r\n                label: 'Paste',\r\n                icon: 'mdi-content-paste',\r\n                callback: () => {\r\n                    // We might want to paste at the current right-click position\r\n                    // but state.pasteWidget doesn't take coords currently.\r\n                    // For now, just call it.\r\n                    state.pasteWidget();\r\n                }\r\n            });\r\n        }\r\n\r\n        return actions;\r\n    }\r\n}\r\n\r\n// Global instance\r\nwindow.RadialMenu = new RadialMenu();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\snippet_manager.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'AppState' is defined but never used.","line":2,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":18,"suggestions":[{"messageId":"removeVar","data":{"varName":"AppState"},"fix":{"range":[49,93],"text":""},"desc":"Remove unused variable 'AppState'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { on, EVENTS } from '../core/events.js';\r\nimport { AppState } from '../core/state.js';\r\nimport { Logger } from '../utils/logger.js';\r\nimport { showToast } from '../utils/dom.js';\r\nimport { highlightWidgetInSnippet } from '../io/yaml_export.js';\r\nimport { loadLayoutIntoState, parseSnippetYamlOffline } from '../io/yaml_import.js';\r\nimport { importSnippetBackend } from '../io/ha_api.js';\r\nimport { hasHaBackend } from '../utils/env.js';\r\n\r\nexport class SnippetManager {\r\n    constructor(adapter) {\r\n        this.adapter = adapter;\r\n        this.suppressSnippetUpdate = false;\r\n        this.snippetDebounceTimer = null;\r\n        this.lastGeneratedYaml = \"\";\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.bindEvents();\r\n        this.setupAutoUpdate();\r\n\r\n        // Initial update\r\n        this.updateSnippetBox();\r\n    }\r\n\r\n    bindEvents() {\r\n        // Fullscreen Snippet Button\r\n        const fullscreenSnippetBtn = document.getElementById('fullscreenSnippetBtn');\r\n        if (fullscreenSnippetBtn) {\r\n            fullscreenSnippetBtn.addEventListener('click', () => {\r\n                this.openSnippetModal();\r\n            });\r\n        }\r\n\r\n        const snippetFullscreenClose = document.getElementById('snippetFullscreenClose');\r\n        if (snippetFullscreenClose) {\r\n            snippetFullscreenClose.addEventListener('click', () => {\r\n                const modal = document.getElementById('snippetFullscreenModal');\r\n                if (modal) {\r\n                    modal.classList.add('hidden');\r\n                }\r\n            });\r\n        }\r\n\r\n        // Import Modal Buttons\r\n        const importSnippetConfirm = document.getElementById('importSnippetConfirm');\r\n        if (importSnippetConfirm) {\r\n            importSnippetConfirm.addEventListener('click', async () => {\r\n                await this.handleImportSnippet();\r\n            });\r\n        }\r\n\r\n        // Update Layout from YAML (Snippet Box)\r\n        const updateLayoutBtn = document.getElementById('updateLayoutBtn');\r\n        if (updateLayoutBtn) {\r\n            updateLayoutBtn.addEventListener('click', async () => {\r\n                await this.handleUpdateLayoutFromSnippetBox();\r\n            });\r\n        }\r\n\r\n        // Copy Snippet Button\r\n        const copySnippetBtn = document.getElementById('copySnippetBtn');\r\n        if (copySnippetBtn) {\r\n            copySnippetBtn.addEventListener('click', async () => {\r\n                this.copySnippetToClipboard(copySnippetBtn);\r\n            });\r\n        }\r\n    }\r\n\r\n    setupAutoUpdate() {\r\n        // Update snippet box whenever state changes\r\n        on(EVENTS.STATE_CHANGED, () => {\r\n            if (!this.suppressSnippetUpdate) {\r\n                this.updateSnippetBox();\r\n            }\r\n        });\r\n\r\n        on(EVENTS.SELECTION_CHANGED, (data) => {\r\n            // StateStore emits { widgetIds: [...] }\r\n            const widgetId = data && data.widgetIds && data.widgetIds.length > 0 ? data.widgetIds[data.widgetIds.length - 1] : null;\r\n            if (widgetId && typeof highlightWidgetInSnippet === 'function') {\r\n                highlightWidgetInSnippet(widgetId);\r\n            }\r\n        });\r\n    }\r\n\r\n    updateSnippetBox() {\r\n        const snippetBox = document.getElementById('snippetBox');\r\n        if (snippetBox) {\r\n            // Debounce the update\r\n            if (this.snippetDebounceTimer) clearTimeout(this.snippetDebounceTimer);\r\n\r\n            this.snippetDebounceTimer = setTimeout(() => {\r\n                // Double-check suppression flag inside callback\r\n                if (this.suppressSnippetUpdate) {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    const payload = window.AppState ? window.AppState.getPagesPayload() : { pages: [] };\r\n                    this.adapter.generate(payload).then(yaml => {\r\n                        this.lastGeneratedYaml = yaml;\r\n                        snippetBox.value = yaml;\r\n\r\n                        // Re-highlight the selected widget if any\r\n                        const selectedIds = window.AppState ? window.AppState.selectedWidgetIds : [];\r\n                        const widgetId = selectedIds.length > 0 ? selectedIds[selectedIds.length - 1] : null;\r\n\r\n                        if (widgetId && typeof highlightWidgetInSnippet === 'function') {\r\n                            highlightWidgetInSnippet(widgetId);\r\n                        }\r\n                    }).catch(e => {\r\n                        Logger.error(\"Error generating snippet via adapter:\", e);\r\n                        snippetBox.value = \"# Error generating YAML (adapter): \" + e.message;\r\n                    });\r\n                } catch (e) {\r\n                    Logger.error(\"Error generating snippet:\", e);\r\n                    snippetBox.value = \"# Error generating YAML: \" + e.message;\r\n                }\r\n            }, 50);\r\n        }\r\n    }\r\n\r\n    openSnippetModal() {\r\n        const modal = document.getElementById('snippetFullscreenModal');\r\n        const content = document.getElementById('snippetFullscreenContent');\r\n        const snippetBox = document.getElementById('snippetBox');\r\n\r\n        if (!modal || !content || !snippetBox) return;\r\n\r\n        // Use a textarea for editing if it doesn't exist, otherwise update its value\r\n        let textarea = content.querySelector(\"textarea\");\r\n        if (!textarea) {\r\n            content.innerHTML = \"\"; // Clear existing content\r\n            textarea = document.createElement(\"textarea\");\r\n            textarea.style.width = \"100%\";\r\n            textarea.style.height = \"calc(100vh - 150px)\"; // Adjusted for header/footer\r\n            textarea.style.fontFamily = \"monospace\";\r\n            textarea.style.padding = \"10px\";\r\n            textarea.style.boxSizing = \"border-box\";\r\n            textarea.style.resize = \"none\";\r\n            textarea.style.backgroundColor = \"var(--bg-input)\";\r\n            textarea.style.color = \"var(--text)\";\r\n            textarea.style.border = \"1px solid var(--border)\";\r\n            textarea.style.borderRadius = \"4px\";\r\n            content.appendChild(textarea);\r\n\r\n            // Add a save/update button to the modal footer if not present\r\n            let footer = modal.querySelector(\".modal-actions\");\r\n            if (!footer) {\r\n                footer = document.createElement(\"div\");\r\n                footer.className = \"modal-actions\";\r\n                const modalInner = modal.querySelector(\".modal\");\r\n                if (modalInner) modalInner.appendChild(footer);\r\n            }\r\n\r\n            if (!footer.querySelector(\"#fullscreenUpdateBtn\")) {\r\n                const updateBtn = document.createElement(\"button\");\r\n                updateBtn.id = \"fullscreenUpdateBtn\";\r\n                updateBtn.className = \"btn btn-primary\";\r\n                updateBtn.textContent = \"Update Layout from YAML\";\r\n                updateBtn.onclick = () => {\r\n                    snippetBox.value = textarea.value;\r\n                    // Trigger the main update button logic directly\r\n                    this.handleUpdateLayoutFromSnippetBox();\r\n                    modal.classList.add(\"hidden\");\r\n                };\r\n                footer.insertBefore(updateBtn, footer.firstChild);\r\n            }\r\n        }\r\n        textarea.value = snippetBox.value || \"\";\r\n        modal.style.display = \"\"; // Clear any inline display: none\r\n        modal.classList.remove('hidden');\r\n    }\r\n\r\n    async handleImportSnippet() {\r\n        const textarea = document.getElementById('importSnippetTextarea');\r\n        const errorBox = document.getElementById('importSnippetError');\r\n        if (!textarea) return;\r\n\r\n        const yaml = textarea.value;\r\n        if (!yaml.trim()) return;\r\n\r\n        try {\r\n            if (errorBox) errorBox.textContent = \"\";\r\n\r\n            let layout;\r\n            // Always try offline parser first for snippets as it's more robust for native LVGL\r\n            try {\r\n                layout = parseSnippetYamlOffline(yaml);\r\n                Logger.log(\"[handleImportSnippet] Successfully used offline parser.\");\r\n            } catch (offlineErr) {\r\n                Logger.warn(\"[handleImportSnippet] Offline parser failed, falling back to backend:\", offlineErr);\r\n                if (hasHaBackend()) {\r\n                    layout = await importSnippetBackend(yaml);\r\n                } else {\r\n                    throw offlineErr;\r\n                }\r\n            }\r\n\r\n            loadLayoutIntoState(layout);\r\n\r\n            // Close modal\r\n            const modal = document.getElementById('importSnippetModal');\r\n            if (modal) {\r\n                modal.classList.add('hidden');\r\n                modal.style.display = 'none';\r\n            }\r\n\r\n            showToast(\"Layout imported successfully\", \"success\");\r\n\r\n        } catch (err) {\r\n            Logger.error(\"Import failed:\", err);\r\n            if (errorBox) errorBox.textContent = `Error: ${err.message}`;\r\n        }\r\n    }\r\n\r\n    async handleUpdateLayoutFromSnippetBox() {\r\n        const snippetBox = document.getElementById('snippetBox');\r\n        if (!snippetBox) return;\r\n        const yaml = snippetBox.value;\r\n        if (!yaml.trim()) return;\r\n\r\n        if (this.lastGeneratedYaml && yaml.trim() === this.lastGeneratedYaml.trim()) {\r\n            Logger.log(\"[handleUpdateLayoutFromSnippetBox] Skipping update: Snippet matches last generated state.\");\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const currentLayoutId = window.AppState?.currentLayoutId || \"reterminal_e1001\";\r\n            const currentDeviceName = window.AppState?.deviceName || \"Layout 1\";\r\n            const currentDeviceModel = window.AppState?.deviceModel || window.AppState?.settings?.device_model || \"reterminal_e1001\";\r\n\r\n            Logger.log(`[handleUpdateLayoutFromSnippetBox] Preserving context - ID: ${currentLayoutId}, Name: ${currentDeviceName}`);\r\n\r\n            let layout = parseSnippetYamlOffline(yaml);\r\n\r\n            layout.device_id = currentLayoutId;\r\n            layout.name = currentDeviceName;\r\n            layout.device_model = currentDeviceModel;\r\n\r\n            if (!layout.settings) {\r\n                layout.settings = {};\r\n            }\r\n            layout.settings.device_model = currentDeviceModel;\r\n            layout.settings.device_name = currentDeviceName;\r\n\r\n            // Preserve dark_mode setting from current state\r\n            const currentDarkMode = window.AppState?.settings?.dark_mode || false;\r\n            layout.settings.dark_mode = currentDarkMode;\r\n\r\n            this.suppressSnippetUpdate = true;\r\n            if (this.snippetDebounceTimer) {\r\n                clearTimeout(this.snippetDebounceTimer);\r\n                this.snippetDebounceTimer = null;\r\n            }\r\n\r\n            loadLayoutIntoState(layout);\r\n\r\n            setTimeout(() => {\r\n                this.suppressSnippetUpdate = false;\r\n            }, 1500);\r\n\r\n            showToast(\"Layout updated from YAML\", \"success\");\r\n\r\n            if (yaml.includes(\"lambda:\") || yaml.includes(\"script:\")) {\r\n                setTimeout(() => {\r\n                    showToast(\"Note: Custom C++ (lambda/script) may not fully preview.\", \"warning\", 4000);\r\n                }, 800);\r\n            }\r\n\r\n        } catch (err) {\r\n            Logger.error(\"Update layout failed:\", err);\r\n            showToast(`Update failed: ${err.message}`, \"error\");\r\n            this.suppressSnippetUpdate = false;\r\n        }\r\n    }\r\n\r\n    async copySnippetToClipboard(btnElement) {\r\n        const snippetBox = document.getElementById('snippetBox');\r\n        if (!snippetBox) return;\r\n\r\n        const text = snippetBox.value || \"\";\r\n        const originalText = btnElement.textContent;\r\n\r\n        const setSuccessState = () => {\r\n            btnElement.textContent = \"Copied!\";\r\n            btnElement.style.minWidth = btnElement.offsetWidth + \"px\";\r\n            setTimeout(() => {\r\n                btnElement.textContent = originalText;\r\n                btnElement.style.minWidth = \"\";\r\n            }, 2000);\r\n        };\r\n\r\n        try {\r\n            if (navigator.clipboard && window.isSecureContext) {\r\n                await navigator.clipboard.writeText(text);\r\n                showToast(\"Snippet copied to clipboard\", \"success\");\r\n                setSuccessState();\r\n            } else {\r\n                const textarea = document.createElement(\"textarea\");\r\n                textarea.value = text;\r\n                textarea.style.position = \"fixed\";\r\n                textarea.style.left = \"-999999px\";\r\n                textarea.style.top = \"-999999px\";\r\n                document.body.appendChild(textarea);\r\n                textarea.focus();\r\n                textarea.select();\r\n                try {\r\n                    document.execCommand(\"copy\");\r\n                    showToast(\"Snippet copied to clipboard\", \"success\");\r\n                    setSuccessState();\r\n                } catch {\r\n                    showToast(\"Unable to copy. Try selecting and copying manually.\", \"error\");\r\n                }\r\n                document.body.removeChild(textarea);\r\n            }\r\n        } catch (err) {\r\n            Logger.error(\"Copy failed:\", err);\r\n            showToast(\"Unable to copy snippet\", \"error\");\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\splitters.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'appContent' is assigned a value but never used.","line":11,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":21,"suggestions":[{"messageId":"removeVar","data":{"varName":"appContent"},"fix":{"range":[378,436],"text":""},"desc":"Remove unused variable 'appContent'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Handles panel resizing via draggable splitters.\n */\nimport { Logger } from '../utils/logger.js';\n\nfunction init() {\n    const leftResizer = document.getElementById('resizer-left');\n    const rightResizer = document.getElementById('resizer-right');\n    const sidebar = document.querySelector('.sidebar');\n    const rightPanel = document.querySelector('.right-panel');\n    const appContent = document.querySelector('.app-content');\n\n    if (!leftResizer || !rightResizer || !sidebar || !rightPanel) {\n        Logger.warn(\"[Splitters] Layout elements not found, retrying...\");\n        setTimeout(init, 500);\n        return;\n    }\n\n    Logger.log(\"[Splitters] Initializing draggable panels...\");\n\n    function setupResizer(resizer, target, orientation) {\n        let startPos, startSize;\n\n        resizer.addEventListener('mousedown', function (e) {\n            if (orientation === 'vertical') {\n                startPos = e.clientX;\n                startSize = target.offsetWidth;\n                document.body.style.cursor = 'col-resize';\n            } else {\n                startPos = e.clientY;\n                startSize = target.offsetHeight;\n                document.body.style.cursor = 'row-resize';\n            }\n\n            resizer.classList.add('dragging');\n            document.body.style.userSelect = 'none';\n\n            function onMouseMove(moveE) {\n                let delta;\n                if (orientation === 'vertical') {\n                    delta = moveE.clientX - startPos;\n                    // For right panel, delta is inverted\n                    if (resizer.id === 'resizer-right') delta = -delta;\n\n                    const newWidth = startSize + delta;\n                    const min = parseInt(getComputedStyle(target).minWidth) || 100;\n                    const max = parseInt(getComputedStyle(target).maxWidth) || 800;\n\n                    if (newWidth >= min && newWidth <= max) {\n                        target.style.width = newWidth + 'px';\n                    }\n                } else {\n                    // Horizontal resizer (bottom panel)\n                    delta = startPos - moveE.clientY; // Inverted because panel is at the bottom\n\n                    const newHeight = startSize + delta;\n                    const min = parseInt(getComputedStyle(target).minHeight) || 50;\n                    const max = parseInt(getComputedStyle(target).maxHeight) || 800;\n\n                    if (newHeight >= min && newHeight <= max) {\n                        target.style.height = newHeight + 'px';\n                    }\n                }\n\n                if (window.dispatchEvent) window.dispatchEvent(new Event('resize'));\n            }\n\n            function onMouseUp() {\n                resizer.classList.remove('dragging');\n                document.body.style.cursor = 'default';\n                document.body.style.userSelect = '';\n                window.removeEventListener('mousemove', onMouseMove);\n                window.removeEventListener('mouseup', onMouseUp);\n            }\n\n            window.addEventListener('mousemove', onMouseMove);\n            window.addEventListener('mouseup', onMouseUp);\n        });\n    }\n\n    const bottomResizer = document.getElementById('resizer-bottom');\n    const codePanel = document.querySelector('.code-panel');\n\n    setupResizer(leftResizer, sidebar, 'vertical');\n    setupResizer(rightResizer, rightPanel, 'vertical');\n    if (bottomResizer && codePanel) {\n        setupResizer(bottomResizer, codePanel, 'horizontal');\n    }\n}\n\n// Run on load\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', init);\n} else {\n    init();\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\ui\\widget_palette.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\utils\\device.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\utils\\dom.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\utils\\env.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":38,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":38,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":50,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":90,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Logger } from './logger.js';\n\n/**\n * Detects the Home Assistant backend URL.\n * @returns {string|null} The API base URL or null.\n */\nexport function detectHaBackendBaseUrl() {\n    // Check manual configuration first (from localStorage)\n    let manualUrl = getHaManualUrl();\n    if (manualUrl) {\n        manualUrl = manualUrl.trim();\n        if (manualUrl.endsWith('/')) {\n            manualUrl = manualUrl.slice(0, -1);\n        }\n        // Ensure suffix is present even if user entered only the base URL previously\n        if (manualUrl && !manualUrl.includes('/api/')) {\n            manualUrl += '/api/esphome_designer';\n        }\n        return manualUrl;\n    }\n\n    try {\n        const loc = window.location;\n        if (loc.protocol === \"file:\") {\n            return null;\n        }\n        if (\n            loc.hostname === \"homeassistant\" ||\n            loc.hostname === \"hassio\" ||\n            loc.pathname.includes(\"/api/\") ||\n            loc.pathname.includes(\"/local/\") ||\n            loc.pathname.includes(\"/hacsfiles/\") ||\n            loc.pathname.includes(\"/esphome-designer\")\n        ) {\n            return `${loc.origin}/api/esphome_designer`;\n        }\n        return null;\n    } catch (e) {\n        return null;\n    }\n}\n\n/**\n * Gets the manual HA URL from localStorage.\n * @returns {string|null}\n */\nexport function getHaManualUrl() {\n    try {\n        return localStorage.getItem('ha_manual_url');\n    } catch (e) {\n        return null;\n    }\n}\n\n/**\n * Sets the manual HA URL in localStorage.\n * @param {string|null} url \n */\nexport function setHaManualUrl(url) {\n    try {\n        if (url) {\n            let sanitizedUrl = url.trim();\n            // Remove trailing slash if present\n            if (sanitizedUrl.endsWith('/')) {\n                sanitizedUrl = sanitizedUrl.slice(0, -1);\n            }\n\n            // If the URL is just the base (e.g. http://ha.local:8123), \n            // append the custom component API path automatically.\n            if (!sanitizedUrl.includes('/api/')) {\n                sanitizedUrl += '/api/esphome_designer';\n            }\n\n            localStorage.setItem('ha_manual_url', sanitizedUrl);\n        } else {\n            localStorage.removeItem('ha_manual_url');\n        }\n    } catch (e) {\n        Logger.error(\"Failed to save HA URL:\", e);\n    }\n}\n\n/**\n * Gets the HA Long-Lived Access Token from localStorage.\n * @returns {string|null}\n */\nexport function getHaToken() {\n    try {\n        return localStorage.getItem('ha_llat_token');\n    } catch (e) {\n        return null;\n    }\n}\n\n/**\n * Sets the HA Long-Lived Access Token in localStorage.\n * @param {string|null} token \n */\nexport function setHaToken(token) {\n    try {\n        if (token) {\n            localStorage.setItem('ha_llat_token', token);\n        } else {\n            localStorage.removeItem('ha_llat_token');\n        }\n    } catch (e) {\n        Logger.error(\"Failed to save HA Token:\", e);\n    }\n}\n\nexport let HA_API_BASE = detectHaBackendBaseUrl();\n\n/**\n * Re-detects the HA backend URL (e.g. after settings change).\n */\nexport function refreshHaBaseUrl() {\n    HA_API_BASE = detectHaBackendBaseUrl();\n}\n\n/**\n * Checks if the HA backend is available.\n * @returns {boolean}\n */\nexport function hasHaBackend() {\n    return !!HA_API_BASE;\n}\n\n// Global exposure for transition\nwindow.detectHaBackendBaseUrl = detectHaBackendBaseUrl;\nwindow.getHaManualUrl = getHaManualUrl;\nwindow.setHaManualUrl = setHaManualUrl;\nwindow.getHaToken = getHaToken;\nwindow.setHaToken = setHaToken;\nwindow.HA_API_BASE = HA_API_BASE;\nwindow.refreshHaBaseUrl = refreshHaBaseUrl;\nwindow.hasHaBackend = hasHaBackend;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\utils\\graph_helpers.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'min' is defined but never used. Allowed unused args must match /^_/u.","line":16,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":52,"suggestions":[{"messageId":"removeVar","data":{"varName":"min"},"fix":{"range":[548,553],"text":""},"desc":"Remove unused variable 'min'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'max' is defined but never used. Allowed unused args must match /^_/u.","line":16,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":57,"suggestions":[{"messageId":"removeVar","data":{"varName":"max"},"fix":{"range":[553,558],"text":""},"desc":"Remove unused variable 'max'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'xGridStr' is defined but never used. Allowed unused args must match /^_/u.","line":39,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":62,"suggestions":[{"messageId":"removeVar","data":{"varName":"xGridStr"},"fix":{"range":[1324,1334],"text":""},"desc":"Remove unused variable 'xGridStr'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'yGridStr' is defined but never used. Allowed unused args must match /^_/u.","line":39,"column":64,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":72,"suggestions":[{"messageId":"removeVar","data":{"varName":"yGridStr"},"fix":{"range":[1334,1344],"text":""},"desc":"Remove unused variable 'yGridStr'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// --- Graph Preview Helpers ---\n\nexport function parseDuration(durationStr) {\n    if (!durationStr) return 3600; // Default 1h\n    const match = durationStr.match(/^(\\d+)([a-z]+)$/i);\n    if (!match) return 3600;\n    const val = parseInt(match[1], 10);\n    const unit = match[2].toLowerCase();\n    if (unit.startsWith(\"s\")) return val;\n    if (unit.startsWith(\"m\")) return val * 60;\n    if (unit.startsWith(\"h\")) return val * 3600;\n    if (unit.startsWith(\"d\")) return val * 86400;\n    return val;\n}\n\nexport function generateMockData(width, height, min, max) {\n    const points = [];\n    const numPoints = 50;\n\n    // Generate a nice wavy line\n    for (let i = 0; i < numPoints; i++) {\n        const x = (i / (numPoints - 1)) * width;\n\n        // Sine wave + noise\n        const normalizedX = i / numPoints;\n        const base = Math.sin(normalizedX * Math.PI * 2); // One full wave\n        const noise = (Math.random() - 0.5) * 0.2; // +/- 10% noise\n\n        let normalizedY = 0.5 + (base * 0.3) + noise;\n        normalizedY = Math.max(0.1, Math.min(0.9, normalizedY)); // Clamp to keep inside\n\n        // Map to pixel coordinates (Y is inverted in SVG/Canvas)\n        const y = height - (normalizedY * height);\n        points.push({ x, y });\n    }\n    return points;\n}\n\nexport function drawInternalGrid(svg, width, height, xGridStr, yGridStr) {\n    const gridGroup = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    gridGroup.setAttribute(\"stroke\", \"rgba(0,0,0,0.1)\");\n    gridGroup.setAttribute(\"stroke-dasharray\", \"2,2\");\n    gridGroup.setAttribute(\"stroke-width\", \"1\");\n\n    // Simple heuristic for grid lines if no specific interval is parsed\n    const xLines = 4;\n    const yLines = 4;\n\n    for (let i = 1; i < xLines; i++) {\n        const x = (i / xLines) * width;\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n        line.setAttribute(\"x1\", x);\n        line.setAttribute(\"y1\", 0);\n        line.setAttribute(\"x2\", x);\n        line.setAttribute(\"y2\", height);\n        gridGroup.appendChild(line);\n    }\n\n    for (let i = 1; i < yLines; i++) {\n        const y = (i / yLines) * height;\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n        line.setAttribute(\"x1\", 0);\n        line.setAttribute(\"y1\", y);\n        line.setAttribute(\"x2\", width);\n        line.setAttribute(\"y2\", y);\n        gridGroup.appendChild(line);\n    }\n\n    svg.appendChild(gridGroup);\n}\n\nexport function drawSmartAxisLabels(container, x, y, width, height, min, max, durationStr) {\n    // Remove existing axis labels first (from previous renders)\n    const existing = container.querySelectorAll('.graph-axis-label');\n    existing.forEach(el => el.remove());\n\n    // Y-Axis Labels (Left of graph)\n    const range = max - min;\n    const steps = 4; // Min, 25%, 50%, 75%, Max\n\n    // Get CANVAS_WIDTH - try multiple sources\n    const canvasWidth = (typeof CANVAS_WIDTH !== 'undefined') ? CANVAS_WIDTH :\n        (typeof window.CANVAS_WIDTH !== 'undefined') ? window.CANVAS_WIDTH : 800;\n\n    for (let i = 0; i <= steps; i++) {\n        const val = min + (range * (i / steps));\n        const labelY = y + height - ((i / steps) * height);\n\n        const div = document.createElement(\"div\");\n        div.className = \"graph-axis-label\";\n        div.style.position = \"absolute\";\n        div.style.right = `${(canvasWidth - x) + 4}px`; // Position to left of graph\n        div.style.top = `${labelY - 6}px`; // Center vertically\n        div.style.fontSize = \"10px\";\n        div.style.color = \"#666\";\n        div.style.textAlign = \"right\";\n        div.textContent = val.toFixed(1);\n        container.appendChild(div);\n    }\n\n    // X-Axis Labels (Below graph)\n    const durationSec = parseDuration(durationStr);\n    const xSteps = 2; // Start, Middle, End\n\n    for (let i = 0; i <= xSteps; i++) {\n        const ratio = i / xSteps;\n        const labelX = x + (width * ratio);\n\n        let labelText = \"\";\n        if (i === xSteps) labelText = \"Now\";\n        else {\n            const timeAgo = durationSec * (1 - ratio);\n            if (timeAgo >= 3600) labelText = `-${(timeAgo / 3600).toFixed(1)}h`;\n            else if (timeAgo >= 60) labelText = `-${(timeAgo / 60).toFixed(0)}m`;\n            else labelText = `-${timeAgo.toFixed(0)}s`;\n        }\n\n        const div = document.createElement(\"div\");\n        div.className = \"graph-axis-label\";\n        div.style.position = \"absolute\";\n        div.style.left = `${labelX}px`;\n        div.style.top = `${y + height + 4}px`; // Below graph\n        div.style.fontSize = \"10px\";\n        div.style.color = \"#666\";\n        div.style.transform = \"translateX(-50%)\";\n        div.textContent = labelText;\n        container.appendChild(div);\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\utils\\helpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\js\\utils\\logger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\core\\plugin_registry.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\features\\icon_plugin.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\features\\text_plugin.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\golden_master\\golden_payload.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\io\\esphome_adapter.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'name' is defined but never used. Allowed unused args must match /^_/u.","line":50,"column":29,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":33,"suggestions":[{"messageId":"removeVar","data":{"varName":"name"},"fix":{"range":[1491,1495],"text":""},"desc":"Remove unused variable 'name'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\r\nimport { ESPHomeAdapter } from '../../js/io/adapters/esphome_adapter.js';\r\n\r\nconst { mockRegistry } = vi.hoisted(() => ({\r\n    mockRegistry: {\r\n        get: vi.fn((type) => {\r\n            if (type === 'text') {\r\n                return {\r\n                    id: 'text',\r\n                    export: (w, ctx) => ctx.lines.push(`  - type: text\\n    content: \"${w.content}\"\\n    # id:${w.id}`)\r\n                };\r\n            }\r\n            return null;\r\n        }),\r\n        getAll: vi.fn(() => []),\r\n        load: vi.fn(async (type) => mockRegistry.get(type)),\r\n        onExportGlobals: vi.fn(),\r\n        onExportNumericSensors: vi.fn(),\r\n        onExportTextSensors: vi.fn(),\r\n        onExportBinarySensors: vi.fn(),\r\n        onExportComponents: vi.fn(),\r\n        onExportHelpers: vi.fn()\r\n    }\r\n}));\r\n\r\n// Top-level mocks for dependencies\r\nvi.mock('../../js/utils/logger.js', () => ({\r\n    Logger: {\r\n        log: vi.fn(),\r\n        error: vi.fn(),\r\n        warn: vi.fn(),\r\n        info: vi.fn()\r\n    }\r\n}));\r\n\r\nvi.mock('../../js/core/plugin_registry.js', () => ({\r\n    registry: mockRegistry\r\n}));\r\n\r\nvi.mock('../../js/core/state.js', () => ({\r\n    AppState: {\r\n        deviceModel: 'reterminal_e1001',\r\n        getCanvasDimensions: vi.fn(() => ({ width: 800, height: 480 })),\r\n        getCanvasShape: vi.fn(() => 'rect')\r\n    }\r\n}));\r\n\r\nvi.mock('../../js/core/utils.js', () => ({\r\n    Utils: {\r\n        getIconCode: vi.fn((name) => 'F000'),\r\n        getColorConst: vi.fn((c) => `Color(${c})`),\r\n        getAlignX: vi.fn((a, x) => x),\r\n        getAlignY: vi.fn((a, y) => y),\r\n        addDitherMask: vi.fn()\r\n    }\r\n}));\r\n\r\nvi.mock('../../js/io/devices.js', () => ({\r\n    DEVICE_PROFILES: {}\r\n}));\r\n\r\nvi.mock('../../js/io/hardware_generators.js', () => ({\r\n    generateI2CSection: vi.fn(() => []),\r\n    generateSPISection: vi.fn(() => []),\r\n    generateSensorSection: vi.fn(() => []),\r\n    generateBinarySensorSection: vi.fn(() => []),\r\n    generateButtonSection: vi.fn(() => []),\r\n    generateDisplaySection: vi.fn(() => [\"display:\"]),\r\n    generateExtraComponents: vi.fn(() => []),\r\n    generateAXP2101Section: vi.fn(() => []),\r\n    generateOutputSection: vi.fn(() => []),\r\n    generateBacklightSection: vi.fn(() => []),\r\n    generateRTTTLSection: vi.fn(() => []),\r\n    generateAudioSection: vi.fn(() => [])\r\n}));\r\n\r\nvi.mock('../../js/io/adapters/base_adapter.js', () => ({\r\n    BaseAdapter: class {\r\n        constructor() { }\r\n        async generate() { return \"\"; }\r\n        generatePage() { return []; }\r\n        generateWidget() { return []; }\r\n        sanitize(s) { return s; }\r\n    }\r\n}));\r\n\r\nvi.mock('../../js/core/constants.js', () => ({\r\n    COLORS: {},\r\n    ALIGNMENT: {}\r\n}));\r\n\r\nconst mockAppState = {\r\n    deviceModel: 'reterminal_e1001',\r\n    getCanvasDimensions: vi.fn(() => ({ width: 800, height: 480 })),\r\n    getCanvasShape: vi.fn(() => 'rect')\r\n};\r\n\r\ndescribe('ESPHomeAdapter', () => {\r\n    let adapter;\r\n\r\n    beforeEach(() => {\r\n        adapter = new ESPHomeAdapter();\r\n        global.PluginRegistry = mockRegistry;\r\n        window.PluginRegistry = mockRegistry;\r\n        global.AppState = mockAppState;\r\n        window.AppState = mockAppState;\r\n        window.LVGLExport = {\r\n            generateLVGLSnippet: vi.fn(() => []),\r\n            serializeWidget: vi.fn(() => '')\r\n        };\r\n        window.DEVICE_PROFILES = {\r\n            'reterminal_e1001': {\r\n                name: 'Test Device',\r\n                features: {},\r\n                pins: {},\r\n                battery: {\r\n                    attenuation: '12db',\r\n                    multiplier: 2.0\r\n                }\r\n            }\r\n        };\r\n        window.currentDeviceModel = 'reterminal_e1001';\r\n    });\r\n\r\n    it('should be instantiable', () => {\r\n        expect(adapter).toBeDefined();\r\n    });\r\n\r\n    it('should generate a basic YAML structure for a page', async () => {\r\n        const projectState = {\r\n            pages: [\r\n                {\r\n                    name: \"Main\",\r\n                    widgets: [\r\n                        { id: \"w1\", type: \"text\", content: \"Hello\" }\r\n                    ]\r\n                }\r\n            ],\r\n            deviceName: \"Test Device\"\r\n        };\r\n\r\n        const yaml = await adapter.generate(projectState);\r\n        expect(yaml).toContain('Test Device');\r\n        expect(yaml).toContain('Hello');\r\n        expect(yaml).toContain('id:w1'); // Metadata tag\r\n    });\r\n\r\n    it('should handle empty pages correctly', async () => {\r\n        const projectState = {\r\n            pages: [{ name: \"Empty\", widgets: [] }],\r\n            deviceName: \"Empty Device\"\r\n        };\r\n        const yaml = await adapter.generate(projectState);\r\n        expect(yaml).toContain('Test Device'); // From profile name\r\n        expect(yaml).toContain('// page:name \"Empty\"');\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\lasso_delete.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\legacy\\golden_master.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\legacy\\time_machine.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\setup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\stores\\editor_store.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'vi' is defined but never used.","line":1,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":46,"suggestions":[{"messageId":"removeVar","data":{"varName":"vi"},"fix":{"range":[41,45],"text":""},"desc":"Remove unused variable 'vi'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\r\nimport { EditorStore } from '../../js/core/stores/editor_store.js';\r\n\r\ndescribe('EditorStore', () => {\r\n    let store;\r\n\r\n    beforeEach(() => {\r\n        store = new EditorStore();\r\n    });\r\n\r\n    describe('Selection', () => {\r\n        it('should select a single widget', () => {\r\n            store.selectWidget('w1');\r\n            expect(store.selectedWidgetIds).toEqual(['w1']);\r\n        });\r\n\r\n        it('should toggle selection in multi-mode', () => {\r\n            store.selectWidget('w1', true);\r\n            expect(store.selectedWidgetIds).toEqual(['w1']);\r\n            store.selectWidget('w1', true);\r\n            expect(store.selectedWidgetIds).toEqual([]);\r\n        });\r\n    });\r\n\r\n    describe('Zoom', () => {\r\n        it('should clamp zoom level between 0.05 and 5.0', () => {\r\n            store.setZoomLevel(0.01);\r\n            expect(store.zoomLevel).toBe(0.05);\r\n            store.setZoomLevel(10.0);\r\n            expect(store.zoomLevel).toBe(5.0);\r\n            store.setZoomLevel(1.5);\r\n            expect(store.zoomLevel).toBe(1.5);\r\n        });\r\n    });\r\n\r\n    describe('History (Undo/Redo)', () => {\r\n        it('should record history snapshots', () => {\r\n            const state1 = { pages: [], deviceName: 'D1' };\r\n            store.recordHistory(state1);\r\n            expect(store.canUndo()).toBe(false); // First recording is base state\r\n\r\n            const state2 = { pages: [{ id: 1 }], deviceName: 'D2' };\r\n            store.recordHistory(state2);\r\n            expect(store.canUndo()).toBe(true);\r\n            expect(store.canRedo()).toBe(false);\r\n        });\r\n\r\n        it('should not record duplicate consecutive states', () => {\r\n            const state = { pages: [], deviceName: 'D1' };\r\n            store.recordHistory(state);\r\n            store.recordHistory(state);\r\n            expect(store.historyStack.length).toBe(1);\r\n        });\r\n\r\n        it('should undo and redo correctly', () => {\r\n            const s1 = { pages: [], deviceName: 'S1' };\r\n            const s2 = { pages: [], deviceName: 'S2' };\r\n\r\n            store.recordHistory(s1);\r\n            store.recordHistory(s2);\r\n\r\n            expect(store.undo()).toEqual(s1);\r\n            expect(store.canRedo()).toBe(true);\r\n            expect(store.redo()).toEqual(s2);\r\n        });\r\n\r\n        it('should truncate future on new change after undo', () => {\r\n            store.recordHistory({ n: 1 });\r\n            store.recordHistory({ n: 2 });\r\n            store.undo();\r\n            store.recordHistory({ n: 3 });\r\n\r\n            expect(store.canRedo()).toBe(false);\r\n            expect(store.historyStack.length).toBe(2);\r\n            expect(store.historyStack[1]).toEqual({ n: 3 });\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\stores\\preferences_store.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'vi' is defined but never used.","line":1,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":46,"suggestions":[{"messageId":"removeVar","data":{"varName":"vi"},"fix":{"range":[41,45],"text":""},"desc":"Remove unused variable 'vi'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\r\nimport { PreferencesStore } from '../../js/core/stores/preferences_store.js';\r\n\r\ndescribe('PreferencesStore', () => {\r\n    let store;\r\n\r\n    beforeEach(() => {\r\n        store = new PreferencesStore();\r\n    });\r\n\r\n    it('should initialize with default states', () => {\r\n        expect(store.snapEnabled).toBe(true);\r\n        expect(store.showGrid).toBe(true);\r\n    });\r\n\r\n    it('should update multiple settings at once', () => {\r\n        store.update({ snapEnabled: false, gridOpacity: 5 });\r\n        expect(store.snapEnabled).toBe(false);\r\n        expect(store.gridOpacity).toBe(5);\r\n    });\r\n\r\n    it('should set snap and grid individually', () => {\r\n        store.setSnapEnabled(false);\r\n        expect(store.snapEnabled).toBe(false);\r\n        store.setShowGrid(false);\r\n        expect(store.showGrid).toBe(false);\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\mail\\Downloads\\ESPHome_desinger\\Codebasecleanup\\0.9\\custom_components\\esphome_designer\\frontend\\tests\\stores\\project_store.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'vi' is defined but never used.","line":1,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":46,"suggestions":[{"messageId":"removeVar","data":{"varName":"vi"},"fix":{"range":[41,45],"text":""},"desc":"Remove unused variable 'vi'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\r\nimport { ProjectStore } from '../../js/core/stores/project_store.js';\r\n\r\ndescribe('ProjectStore', () => {\r\n    let store;\r\n\r\n    beforeEach(() => {\r\n        store = new ProjectStore();\r\n    });\r\n\r\n    describe('Initialization', () => {\r\n        it('should initialize with a default overview page', () => {\r\n            expect(store.pages.length).toBe(1);\r\n            expect(store.pages[0].name).toBe('Overview');\r\n        });\r\n    });\r\n\r\n    describe('Page Management', () => {\r\n        it('should change current page index correctly', () => {\r\n            store.setPages([\r\n                { id: 'p0', name: 'Page 0', widgets: [] },\r\n                { id: 'p1', name: 'Page 1', widgets: [] }\r\n            ]);\r\n            store.setCurrentPageIndex(1);\r\n            expect(store.currentPageIndex).toBe(1);\r\n            expect(store.getCurrentPage().id).toBe('p1');\r\n        });\r\n\r\n        it('should not change to out-of-bounds index', () => {\r\n            store.setCurrentPageIndex(5);\r\n            expect(store.currentPageIndex).toBe(0);\r\n        });\r\n    });\r\n\r\n    describe('Widget Operations', () => {\r\n        it('should add a widget and index it', () => {\r\n            const widget = { id: 'w1', type: 'text' };\r\n            store.addWidget(widget);\r\n            expect(store.pages[0].widgets).toContain(widget);\r\n            expect(store.getWidgetById('w1')).toBe(widget);\r\n        });\r\n\r\n        it('should update a widget', () => {\r\n            const widget = { id: 'w1', type: 'text', x: 0 };\r\n            store.addWidget(widget);\r\n            store.updateWidget('w1', { x: 10 });\r\n            expect(store.getWidgetById('w1').x).toBe(10);\r\n        });\r\n\r\n        it('should delete specified widgets', () => {\r\n            store.addWidget({ id: 'w1', type: 'text' });\r\n            store.addWidget({ id: 'w2', type: 'icon' });\r\n            store.deleteWidgets(['w1']);\r\n            expect(store.pages[0].widgets.length).toBe(1);\r\n            expect(store.getWidgetById('w1')).toBeUndefined();\r\n            expect(store.getWidgetById('w2')).toBeDefined();\r\n        });\r\n\r\n        it('should clear the current page', () => {\r\n            store.addWidget({ id: 'w1', type: 'text' });\r\n            store.addWidget({ id: 'w2', type: 'icon', locked: true });\r\n\r\n            const result = store.clearCurrentPage(true); // Preserve locked\r\n            expect(result.deleted).toBe(1);\r\n            expect(result.preserved).toBe(1);\r\n            expect(store.pages[0].widgets.length).toBe(1);\r\n            expect(store.getWidgetById('w1')).toBeUndefined();\r\n            expect(store.getWidgetById('w2')).toBeDefined();\r\n\r\n            store.clearCurrentPage(false); // don't preserve\r\n            expect(store.pages[0].widgets.length).toBe(0);\r\n            expect(store.getWidgetById('w2')).toBeUndefined();\r\n        });\r\n    });\r\n\r\n    describe('Device Settings', () => {\r\n        it('should update device settings and window global', () => {\r\n            store.setDeviceSettings('My Home', 'reterminal_e1002');\r\n            expect(store.deviceName).toBe('My Home');\r\n            expect(store.deviceModel).toBe('reterminal_e1002');\r\n            expect(window.currentDeviceModel).toBe('reterminal_e1002');\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[]}]
