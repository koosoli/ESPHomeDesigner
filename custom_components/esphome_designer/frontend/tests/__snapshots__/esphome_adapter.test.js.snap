// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ESPHomeAdapter Configuration Generation > matches the known good snapshot for a native custom LCD display 1`] = `
"# ============================================================================
# ESPHome YAML - Generated by ESPHome Designer
# ============================================================================
# TARGET DEVICE: Seeedstudio reTerminal E1001 (Monochrome)
#         - Display Platform: waveshare_epaper
#         - PSRAM: Yes
#         - Touchscreen: No
#         - Framework: ESP-IDF (Required for stable PSRAM/LVGL)
# ============================================================================
#
# SETUP INSTRUCTIONS:
#
# STEP 1: Copy the Material Design Icons font file
#         - From this repo: resources/fonts/materialdesignicons-webfont.ttf
#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf
#
# STEP 2: Create a new device in ESPHome
#         - Click "New Device"
#         - Select: ESP32-S3 (or appropriate for your board)
#         - Framework: ESP-IDF (Essential for S3 stability)
#
# STEP 3: PASTE this snippet into your device YAML
#         - Paste this snippet at the end of your configuration.
#         - System sections (esphome, esp32, psram) are auto-commented
#           to avoid conflicts with your existing base setup.
#
# CAPTIVE PORTAL:
#         - If WiFi connection fails, the device will create a hotspot.
#         - Search for its name in your WiFi settings.
#         - Connect and go to http://192.168.4.1 to configure WiFi.
#
# TIP: For reTerminal / S3 devices, if you cannot see logs via USB,
#      add this to your base 'logger:' section:
#      hardware_uart: USB_CDC
#
# ============================================================================

# ====================================
# Device Settings
# ====================================
# Orientation: landscape
# Dark Mode: disabled
# Refresh Interval: 600
# Power Strategy: Always On
# Deep Sleep Interval: 600
# ====================================

# esphome:
#   name: your-device-name
#   comment: 'Snippet generated by ESPHome Designer'
#   on_boot:
#     priority: 300
#     then:
#       - output.turn_on: bsp_battery_enable
#       - delay: 2s
#       - script.execute: manage_run_and_sleep
#
# esp32:
#   board: esp32-s3-devkitc-1
#   framework:
#     type: esp-idf
#     sdkconfig_options:
#       CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: y
#       CONFIG_ESP32S3_DATA_CACHE_64KB: y
#
# logger:
#   hardware_uart: USB_CDC # Enable for USB debugging on S3
#   level: DEBUG
#
# api:
# ota:
# wifi:
#   # ... your wifi config here


globals:
  - id: display_page
    type: int
    restore_value: false
    initial_value: '0'
  - id: page_refresh_default_s
    type: int
    restore_value: true
    initial_value: '600'
  - id: page_refresh_current_s
    type: int
    restore_value: false
    initial_value: '60'
  - id: last_page_switch_time
    type: uint32_t
    restore_value: false
    initial_value: '0'
psram:
  mode: octal
  speed: 80MHz

http_request:
  verify_ssl: false
  timeout: 20s
  buffer_size_rx: 4096
i2c:
  - sda: GPIO19
    scl: GPIO20
    scan: true
    id: bus_a

spi:
  - id: spi_bus
    clk_pin: GPIO7
    mosi_pin: GPIO9

output:
  - platform: gpio
    pin: GPIO21
    id: bsp_battery_enable

  - platform: ledc
    pin: GPIO45
    id: buzzer_output

rtttl:
  id: reterminal_buzzer
  output: buzzer_output

time:
  - platform: homeassistant
    id: ha_time
sensor:
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2
  - platform: sht4x
    id: sht4x_sensor
    temperature:
      name: "Temperature"
      id: sht4x_temperature
    humidity:
      name: "Humidity"
      id: sht4x_humidity
    address: 0x44
    update_interval: 60s

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    icon: "mdi:battery"
    device_class: battery
    state_class: measurement
    lambda: |-
      if (id(battery_voltage).state > 4.15) return 100;
      if (id(battery_voltage).state < 3.27) return 0;
      return (id(battery_voltage).state - 3.27) / (4.15 - 3.27) * 100.0;

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "Left Button"
    id: button_left
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) > 0 ? id(display_page) - 1 : 0;'
  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      inverted: true
    name: "Right Button"
    id: button_right
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) < 0 ? id(display_page) + 1 : 0;'
  - platform: gpio
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true
    name: "Refresh Button"
    id: button_refresh
    on_press:
      then:
        - component.update: epaper_display
  - platform: gpio
    pin:
      number: GPIO2
      mode: INPUT_PULLUP
      inverted: true
    name: "Home Button"
    id: button_home
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: 0
        - script.execute: manage_run_and_sleep

button:
  - platform: template
    name: "Next Page"
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) + 1;'
  - platform: template
    name: "Previous Page"
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) - 1;'
  - platform: template
    name: "Refresh Display"
    on_press:
      then:
        - component.update: epaper_display
  - platform: template
    name: "Go to Page 1"
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: 0
  # Buzzer Sounds
  - platform: template
    name: "Play Beep Short"
    icon: "mdi:bell-ring"
    on_press:
      - rtttl.play: "beep:d=32,o=5,b=200:16e6"

  - platform: template
    name: "Play Beep OK"
    icon: "mdi:check-circle-outline"
    on_press:
      - rtttl.play: "ok:d=16,o=5,b=200:e6"

  - platform: template
    name: "Play Beep Error"
    icon: "mdi:alert-circle-outline"
    on_press:
      - rtttl.play: "error:d=16,o=5,b=200:c6"

  - platform: template
    name: "Play Star Wars"
    icon: "mdi:music-note"
    on_press:
      - rtttl.play: "StarWars:d=4,o=5,b=45:32p,32f,32f,32f,8a#.,8f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32d#,8c6"

font:
  - file:
      type: gfonts
      family: "Roboto"
      weight: 400
      italic: false
    id: font_roboto_400_20
    size: 20
    glyphs: ["\\U00000020", "\\U00000021", "\\U00000022", "\\U00000023", "\\U00000024", "\\U00000025", "\\U00000026", "\\U00000027", "\\U00000028", "\\U00000029", "\\U0000002A", "\\U0000002B", "\\U0000002C", "\\U0000002D", "\\U0000002E", "\\U0000002F", "\\U00000030", "\\U00000031", "\\U00000032", "\\U00000033", "\\U00000034", "\\U00000035", "\\U00000036", "\\U00000037", "\\U00000038", "\\U00000039", "\\U0000003A", "\\U0000003B", "\\U0000003C", "\\U0000003D", "\\U0000003E", "\\U0000003F", "\\U00000040", "\\U00000041", "\\U00000042", "\\U00000043", "\\U00000044", "\\U00000045", "\\U00000046", "\\U00000047", "\\U00000048", "\\U00000049", "\\U0000004A", "\\U0000004B", "\\U0000004C", "\\U0000004D", "\\U0000004E", "\\U0000004F", "\\U00000050", "\\U00000051", "\\U00000052", "\\U00000053", "\\U00000054", "\\U00000055", "\\U00000056", "\\U00000057", "\\U00000058", "\\U00000059", "\\U0000005A", "\\U0000005B", "\\U0000005C", "\\U0000005D", "\\U0000005E", "\\U0000005F", "\\U00000060", "\\U00000061", "\\U00000062", "\\U00000063", "\\U00000064", "\\U00000065", "\\U00000066", "\\U00000067", "\\U00000068", "\\U00000069", "\\U0000006A", "\\U0000006B", "\\U0000006C", "\\U0000006D", "\\U0000006E", "\\U0000006F", "\\U00000070", "\\U00000071", "\\U00000072", "\\U00000073", "\\U00000074", "\\U00000075", "\\U00000076", "\\U00000077", "\\U00000078", "\\U00000079", "\\U0000007A", "\\U0000007B", "\\U0000007C", "\\U0000007D", "\\U0000007E", "\\U000000A0", "\\U000000A1", "\\U000000A2", "\\U000000A3", "\\U000000A4", "\\U000000A5", "\\U000000A6", "\\U000000A7", "\\U000000A8", "\\U000000A9", "\\U000000AA", "\\U000000AB", "\\U000000AC", "\\U000000AD", "\\U000000AE", "\\U000000AF", "\\U000000B0", "\\U000000B1", "\\U000000B2", "\\U000000B3", "\\U000000B4", "\\U000000B5", "\\U000000B6", "\\U000000B7", "\\U000000B8", "\\U000000B9", "\\U000000BA", "\\U000000BB", "\\U000000BC", "\\U000000BD", "\\U000000BE", "\\U000000BF", "\\U000000C0", "\\U000000C1", "\\U000000C2", "\\U000000C3", "\\U000000C4", "\\U000000C5", "\\U000000C6", "\\U000000C7", "\\U000000C8", "\\U000000C9", "\\U000000CA", "\\U000000CB", "\\U000000CC", "\\U000000CD", "\\U000000CE", "\\U000000CF", "\\U000000D0", "\\U000000D1", "\\U000000D2", "\\U000000D3", "\\U000000D4", "\\U000000D5", "\\U000000D6", "\\U000000D7", "\\U000000D8", "\\U000000D9", "\\U000000DA", "\\U000000DB", "\\U000000DC", "\\U000000DD", "\\U000000DE", "\\U000000DF", "\\U000000E0", "\\U000000E1", "\\U000000E2", "\\U000000E3", "\\U000000E4", "\\U000000E5", "\\U000000E6", "\\U000000E7", "\\U000000E8", "\\U000000E9", "\\U000000EA", "\\U000000EB", "\\U000000EC", "\\U000000ED", "\\U000000EE", "\\U000000EF", "\\U000000F0", "\\U000000F1", "\\U000000F2", "\\U000000F3", "\\U000000F4", "\\U000000F5", "\\U000000F6", "\\U000000F7", "\\U000000F8", "\\U000000F9", "\\U000000FA", "\\U000000FB", "\\U000000FC", "\\U000000FD", "\\U000000FE", "\\U000000FF", "\\U000003BC", "\\U000003A9", "\\U000020AC", "\\U00002122"]
script:
  - id: change_page_to
    parameters:
      target_page: int
    then:
      - lambda: |-
          int pages_count = 1;
          int target = target_page;
          while (target < 0) target += pages_count;
          target %= pages_count;

          // Debounce: Ignore page changes within 3000ms of last change
          // (adjusted for e-paper display update time)
          uint32_t now = millis();
          if (now - id(last_page_switch_time) < 3000) {
            ESP_LOGD("display", "Page change ignored (debounce), last switch was %d ms ago", now - id(last_page_switch_time));
            return;
          }

          if (id(display_page) != target) {
            // Set debounce time BEFORE display update (update takes ~1.6s)
            id(last_page_switch_time) = now;
            id(display_page) = target;
            id(epaper_display).update();
            ESP_LOGI("display", "Switched to page %d", target);
            // Restart refresh logic
            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();
            id(manage_run_and_sleep).execute();
          }

  - id: manage_run_and_sleep
    mode: restart
    then:
      - logger.log: "Waiting for sync..."
      - wait_until:
          condition:
            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'
          timeout: 120s
      - delay: 5s
      - lambda: |-
          int p = id(display_page);
          int interval = id(page_refresh_default_s);
          bool is_sleep_time = false;
          auto time = id(ha_time).now();
          if (time.is_valid()) {
             int hour = time.hour;
             int minute = time.minute;
             int curr_min = hour * 60 + minute;
             int start = 0;
             int end = 0;
             if (start < end) {
                 if (hour >= start && hour < end) is_sleep_time = true;
             } else if (start > end) {
                 if (hour >= start || hour < end) is_sleep_time = true;
             }

             // Visibility Logic: Find best page for current time
             int best_page = -1;
             if (best_page == -1) best_page = 0;

             // If current page is invisible OR another should be shown, switch
             if (best_page != -1 && best_page != p) {
                 ESP_LOGI("display", "Auto-switching to scheduled page %d", best_page);
                 id(change_page_to).execute(best_page);
                 return;
             }
          }
          if (!is_sleep_time) {
          }
          id(page_refresh_current_s) = interval;
      - component.update: epaper_display
      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'
      - script.execute: manage_run_and_sleep
display:
  - platform: waveshare_epaper
    id: epaper_display
    cs_pin: GPIO10
    dc_pin: GPIO11
    reset_pin:
      number: GPIO12
      inverted: false
    busy_pin:
      number: GPIO13
      inverted: true
    model: "7.50inv2p"
    rotation: 0
    update_interval: never
    full_update_every: 30

    lambda: |-
      const auto COLOR_WHITE = Color(0, 0, 0); // Inverted for e-ink
      const auto COLOR_BLACK = Color(255, 255, 255); // Inverted for e-ink
      const auto COLOR_RED = Color(255, 0, 0);
      const auto COLOR_GREEN = Color(0, 255, 0);
      const auto COLOR_BLUE = Color(0, 0, 255);
      const auto COLOR_YELLOW = Color(255, 255, 0);
      const auto COLOR_ORANGE = Color(255, 165, 0);
      auto color_off = COLOR_WHITE;
      auto color_on = COLOR_BLACK;

      // Helper to print text with word-wrap at widget boundary
      auto print_wrapped_text = [&](int x, int y, int max_w, int line_h, esphome::font::Font *font, Color color, TextAlign align, const char* text) {
        if (!text || max_w <= 0) return;
        int cx = x;
        int cy = y;
        std::string line;
        std::string word;
        const char* p = text;
        while (*p) {
          // SANITIZATION: Treat newlines, carriage returns, and tabs as spaces for flow
          bool is_space = (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t');
          if (is_space) {
            if (!word.empty()) {
              int ww, wh, wbl, wx;
              font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
              int lw = 0, lx;
              if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
              if (lw + ww > max_w && !line.empty()) {
                it.print(cx, cy, font, color, align, line.c_str());
                cy += line_h;
                line = word;
              } else {
                if (!line.empty()) line += " ";
                line += word;
              }
              word.clear();
            }
          } else {
            word += *p;
          }
          p++;
        }
        if (!word.empty()) {
          int ww, wh, wbl, wx;
          font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
          int lw = 0, lx;
          if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
          if (lw + ww > max_w && !line.empty()) {
            it.print(cx, cy, font, color, align, line.c_str());
            cy += line_h;
            line = word;
          } else {
            if (!line.empty()) line += " ";
            line += word;
          }
        }
        if (!line.empty()) {
          it.print(cx, cy, font, color, align, line.c_str());
        }
      };

      // Helper to apply a simple grey dither mask for e-paper (checkerboard)
      auto apply_grey_dither_mask = [&](int x_start, int y_start, int w, int h) {
        for (int y = y_start; y < y_start + h; y++) {
          for (int x = x_start; x < x_start + w; x++) {
            if ((x + y) % 2 == 0) it.draw_pixel_at(x, y, COLOR_WHITE);
            else it.draw_pixel_at(x, y, COLOR_BLACK);
          }
        }
      };

      // Helper to apply grey dither to text (subtractive - erases every other black pixel)
      auto apply_grey_dither_to_text = [&](int x_start, int y_start, int w, int h) {
        for (int y = y_start; y < y_start + h; y++) {
          for (int x = x_start; x < x_start + w; x++) {
            if ((x + y) % 2 == 0) it.draw_pixel_at(x, y, COLOR_WHITE);
          }
        }
      };
      int currentPage = id(display_page);
      // ═══════════════════════════════════════════════════════════════
      // ▸ PAGE: Main Page
      // ═══════════════════════════════════════════════════════════════
      if (currentPage == 0) {
        // page:name "Main Page"
        // page:dark_mode "inherit"
        // page:refresh_type "interval"
        // page:refresh_time ""
        // page:visible_from ""
        // page:visible_to ""
        // Clear screen for this page
        it.fill(COLOR_WHITE);
        color_off = COLOR_WHITE;
        color_on = COLOR_BLACK;
        // widget:text id:widget_1 type:text x:10 y:20 w:100 h:30 align:TOP_LEFT text:"Text"
        it.printf(10, 20, id(font_roboto_400_20), color_on, TextAlign::TOP_LEFT, "Text");
      }"
`;

exports[`ESPHomeAdapter Configuration Generation > matches the known good snapshot for an LVGL configured display 1`] = `
"# ============================================================================
# ESPHome YAML - Generated by ESPHome Designer
# ============================================================================
# TARGET DEVICE: Seeedstudio reTerminal E1001 (Monochrome)
#         - Display Platform: waveshare_epaper
#         - PSRAM: Yes
#         - Touchscreen: No
#         - Framework: ESP-IDF (Required for stable PSRAM/LVGL)
# ============================================================================
#
# SETUP INSTRUCTIONS:
#
# STEP 1: Copy the Material Design Icons font file
#         - From this repo: resources/fonts/materialdesignicons-webfont.ttf
#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf
#
# STEP 2: Create a new device in ESPHome
#         - Click "New Device"
#         - Select: ESP32-S3 (or appropriate for your board)
#         - Framework: ESP-IDF (Essential for S3 stability)
#
# STEP 3: PASTE this snippet into your device YAML
#         - Paste this snippet at the end of your configuration.
#         - System sections (esphome, esp32, psram) are auto-commented
#           to avoid conflicts with your existing base setup.
#
# CAPTIVE PORTAL:
#         - If WiFi connection fails, the device will create a hotspot.
#         - Search for its name in your WiFi settings.
#         - Connect and go to http://192.168.4.1 to configure WiFi.
#
# TIP: For reTerminal / S3 devices, if you cannot see logs via USB,
#      add this to your base 'logger:' section:
#      hardware_uart: USB_CDC
#
# ============================================================================

# ====================================
# Device Settings
# ====================================
# Orientation: landscape
# Dark Mode: disabled
# Refresh Interval: 600
# Power Strategy: Always On
# Deep Sleep Interval: 600
# ====================================

# esphome:
#   name: your-device-name
#   comment: 'Snippet generated by ESPHome Designer'
#   on_boot:
#     priority: 300
#     then:
#       - output.turn_on: bsp_battery_enable
#       - delay: 2s
#       - script.execute: manage_run_and_sleep
#
# esp32:
#   board: esp32-s3-devkitc-1
#   framework:
#     type: esp-idf
#     sdkconfig_options:
#       CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: y
#       CONFIG_ESP32S3_DATA_CACHE_64KB: y
#
# logger:
#   hardware_uart: USB_CDC # Enable for USB debugging on S3
#   level: DEBUG
#
# api:
# ota:
# wifi:
#   # ... your wifi config here


globals:
  - id: display_page
    type: int
    restore_value: false
    initial_value: '0'
  - id: page_refresh_default_s
    type: int
    restore_value: true
    initial_value: '600'
  - id: page_refresh_current_s
    type: int
    restore_value: false
    initial_value: '60'
  - id: last_page_switch_time
    type: uint32_t
    restore_value: false
    initial_value: '0'
psram:
  mode: octal
  speed: 80MHz

http_request:
  verify_ssl: false
  timeout: 20s
  buffer_size_rx: 4096
i2c:
  - sda: GPIO19
    scl: GPIO20
    scan: true
    id: bus_a

spi:
  - id: spi_bus
    clk_pin: GPIO7
    mosi_pin: GPIO9

output:
  - platform: gpio
    pin: GPIO21
    id: bsp_battery_enable

  - platform: ledc
    pin: GPIO45
    id: buzzer_output

rtttl:
  id: reterminal_buzzer
  output: buzzer_output

time:
  - platform: homeassistant
    id: ha_time
sensor:
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2
  - platform: sht4x
    id: sht4x_sensor
    temperature:
      name: "Temperature"
      id: sht4x_temperature
    humidity:
      name: "Humidity"
      id: sht4x_humidity
    address: 0x44
    update_interval: 60s

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    icon: "mdi:battery"
    device_class: battery
    state_class: measurement
    lambda: |-
      if (id(battery_voltage).state > 4.15) return 100;
      if (id(battery_voltage).state < 3.27) return 0;
      return (id(battery_voltage).state - 3.27) / (4.15 - 3.27) * 100.0;

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "Left Button"
    id: button_left
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) > 0 ? id(display_page) - 1 : 0;'
  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      inverted: true
    name: "Right Button"
    id: button_right
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) < 0 ? id(display_page) + 1 : 0;'
  - platform: gpio
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true
    name: "Refresh Button"
    id: button_refresh
    on_press:
      then:
        - component.update: epaper_display
  - platform: gpio
    pin:
      number: GPIO2
      mode: INPUT_PULLUP
      inverted: true
    name: "Home Button"
    id: button_home
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: 0
        - script.execute: manage_run_and_sleep

button:
  - platform: template
    name: "Next Page"
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) + 1;'
  - platform: template
    name: "Previous Page"
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: !lambda 'return id(display_page) - 1;'
  - platform: template
    name: "Refresh Display"
    on_press:
      then:
        - component.update: epaper_display
  - platform: template
    name: "Go to Page 1"
    on_press:
      then:
        - script.execute:
            id: change_page_to
            target_page: 0
  # Buzzer Sounds
  - platform: template
    name: "Play Beep Short"
    icon: "mdi:bell-ring"
    on_press:
      - rtttl.play: "beep:d=32,o=5,b=200:16e6"

  - platform: template
    name: "Play Beep OK"
    icon: "mdi:check-circle-outline"
    on_press:
      - rtttl.play: "ok:d=16,o=5,b=200:e6"

  - platform: template
    name: "Play Beep Error"
    icon: "mdi:alert-circle-outline"
    on_press:
      - rtttl.play: "error:d=16,o=5,b=200:c6"

  - platform: template
    name: "Play Star Wars"
    icon: "mdi:music-note"
    on_press:
      - rtttl.play: "StarWars:d=4,o=5,b=45:32p,32f,32f,32f,8a#.,8f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32d#,8c6"

font:
  - file:
      type: gfonts
      family: "Roboto"
      weight: 400
      italic: false
    id: font_roboto_400_20
    size: 20
    glyphs: ["\\U00000020", "\\U00000021", "\\U00000022", "\\U00000023", "\\U00000024", "\\U00000025", "\\U00000026", "\\U00000027", "\\U00000028", "\\U00000029", "\\U0000002A", "\\U0000002B", "\\U0000002C", "\\U0000002D", "\\U0000002E", "\\U0000002F", "\\U00000030", "\\U00000031", "\\U00000032", "\\U00000033", "\\U00000034", "\\U00000035", "\\U00000036", "\\U00000037", "\\U00000038", "\\U00000039", "\\U0000003A", "\\U0000003B", "\\U0000003C", "\\U0000003D", "\\U0000003E", "\\U0000003F", "\\U00000040", "\\U00000041", "\\U00000042", "\\U00000043", "\\U00000044", "\\U00000045", "\\U00000046", "\\U00000047", "\\U00000048", "\\U00000049", "\\U0000004A", "\\U0000004B", "\\U0000004C", "\\U0000004D", "\\U0000004E", "\\U0000004F", "\\U00000050", "\\U00000051", "\\U00000052", "\\U00000053", "\\U00000054", "\\U00000055", "\\U00000056", "\\U00000057", "\\U00000058", "\\U00000059", "\\U0000005A", "\\U0000005B", "\\U0000005C", "\\U0000005D", "\\U0000005E", "\\U0000005F", "\\U00000060", "\\U00000061", "\\U00000062", "\\U00000063", "\\U00000064", "\\U00000065", "\\U00000066", "\\U00000067", "\\U00000068", "\\U00000069", "\\U0000006A", "\\U0000006B", "\\U0000006C", "\\U0000006D", "\\U0000006E", "\\U0000006F", "\\U00000070", "\\U00000071", "\\U00000072", "\\U00000073", "\\U00000074", "\\U00000075", "\\U00000076", "\\U00000077", "\\U00000078", "\\U00000079", "\\U0000007A", "\\U0000007B", "\\U0000007C", "\\U0000007D", "\\U0000007E", "\\U000000A0", "\\U000000A1", "\\U000000A2", "\\U000000A3", "\\U000000A4", "\\U000000A5", "\\U000000A6", "\\U000000A7", "\\U000000A8", "\\U000000A9", "\\U000000AA", "\\U000000AB", "\\U000000AC", "\\U000000AD", "\\U000000AE", "\\U000000AF", "\\U000000B0", "\\U000000B1", "\\U000000B2", "\\U000000B3", "\\U000000B4", "\\U000000B5", "\\U000000B6", "\\U000000B7", "\\U000000B8", "\\U000000B9", "\\U000000BA", "\\U000000BB", "\\U000000BC", "\\U000000BD", "\\U000000BE", "\\U000000BF", "\\U000000C0", "\\U000000C1", "\\U000000C2", "\\U000000C3", "\\U000000C4", "\\U000000C5", "\\U000000C6", "\\U000000C7", "\\U000000C8", "\\U000000C9", "\\U000000CA", "\\U000000CB", "\\U000000CC", "\\U000000CD", "\\U000000CE", "\\U000000CF", "\\U000000D0", "\\U000000D1", "\\U000000D2", "\\U000000D3", "\\U000000D4", "\\U000000D5", "\\U000000D6", "\\U000000D7", "\\U000000D8", "\\U000000D9", "\\U000000DA", "\\U000000DB", "\\U000000DC", "\\U000000DD", "\\U000000DE", "\\U000000DF", "\\U000000E0", "\\U000000E1", "\\U000000E2", "\\U000000E3", "\\U000000E4", "\\U000000E5", "\\U000000E6", "\\U000000E7", "\\U000000E8", "\\U000000E9", "\\U000000EA", "\\U000000EB", "\\U000000EC", "\\U000000ED", "\\U000000EE", "\\U000000EF", "\\U000000F0", "\\U000000F1", "\\U000000F2", "\\U000000F3", "\\U000000F4", "\\U000000F5", "\\U000000F6", "\\U000000F7", "\\U000000F8", "\\U000000F9", "\\U000000FA", "\\U000000FB", "\\U000000FC", "\\U000000FD", "\\U000000FE", "\\U000000FF", "\\U000003BC", "\\U000003A9", "\\U000020AC", "\\U00002122"]
script:
  - id: change_page_to
    parameters:
      target_page: int
    then:
      - lambda: |-
          int pages_count = 1;
          int target = target_page;
          while (target < 0) target += pages_count;
          target %= pages_count;

          // Debounce: Ignore page changes within 3000ms of last change
          // (adjusted for e-paper display update time)
          uint32_t now = millis();
          if (now - id(last_page_switch_time) < 3000) {
            ESP_LOGD("display", "Page change ignored (debounce), last switch was %d ms ago", now - id(last_page_switch_time));
            return;
          }

          if (id(display_page) != target) {
            // Set debounce time BEFORE display update (update takes ~1.6s)
            id(last_page_switch_time) = now;
            id(display_page) = target;
            id(epaper_display).update();
            ESP_LOGI("display", "Switched to page %d", target);
            // Restart refresh logic
            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();
            id(manage_run_and_sleep).execute();
          }

  - id: manage_run_and_sleep
    mode: restart
    then:
      - logger.log: "Waiting for sync..."
      - wait_until:
          condition:
            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'
          timeout: 120s
      - delay: 5s
      - lambda: |-
          int p = id(display_page);
          int interval = id(page_refresh_default_s);
          bool is_sleep_time = false;
          auto time = id(ha_time).now();
          if (time.is_valid()) {
             int hour = time.hour;
             int minute = time.minute;
             int curr_min = hour * 60 + minute;
             int start = 0;
             int end = 0;
             if (start < end) {
                 if (hour >= start && hour < end) is_sleep_time = true;
             } else if (start > end) {
                 if (hour >= start || hour < end) is_sleep_time = true;
             }

             // Visibility Logic: Find best page for current time
             int best_page = -1;
             if (best_page == -1) best_page = 0;

             // If current page is invisible OR another should be shown, switch
             if (best_page != -1 && best_page != p) {
                 ESP_LOGI("display", "Auto-switching to scheduled page %d", best_page);
                 id(change_page_to).execute(best_page);
                 return;
             }
          }
          if (!is_sleep_time) {
          }
          id(page_refresh_current_s) = interval;
      - component.update: epaper_display
      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'
      - script.execute: manage_run_and_sleep
display:
  - platform: waveshare_epaper
    id: epaper_display
    cs_pin: GPIO10
    dc_pin: GPIO11
    reset_pin:
      number: GPIO12
      inverted: false
    busy_pin:
      number: GPIO13
      inverted: true
    model: "7.50inv2p"
    rotation: 0
    update_interval: never
    full_update_every: 30

    lambda: |-
      const auto COLOR_WHITE = Color(0, 0, 0); // Inverted for e-ink
      const auto COLOR_BLACK = Color(255, 255, 255); // Inverted for e-ink
      const auto COLOR_RED = Color(255, 0, 0);
      const auto COLOR_GREEN = Color(0, 255, 0);
      const auto COLOR_BLUE = Color(0, 0, 255);
      const auto COLOR_YELLOW = Color(255, 255, 0);
      const auto COLOR_ORANGE = Color(255, 165, 0);
      auto color_off = COLOR_WHITE;
      auto color_on = COLOR_BLACK;

      // Helper to print text with word-wrap at widget boundary
      auto print_wrapped_text = [&](int x, int y, int max_w, int line_h, esphome::font::Font *font, Color color, TextAlign align, const char* text) {
        if (!text || max_w <= 0) return;
        int cx = x;
        int cy = y;
        std::string line;
        std::string word;
        const char* p = text;
        while (*p) {
          // SANITIZATION: Treat newlines, carriage returns, and tabs as spaces for flow
          bool is_space = (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t');
          if (is_space) {
            if (!word.empty()) {
              int ww, wh, wbl, wx;
              font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
              int lw = 0, lx;
              if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
              if (lw + ww > max_w && !line.empty()) {
                it.print(cx, cy, font, color, align, line.c_str());
                cy += line_h;
                line = word;
              } else {
                if (!line.empty()) line += " ";
                line += word;
              }
              word.clear();
            }
          } else {
            word += *p;
          }
          p++;
        }
        if (!word.empty()) {
          int ww, wh, wbl, wx;
          font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
          int lw = 0, lx;
          if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
          if (lw + ww > max_w && !line.empty()) {
            it.print(cx, cy, font, color, align, line.c_str());
            cy += line_h;
            line = word;
          } else {
            if (!line.empty()) line += " ";
            line += word;
          }
        }
        if (!line.empty()) {
          it.print(cx, cy, font, color, align, line.c_str());
        }
      };

      // Helper to apply a simple grey dither mask for e-paper (checkerboard)
      auto apply_grey_dither_mask = [&](int x_start, int y_start, int w, int h) {
        for (int y = y_start; y < y_start + h; y++) {
          for (int x = x_start; x < x_start + w; x++) {
            if ((x + y) % 2 == 0) it.draw_pixel_at(x, y, COLOR_WHITE);
            else it.draw_pixel_at(x, y, COLOR_BLACK);
          }
        }
      };

      // Helper to apply grey dither to text (subtractive - erases every other black pixel)
      auto apply_grey_dither_to_text = [&](int x_start, int y_start, int w, int h) {
        for (int y = y_start; y < y_start + h; y++) {
          for (int x = x_start; x < x_start + w; x++) {
            if ((x + y) % 2 == 0) it.draw_pixel_at(x, y, COLOR_WHITE);
          }
        }
      };
      int currentPage = id(display_page);
      // ═══════════════════════════════════════════════════════════════
      // ▸ PAGE: Main Page
      // ═══════════════════════════════════════════════════════════════
      if (currentPage == 0) {
        // page:name "Main Page"
        // page:dark_mode "inherit"
        // page:refresh_type "interval"
        // page:refresh_time ""
        // page:visible_from ""
        // page:visible_to ""
        // Clear screen for this page
        it.fill(COLOR_WHITE);
        color_off = COLOR_WHITE;
        color_on = COLOR_BLACK;
        // widget:text id:widget_1 type:text x:10 y:20 w:100 h:30 align:TOP_LEFT text:"Text"
        it.printf(10, 20, id(font_roboto_400_20), color_on, TextAlign::TOP_LEFT, "Text");
      }"
`;
