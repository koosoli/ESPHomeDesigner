// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ESPHomeAdapter > End-to-End Golden Master Snapshots > generates a full multi-page native layout accurately 1`] = `
"# ============================================================================
# ESPHome YAML - Generated by ESPHome Designer
# ============================================================================
# TARGET DEVICE: Test Device
#         - Display Platform: Unknown
#         - PSRAM: No
#         - Touchscreen: No
#         - Framework: esp-idf (Recommended)
# ============================================================================
#
# SETUP INSTRUCTIONS:
#
# STEP 1: Copy the Material Design Icons font file
#         - From this repo: resources/fonts/materialdesignicons-webfont.ttf
#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf
#
# STEP 2: Create a new device in ESPHome
#         - Click "New Device"
#         - Select: ESP32-S3 (or appropriate for your board)
#         - Framework: ESP-IDF (Essential for S3 stability)
#
# STEP 3: PASTE this snippet into your device YAML
#         - Paste this snippet at the end of your configuration.
#         - System sections (esphome, esp32, psram) are auto-commented
#           to avoid conflicts with your existing base setup.
#
# CAPTIVE PORTAL:
#         - If WiFi connection fails, the device will create a hotspot.
#         - Search for its name in your WiFi settings.
#         - Connect and go to http://192.168.4.1 to configure WiFi.
#
# TIP: For reTerminal / S3 devices, if you cannot see logs via USB,
#      add this to your base 'logger:' section:
#      hardware_uart: USB_CDC
#
# ============================================================================

# ====================================
# Device Settings
# ====================================
# Orientation: landscape
# Dark Mode: disabled
# Refresh Interval: 600
# Power Strategy: Always On
# Deep Sleep Interval: 600
# ====================================

# esphome:
#   name: your-device-name
#   comment: 'Snippet generated by ESPHome Designer'
#   on_boot:
#     priority: 300
#     then:
#       - delay: 2s
#       - script.execute: manage_run_and_sleep
#
# esp32:
#   board: esp32-s3-devkitc-1
#   framework:
#     type: esp-idf
#     sdkconfig_options:
#       CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: y
#       CONFIG_ESP32S3_DATA_CACHE_64KB: y
#
# logger:
#   hardware_uart: USB_CDC # Enable for USB debugging on S3
#   level: DEBUG
#
# api:
# ota:
# wifi:
#   # ... your wifi config here


globals:
  - id: display_page
    type: int
    restore_value: false
    initial_value: '0'
  - id: page_refresh_default_s
    type: int
    restore_value: true
    initial_value: '60'
  - id: page_refresh_current_s
    type: int
    restore_value: false
    initial_value: '60'
  - id: last_page_switch_time
    type: uint32_t
    restore_value: false
    initial_value: '0'
http_request:
  verify_ssl: false
  timeout: 20s
  buffer_size_rx: 4096
time:
  - platform: homeassistant
    id: ha_time
binary_sensor:
  - platform: homeassistant
    id: light_living_room
    entity_id: light.living_room
    internal: true
font:
  - file:
      type: gfonts
      family: "Roboto"
      weight: 400
      italic: false
    id: font_roboto_400_20
    size: 20
    glyphs: ["\\U00000020", "\\U00000021", "\\U00000022", "\\U00000023", "\\U00000024", "\\U00000025", "\\U00000026", "\\U00000027", "\\U00000028", "\\U00000029", "\\U0000002A", "\\U0000002B", "\\U0000002C", "\\U0000002D", "\\U0000002E", "\\U0000002F", "\\U00000030", "\\U00000031", "\\U00000032", "\\U00000033", "\\U00000034", "\\U00000035", "\\U00000036", "\\U00000037", "\\U00000038", "\\U00000039", "\\U0000003A", "\\U0000003B", "\\U0000003C", "\\U0000003D", "\\U0000003E", "\\U0000003F", "\\U00000040", "\\U00000041", "\\U00000042", "\\U00000043", "\\U00000044", "\\U00000045", "\\U00000046", "\\U00000047", "\\U00000048", "\\U00000049", "\\U0000004A", "\\U0000004B", "\\U0000004C", "\\U0000004D", "\\U0000004E", "\\U0000004F", "\\U00000050", "\\U00000051", "\\U00000052", "\\U00000053", "\\U00000054", "\\U00000055", "\\U00000056", "\\U00000057", "\\U00000058", "\\U00000059", "\\U0000005A", "\\U0000005B", "\\U0000005C", "\\U0000005D", "\\U0000005E", "\\U0000005F", "\\U00000060", "\\U00000061", "\\U00000062", "\\U00000063", "\\U00000064", "\\U00000065", "\\U00000066", "\\U00000067", "\\U00000068", "\\U00000069", "\\U0000006A", "\\U0000006B", "\\U0000006C", "\\U0000006D", "\\U0000006E", "\\U0000006F", "\\U00000070", "\\U00000071", "\\U00000072", "\\U00000073", "\\U00000074", "\\U00000075", "\\U00000076", "\\U00000077", "\\U00000078", "\\U00000079", "\\U0000007A", "\\U0000007B", "\\U0000007C", "\\U0000007D", "\\U0000007E", "\\U000000A0", "\\U000000A1", "\\U000000A2", "\\U000000A3", "\\U000000A4", "\\U000000A5", "\\U000000A6", "\\U000000A7", "\\U000000A8", "\\U000000A9", "\\U000000AA", "\\U000000AB", "\\U000000AC", "\\U000000AD", "\\U000000AE", "\\U000000AF", "\\U000000B0", "\\U000000B1", "\\U000000B2", "\\U000000B3", "\\U000000B4", "\\U000000B5", "\\U000000B6", "\\U000000B7", "\\U000000B8", "\\U000000B9", "\\U000000BA", "\\U000000BB", "\\U000000BC", "\\U000000BD", "\\U000000BE", "\\U000000BF", "\\U000000C0", "\\U000000C1", "\\U000000C2", "\\U000000C3", "\\U000000C4", "\\U000000C5", "\\U000000C6", "\\U000000C7", "\\U000000C8", "\\U000000C9", "\\U000000CA", "\\U000000CB", "\\U000000CC", "\\U000000CD", "\\U000000CE", "\\U000000CF", "\\U000000D0", "\\U000000D1", "\\U000000D2", "\\U000000D3", "\\U000000D4", "\\U000000D5", "\\U000000D6", "\\U000000D7", "\\U000000D8", "\\U000000D9", "\\U000000DA", "\\U000000DB", "\\U000000DC", "\\U000000DD", "\\U000000DE", "\\U000000DF", "\\U000000E0", "\\U000000E1", "\\U000000E2", "\\U000000E3", "\\U000000E4", "\\U000000E5", "\\U000000E6", "\\U000000E7", "\\U000000E8", "\\U000000E9", "\\U000000EA", "\\U000000EB", "\\U000000EC", "\\U000000ED", "\\U000000EE", "\\U000000EF", "\\U000000F0", "\\U000000F1", "\\U000000F2", "\\U000000F3", "\\U000000F4", "\\U000000F5", "\\U000000F6", "\\U000000F7", "\\U000000F8", "\\U000000F9", "\\U000000FA", "\\U000000FB", "\\U000000FC", "\\U000000FD", "\\U000000FE", "\\U000000FF", "\\U000003BC", "\\U000003A9", "\\U000020AC", "\\U00002122"]
script:
  - id: change_page_to
    parameters:
      target_page: int
    then:
      - lambda: |-
          int pages_count = 2;
          int target = target_page;
          while (target < 0) target += pages_count;
          target %= pages_count;

          // Debounce: Ignore page changes within 3000ms of last change
          // (adjusted for e-paper display update time)
          uint32_t now = millis();
          if (now - id(last_page_switch_time) < 3000) {
            ESP_LOGD("display", "Page change ignored (debounce), last switch was %d ms ago", now - id(last_page_switch_time));
            return;
          }

          if (id(display_page) != target) {
            // Set debounce time BEFORE display update (update takes ~1.6s)
            id(last_page_switch_time) = now;
            id(display_page) = target;
            id(epaper_display).update();
            ESP_LOGI("display", "Switched to page %d", target);
            // Restart refresh logic
            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();
            id(manage_run_and_sleep).execute();
          }

  - id: manage_run_and_sleep
    mode: restart
    then:
      - logger.log: "Waiting for sync..."
      - wait_until:
          condition:
            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'
          timeout: 120s
      - delay: 5s
      - lambda: |-
          int p = id(display_page);
          int interval = id(page_refresh_default_s);
          bool is_sleep_time = false;
          auto time = id(ha_time).now();
          if (time.is_valid()) {
             int hour = time.hour;
             int minute = time.minute;
             int curr_min = hour * 60 + minute;
             int start = 0;
             int end = 0;
             if (start < end) {
                 if (hour >= start && hour < end) is_sleep_time = true;
             } else if (start > end) {
                 if (hour >= start || hour < end) is_sleep_time = true;
             }

             // Visibility Logic: Find best page for current time
             int best_page = -1;
             if (best_page == -1) best_page = 0;
             if (best_page == -1) best_page = 1;

             // If current page is invisible OR another should be shown, switch
             if (best_page != -1 && best_page != p) {
                 ESP_LOGI("display", "Auto-switching to scheduled page %d", best_page);
                 id(change_page_to).execute(best_page);
                 return;
             }
          }
          if (!is_sleep_time) {
          }
          id(page_refresh_current_s) = interval;
      - component.update: epaper_display
      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'
      - script.execute: manage_run_and_sleep
display:
    lambda: |-
      const auto COLOR_WHITE = Color(255, 255, 255);
      const auto COLOR_BLACK = Color(0, 0, 0);
      const auto COLOR_RED = Color(255, 0, 0);
      const auto COLOR_GREEN = Color(0, 255, 0);
      const auto COLOR_BLUE = Color(0, 0, 255);
      const auto COLOR_YELLOW = Color(255, 255, 0);
      const auto COLOR_ORANGE = Color(255, 165, 0);
      auto color_off = COLOR_WHITE;
      auto color_on = COLOR_BLACK;

      // Helper to print text with word-wrap at widget boundary
      auto print_wrapped_text = [&](int x, int y, int max_w, int line_h, esphome::font::Font *font, Color color, TextAlign align, const char* text) {
        if (!text || max_w <= 0) return;
        int cx = x;
        int cy = y;
        std::string line;
        std::string word;
        const char* p = text;
        while (*p) {
          // SANITIZATION: Treat newlines, carriage returns, and tabs as spaces for flow
          bool is_space = (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t');
          if (is_space) {
            if (!word.empty()) {
              int ww, wh, wbl, wx;
              font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
              int lw = 0, lx;
              if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
              if (lw + ww > max_w && !line.empty()) {
                it.print(cx, cy, font, color, align, line.c_str());
                cy += line_h;
                line = word;
              } else {
                if (!line.empty()) line += " ";
                line += word;
              }
              word.clear();
            }
          } else {
            word += *p;
          }
          p++;
        }
        if (!word.empty()) {
          int ww, wh, wbl, wx;
          font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
          int lw = 0, lx;
          if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
          if (lw + ww > max_w && !line.empty()) {
            it.print(cx, cy, font, color, align, line.c_str());
            cy += line_h;
            line = word;
          } else {
            if (!line.empty()) line += " ";
            line += word;
          }
        }
        if (!line.empty()) {
          it.print(cx, cy, font, color, align, line.c_str());
        }
      };

      int currentPage = id(display_page);
      static int last_rendered_page = -1;
      bool page_changed = (last_rendered_page != currentPage);
      if (page_changed) last_rendered_page = currentPage;
      // ═══════════════════════════════════════════════════════════════
      // ▸ PAGE: Home
      // ═══════════════════════════════════════════════════════════════
      if (currentPage == 0) {
        // page:name "Home"
        // page:dark_mode "inherit"
        // page:refresh_type "interval"
        // page:refresh_time ""
        // page:visible_from ""
        // page:visible_to ""
        // Clear screen for this page
        if (page_changed) {
          // Full clear on page change (prevents black artifacts)
          it.filled_rectangle(0, 0, it.get_width(), it.get_height(), COLOR_WHITE);
        } else {
          // Fast clear for same-page updates
          it.fill(COLOR_WHITE);
        }
        color_off = COLOR_WHITE;
        color_on = COLOR_BLACK;
        // widget:text id:txt1 type:text x:0 y:0 w:200 h:40 align:TOP_LEFT text:"Dashboard"
        it.printf(0, 0, id(font_roboto_400_20), Color(theme_auto), TextAlign::TOP_LEFT, "Dashboard");
        // ────────────────────────────────────────
        // widget:icon id:icon1 type:icon x:10 y:50 w:32 h:32 code:F0595 size:48 color:theme_auto
        it.printf(26, 66, id(font_material_design_icons_400_48), color_on, TextAlign::CENTER, "%s", "\\U000F0595");
      }
      // ═══════════════════════════════════════════════════════════════
      // ▸ PAGE: Lights
      // ═══════════════════════════════════════════════════════════════
      if (currentPage == 1) {
        // page:name "Lights"
        // page:dark_mode "inherit"
        // page:refresh_type "interval"
        // page:refresh_time ""
        // page:visible_from ""
        // page:visible_to ""
        // Clear screen for this page
        if (page_changed) {
          // Full clear on page change (prevents black artifacts)
          it.filled_rectangle(0, 0, it.get_width(), it.get_height(), COLOR_WHITE);
        } else {
          // Fast clear for same-page updates
          it.fill(COLOR_WHITE);
        }
        color_off = COLOR_WHITE;
        color_on = COLOR_BLACK;
        // widget:touch_area id:btn1 type:touch_area x:20 y:20 w:100 h:100 icon:"" icon_pressed:"" icon_size:40 icon_color:theme_auto
      }"
`;

exports[`ESPHomeAdapter > End-to-End Golden Master Snapshots > handles dense entity deduplication arrays and attributes 1`] = `
"# ============================================================================
# ESPHome YAML - Generated by ESPHome Designer
# ============================================================================
# TARGET DEVICE: Test Device
#         - Display Platform: Unknown
#         - PSRAM: No
#         - Touchscreen: No
#         - Framework: esp-idf (Recommended)
# ============================================================================
#
# SETUP INSTRUCTIONS:
#
# STEP 1: Copy the Material Design Icons font file
#         - From this repo: resources/fonts/materialdesignicons-webfont.ttf
#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf
#
# STEP 2: Create a new device in ESPHome
#         - Click "New Device"
#         - Select: ESP32-S3 (or appropriate for your board)
#         - Framework: ESP-IDF (Essential for S3 stability)
#
# STEP 3: PASTE this snippet into your device YAML
#         - Paste this snippet at the end of your configuration.
#         - System sections (esphome, esp32, psram) are auto-commented
#           to avoid conflicts with your existing base setup.
#
# CAPTIVE PORTAL:
#         - If WiFi connection fails, the device will create a hotspot.
#         - Search for its name in your WiFi settings.
#         - Connect and go to http://192.168.4.1 to configure WiFi.
#
# TIP: For reTerminal / S3 devices, if you cannot see logs via USB,
#      add this to your base 'logger:' section:
#      hardware_uart: USB_CDC
#
# ============================================================================

# ====================================
# Device Settings
# ====================================
# Orientation: landscape
# Dark Mode: disabled
# Refresh Interval: 600
# Power Strategy: Always On
# Deep Sleep Interval: 600
# ====================================

# esphome:
#   name: your-device-name
#   comment: 'Snippet generated by ESPHome Designer'
#   on_boot:
#     priority: 300
#     then:
#       - delay: 2s
#       - script.execute: manage_run_and_sleep
#
# esp32:
#   board: esp32-s3-devkitc-1
#   framework:
#     type: esp-idf
#     sdkconfig_options:
#       CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: y
#       CONFIG_ESP32S3_DATA_CACHE_64KB: y
#
# logger:
#   hardware_uart: USB_CDC # Enable for USB debugging on S3
#   level: DEBUG
#
# api:
# ota:
# wifi:
#   # ... your wifi config here


globals:
  - id: display_page
    type: int
    restore_value: false
    initial_value: '0'
  - id: page_refresh_default_s
    type: int
    restore_value: true
    initial_value: '60'
  - id: page_refresh_current_s
    type: int
    restore_value: false
    initial_value: '60'
  - id: last_page_switch_time
    type: uint32_t
    restore_value: false
    initial_value: '0'
http_request:
  verify_ssl: false
  timeout: 20s
  buffer_size_rx: 4096
time:
  - platform: homeassistant
    id: ha_time
sensor:
  - platform: homeassistant
    id: sensor_temperature
    entity_id: sensor.temperature
    internal: true
  - platform: homeassistant
    id: sensor_temperature_calibration
    entity_id: sensor.temperature
    attribute: calibration
    internal: true
  - platform: homeassistant
    id: sensor_weather_forecast_0__condition
    entity_id: sensor.weather
    attribute: forecast[0].condition
    internal: true
text_sensor:
  - platform: homeassistant
    id: weather_home_temperature_txt
    entity_id: weather.home
    attribute: temperature
    internal: true
  - platform: homeassistant
    id: sensor_state_txt
    entity_id: sensor.state
    internal: true
binary_sensor:
  - platform: homeassistant
    id: binary_sensor_door
    entity_id: binary_sensor.door
    internal: true
font:
  - file:
      type: gfonts
      family: "Roboto"
      weight: 400
      italic: false
    id: font_roboto_400_14
    size: 14
    glyphs: ["\\U00000020", "\\U00000021", "\\U00000022", "\\U00000023", "\\U00000024", "\\U00000025", "\\U00000026", "\\U00000027", "\\U00000028", "\\U00000029", "\\U0000002A", "\\U0000002B", "\\U0000002C", "\\U0000002D", "\\U0000002E", "\\U0000002F", "\\U00000030", "\\U00000031", "\\U00000032", "\\U00000033", "\\U00000034", "\\U00000035", "\\U00000036", "\\U00000037", "\\U00000038", "\\U00000039", "\\U0000003A", "\\U0000003B", "\\U0000003C", "\\U0000003D", "\\U0000003E", "\\U0000003F", "\\U00000040", "\\U00000041", "\\U00000042", "\\U00000043", "\\U00000044", "\\U00000045", "\\U00000046", "\\U00000047", "\\U00000048", "\\U00000049", "\\U0000004A", "\\U0000004B", "\\U0000004C", "\\U0000004D", "\\U0000004E", "\\U0000004F", "\\U00000050", "\\U00000051", "\\U00000052", "\\U00000053", "\\U00000054", "\\U00000055", "\\U00000056", "\\U00000057", "\\U00000058", "\\U00000059", "\\U0000005A", "\\U0000005B", "\\U0000005C", "\\U0000005D", "\\U0000005E", "\\U0000005F", "\\U00000060", "\\U00000061", "\\U00000062", "\\U00000063", "\\U00000064", "\\U00000065", "\\U00000066", "\\U00000067", "\\U00000068", "\\U00000069", "\\U0000006A", "\\U0000006B", "\\U0000006C", "\\U0000006D", "\\U0000006E", "\\U0000006F", "\\U00000070", "\\U00000071", "\\U00000072", "\\U00000073", "\\U00000074", "\\U00000075", "\\U00000076", "\\U00000077", "\\U00000078", "\\U00000079", "\\U0000007A", "\\U0000007B", "\\U0000007C", "\\U0000007D", "\\U0000007E", "\\U000000A0", "\\U000000A1", "\\U000000A2", "\\U000000A3", "\\U000000A4", "\\U000000A5", "\\U000000A6", "\\U000000A7", "\\U000000A8", "\\U000000A9", "\\U000000AA", "\\U000000AB", "\\U000000AC", "\\U000000AD", "\\U000000AE", "\\U000000AF", "\\U000000B0", "\\U000000B1", "\\U000000B2", "\\U000000B3", "\\U000000B4", "\\U000000B5", "\\U000000B6", "\\U000000B7", "\\U000000B8", "\\U000000B9", "\\U000000BA", "\\U000000BB", "\\U000000BC", "\\U000000BD", "\\U000000BE", "\\U000000BF", "\\U000000C0", "\\U000000C1", "\\U000000C2", "\\U000000C3", "\\U000000C4", "\\U000000C5", "\\U000000C6", "\\U000000C7", "\\U000000C8", "\\U000000C9", "\\U000000CA", "\\U000000CB", "\\U000000CC", "\\U000000CD", "\\U000000CE", "\\U000000CF", "\\U000000D0", "\\U000000D1", "\\U000000D2", "\\U000000D3", "\\U000000D4", "\\U000000D5", "\\U000000D6", "\\U000000D7", "\\U000000D8", "\\U000000D9", "\\U000000DA", "\\U000000DB", "\\U000000DC", "\\U000000DD", "\\U000000DE", "\\U000000DF", "\\U000000E0", "\\U000000E1", "\\U000000E2", "\\U000000E3", "\\U000000E4", "\\U000000E5", "\\U000000E6", "\\U000000E7", "\\U000000E8", "\\U000000E9", "\\U000000EA", "\\U000000EB", "\\U000000EC", "\\U000000ED", "\\U000000EE", "\\U000000EF", "\\U000000F0", "\\U000000F1", "\\U000000F2", "\\U000000F3", "\\U000000F4", "\\U000000F5", "\\U000000F6", "\\U000000F7", "\\U000000F8", "\\U000000F9", "\\U000000FA", "\\U000000FB", "\\U000000FC", "\\U000000FD", "\\U000000FE", "\\U000000FF", "\\U000003BC", "\\U000003A9", "\\U000020AC", "\\U00002122"]
  - file:
      type: gfonts
      family: "Roboto"
      weight: 400
      italic: false
    id: font_roboto_400_20
    size: 20
    glyphs: ["\\U00000020", "\\U00000021", "\\U00000022", "\\U00000023", "\\U00000024", "\\U00000025", "\\U00000026", "\\U00000027", "\\U00000028", "\\U00000029", "\\U0000002A", "\\U0000002B", "\\U0000002C", "\\U0000002D", "\\U0000002E", "\\U0000002F", "\\U00000030", "\\U00000031", "\\U00000032", "\\U00000033", "\\U00000034", "\\U00000035", "\\U00000036", "\\U00000037", "\\U00000038", "\\U00000039", "\\U0000003A", "\\U0000003B", "\\U0000003C", "\\U0000003D", "\\U0000003E", "\\U0000003F", "\\U00000040", "\\U00000041", "\\U00000042", "\\U00000043", "\\U00000044", "\\U00000045", "\\U00000046", "\\U00000047", "\\U00000048", "\\U00000049", "\\U0000004A", "\\U0000004B", "\\U0000004C", "\\U0000004D", "\\U0000004E", "\\U0000004F", "\\U00000050", "\\U00000051", "\\U00000052", "\\U00000053", "\\U00000054", "\\U00000055", "\\U00000056", "\\U00000057", "\\U00000058", "\\U00000059", "\\U0000005A", "\\U0000005B", "\\U0000005C", "\\U0000005D", "\\U0000005E", "\\U0000005F", "\\U00000060", "\\U00000061", "\\U00000062", "\\U00000063", "\\U00000064", "\\U00000065", "\\U00000066", "\\U00000067", "\\U00000068", "\\U00000069", "\\U0000006A", "\\U0000006B", "\\U0000006C", "\\U0000006D", "\\U0000006E", "\\U0000006F", "\\U00000070", "\\U00000071", "\\U00000072", "\\U00000073", "\\U00000074", "\\U00000075", "\\U00000076", "\\U00000077", "\\U00000078", "\\U00000079", "\\U0000007A", "\\U0000007B", "\\U0000007C", "\\U0000007D", "\\U0000007E", "\\U000000A0", "\\U000000A1", "\\U000000A2", "\\U000000A3", "\\U000000A4", "\\U000000A5", "\\U000000A6", "\\U000000A7", "\\U000000A8", "\\U000000A9", "\\U000000AA", "\\U000000AB", "\\U000000AC", "\\U000000AD", "\\U000000AE", "\\U000000AF", "\\U000000B0", "\\U000000B1", "\\U000000B2", "\\U000000B3", "\\U000000B4", "\\U000000B5", "\\U000000B6", "\\U000000B7", "\\U000000B8", "\\U000000B9", "\\U000000BA", "\\U000000BB", "\\U000000BC", "\\U000000BD", "\\U000000BE", "\\U000000BF", "\\U000000C0", "\\U000000C1", "\\U000000C2", "\\U000000C3", "\\U000000C4", "\\U000000C5", "\\U000000C6", "\\U000000C7", "\\U000000C8", "\\U000000C9", "\\U000000CA", "\\U000000CB", "\\U000000CC", "\\U000000CD", "\\U000000CE", "\\U000000CF", "\\U000000D0", "\\U000000D1", "\\U000000D2", "\\U000000D3", "\\U000000D4", "\\U000000D5", "\\U000000D6", "\\U000000D7", "\\U000000D8", "\\U000000D9", "\\U000000DA", "\\U000000DB", "\\U000000DC", "\\U000000DD", "\\U000000DE", "\\U000000DF", "\\U000000E0", "\\U000000E1", "\\U000000E2", "\\U000000E3", "\\U000000E4", "\\U000000E5", "\\U000000E6", "\\U000000E7", "\\U000000E8", "\\U000000E9", "\\U000000EA", "\\U000000EB", "\\U000000EC", "\\U000000ED", "\\U000000EE", "\\U000000EF", "\\U000000F0", "\\U000000F1", "\\U000000F2", "\\U000000F3", "\\U000000F4", "\\U000000F5", "\\U000000F6", "\\U000000F7", "\\U000000F8", "\\U000000F9", "\\U000000FA", "\\U000000FB", "\\U000000FC", "\\U000000FD", "\\U000000FE", "\\U000000FF", "\\U000003BC", "\\U000003A9", "\\U000020AC", "\\U00002122"]
script:
  - id: change_page_to
    parameters:
      target_page: int
    then:
      - lambda: |-
          int pages_count = 1;
          int target = target_page;
          while (target < 0) target += pages_count;
          target %= pages_count;

          // Debounce: Ignore page changes within 3000ms of last change
          // (adjusted for e-paper display update time)
          uint32_t now = millis();
          if (now - id(last_page_switch_time) < 3000) {
            ESP_LOGD("display", "Page change ignored (debounce), last switch was %d ms ago", now - id(last_page_switch_time));
            return;
          }

          if (id(display_page) != target) {
            // Set debounce time BEFORE display update (update takes ~1.6s)
            id(last_page_switch_time) = now;
            id(display_page) = target;
            id(epaper_display).update();
            ESP_LOGI("display", "Switched to page %d", target);
            // Restart refresh logic
            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();
            id(manage_run_and_sleep).execute();
          }

  - id: manage_run_and_sleep
    mode: restart
    then:
      - logger.log: "Waiting for sync..."
      - wait_until:
          condition:
            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'
          timeout: 120s
      - delay: 5s
      - lambda: |-
          int p = id(display_page);
          int interval = id(page_refresh_default_s);
          bool is_sleep_time = false;
          auto time = id(ha_time).now();
          if (time.is_valid()) {
             int hour = time.hour;
             int minute = time.minute;
             int curr_min = hour * 60 + minute;
             int start = 0;
             int end = 0;
             if (start < end) {
                 if (hour >= start && hour < end) is_sleep_time = true;
             } else if (start > end) {
                 if (hour >= start || hour < end) is_sleep_time = true;
             }

             // Visibility Logic: Find best page for current time
             int best_page = -1;
             if (best_page == -1) best_page = 0;

             // If current page is invisible OR another should be shown, switch
             if (best_page != -1 && best_page != p) {
                 ESP_LOGI("display", "Auto-switching to scheduled page %d", best_page);
                 id(change_page_to).execute(best_page);
                 return;
             }
          }
          if (!is_sleep_time) {
          }
          id(page_refresh_current_s) = interval;
      - component.update: epaper_display
      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'
      - script.execute: manage_run_and_sleep
display:
    lambda: |-
      const auto COLOR_WHITE = Color(255, 255, 255);
      const auto COLOR_BLACK = Color(0, 0, 0);
      const auto COLOR_RED = Color(255, 0, 0);
      const auto COLOR_GREEN = Color(0, 255, 0);
      const auto COLOR_BLUE = Color(0, 0, 255);
      const auto COLOR_YELLOW = Color(255, 255, 0);
      const auto COLOR_ORANGE = Color(255, 165, 0);
      auto color_off = COLOR_WHITE;
      auto color_on = COLOR_BLACK;

      // Helper to print text with word-wrap at widget boundary
      auto print_wrapped_text = [&](int x, int y, int max_w, int line_h, esphome::font::Font *font, Color color, TextAlign align, const char* text) {
        if (!text || max_w <= 0) return;
        int cx = x;
        int cy = y;
        std::string line;
        std::string word;
        const char* p = text;
        while (*p) {
          // SANITIZATION: Treat newlines, carriage returns, and tabs as spaces for flow
          bool is_space = (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t');
          if (is_space) {
            if (!word.empty()) {
              int ww, wh, wbl, wx;
              font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
              int lw = 0, lx;
              if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
              if (lw + ww > max_w && !line.empty()) {
                it.print(cx, cy, font, color, align, line.c_str());
                cy += line_h;
                line = word;
              } else {
                if (!line.empty()) line += " ";
                line += word;
              }
              word.clear();
            }
          } else {
            word += *p;
          }
          p++;
        }
        if (!word.empty()) {
          int ww, wh, wbl, wx;
          font->measure(word.c_str(), &ww, &wx, &wbl, &wh);
          int lw = 0, lx;
          if (!line.empty()) { font->measure(line.c_str(), &lw, &lx, &wbl, &wh); int sw, sx, sbl, sh; font->measure(" ", &sw, &sx, &sbl, &sh); lw += sw; }
          if (lw + ww > max_w && !line.empty()) {
            it.print(cx, cy, font, color, align, line.c_str());
            cy += line_h;
            line = word;
          } else {
            if (!line.empty()) line += " ";
            line += word;
          }
        }
        if (!line.empty()) {
          it.print(cx, cy, font, color, align, line.c_str());
        }
      };

      int currentPage = id(display_page);
      static int last_rendered_page = -1;
      bool page_changed = (last_rendered_page != currentPage);
      if (page_changed) last_rendered_page = currentPage;
      // ═══════════════════════════════════════════════════════════════
      // ▸ PAGE: Sensors
      // ═══════════════════════════════════════════════════════════════
      if (currentPage == 0) {
        // page:name "Sensors"
        // page:dark_mode "inherit"
        // page:refresh_type "interval"
        // page:refresh_time ""
        // page:visible_from ""
        // page:visible_to ""
        // Clear screen for this page
        if (page_changed) {
          // Full clear on page change (prevents black artifacts)
          it.filled_rectangle(0, 0, it.get_width(), it.get_height(), COLOR_WHITE);
        } else {
          // Fast clear for same-page updates
          it.fill(COLOR_WHITE);
        }
        color_off = COLOR_WHITE;
        color_on = COLOR_BLACK;
        // widget:sensor_text id:w1 type:sensor_text x:0 y:0 w:50 h:20 align:TOP_LEFT entity:"sensor.temperature" format:"label_value"
        {
          int w1, h1, xoff1, bl1;
          int w2, h2, xoff2, bl2;
          char value_buf[512];
          sprintf(value_buf, "%.2f", id(sensor_temperature).state);
          id(font_roboto_400_14)->measure("temperature: ", &w1, &xoff1, &bl1, &h1);
          id(font_roboto_400_20)->measure(value_buf, &w2, &xoff2, &bl2, &h2);
          // Align baselines: yVal + bl1 = yVal2 + bl2 => yVal2 = yVal + bl1 - bl2
          it.printf(0, 0, id(font_roboto_400_14), Color(theme_auto), TextAlign::TOP_LEFT, "temperature: ");
          it.printf(0 + w1, 0 + (bl1 - bl2), id(font_roboto_400_20), Color(theme_auto), TextAlign::TOP_LEFT, "%s", value_buf);
        }
        // ────────────────────────────────────────
        // widget:sensor_text id:w2 type:sensor_text x:60 y:0 w:50 h:20 align:TOP_LEFT entity:"sensor.temperature" format:"label_value"
        {
          int w1, h1, xoff1, bl1;
          int w2, h2, xoff2, bl2;
          char value_buf[512];
          sprintf(value_buf, "%.2f", id(sensor_temperature_calibration).state);
          id(font_roboto_400_14)->measure("temperature: ", &w1, &xoff1, &bl1, &h1);
          id(font_roboto_400_20)->measure(value_buf, &w2, &xoff2, &bl2, &h2);
          // Align baselines: yVal + bl1 = yVal2 + bl2 => yVal2 = yVal + bl1 - bl2
          it.printf(60, 0, id(font_roboto_400_14), Color(theme_auto), TextAlign::TOP_LEFT, "temperature: ");
          it.printf(60 + w1, 0 + (bl1 - bl2), id(font_roboto_400_20), Color(theme_auto), TextAlign::TOP_LEFT, "%s", value_buf);
        }
        // ────────────────────────────────────────
        // widget:text id:w3 type:text x:0 y:30 w:100 h:30 align:TOP_LEFT text:"Text"
        it.printf(0, 30, id(font_roboto_400_20), Color(theme_auto), TextAlign::TOP_LEFT, "Text");
        // ────────────────────────────────────────
        // widget:icon id:w4 type:icon x:0 y:70 w:40 h:40 code:F0595 size:48 color:theme_auto  cond_ent:"binary_sensor.door" cond_op:"==" cond_inv:"false"
        std::string(id(binary_sensor_door).state) == "0.0"
        it.printf(20, 90, id(font_material_design_icons_400_48), color_on, TextAlign::CENTER, "%s", "\\U000F0595");
        }
        // ────────────────────────────────────────
        // widget:icon id:w5 type:icon x:50 y:70 w:40 h:40 code:F0595 size:48 color:theme_auto  cond_ent:"sensor.state" cond_op:"==" cond_inv:"false"
        std::string(id(sensor_state).state) == "0.0"
        it.printf(70, 90, id(font_material_design_icons_400_48), color_on, TextAlign::CENTER, "%s", "\\U000F0595");
        }
        // ────────────────────────────────────────
        // widget:text id:w6 type:text x:0 y:120 w:150 h:30 align:TOP_LEFT text:"Text"
        it.printf(0, 120, id(font_roboto_400_20), Color(theme_auto), TextAlign::TOP_LEFT, "Text");
      }"
`;
