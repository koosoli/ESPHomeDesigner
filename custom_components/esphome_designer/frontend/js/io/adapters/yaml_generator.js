/**
 * Modular YAML generator for ESPHome.
 * Handles the structural components of the generated configuration.
 */
export class YamlGenerator {
    /**
     * Generates the instruction header with setup guidance.
     * @param {Object} profile 
     * @param {Object} layout 
     * @returns {string[]}
     */
    generateInstructionHeader(profile, layout) {
        const lines = [];
        lines.push("# ============================================================================");
        lines.push("# ESPHome YAML - Generated by ESPHome Designer");
        lines.push("# ============================================================================");
        lines.push(`# TARGET DEVICE: ${profile.name || "Unknown"}`);
        const dims = window.AppState ? window.AppState.getCanvasDimensions() : { width: 800, height: 480 };
        lines.push(`# Resolution: ${dims.width}x${dims.height}`);
        lines.push(`# Shape: ${window.AppState ? window.AppState.getCanvasShape() : "rect"}`);
        lines.push("#");

        // Add brief device specs comment based on profile features
        const feats = profile.features || {};
        const platform = profile.displayPlatform || (feats.lcd ? (profile.id === 'reterminal_e1001' ? 'reterminal_e1001' : 'LCD') : (feats.epaper ? "waveshare_epaper" : "Unknown"));
        lines.push(`#         - Display Platform: ${platform}`);
        lines.push(`#         - PSRAM: ${feats.psram ? 'Yes' : 'No'}`);
        lines.push(`#         - Battery: ${profile.battery ? 'Yes' : 'No'}`);
        lines.push(`#         - Buttons: ${feats.buttons ? 'Yes' : 'No'}`);
        lines.push(`#         - Buzzer: ${feats.buzzer ? 'Yes' : 'No'}`);
        if (feats.audio) lines.push(`#         - Audio: Yes`);
        lines.push("# ============================================================================");
        lines.push("#");
        lines.push("# SETUP INSTRUCTIONS:");
        lines.push("#");
        lines.push("# STEP 1: Copy the Material Design Icons font file");
        lines.push("#         - From this repo: font_ttf/font_ttf/materialdesignicons-webfont.ttf");
        lines.push("#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf");
        lines.push("#         (Create the fonts folder if it doesn't exist)");
        lines.push("#");
        lines.push("# STEP 2: Create a new device in ESPHome");
        lines.push("#         - Click \"New Device\"");
        lines.push("#         - Name: your-device-name");
        lines.push("#         - Select: ESP32-S3 (or appropriate for your board)");
        lines.push("#         - Board: esp32-s3-devkitc-1");
        lines.push("#         - Framework: esp-idf");
        lines.push("#           (TIP: For ESPHome 2025.12+, set version: 5.4.2 to avoid build errors)");
        lines.push("#");
        lines.push("# ============================================================================");
        lines.push("");
        lines.push("# ============================================================================");
        lines.push("# STEP 3: Add the on_boot sequence");
        lines.push("# Paste the following into your 'esphome:' section.");
        lines.push("# (TIP: If compiling fails with 'OOM', add 'compile_process_limit: 1' to 'esphome:')");
        lines.push("# ============================================================================");
        lines.push("# esphome:");
        lines.push("#   on_boot:");
        lines.push("#     priority: 600");
        lines.push("#     then:");
        if (profile.battery && profile.pins && profile.pins.batteryEnable) {
            lines.push("#       - output.turn_on: bsp_battery_enable");
        }
        lines.push("#       - delay: 2s  # Wait for Home Assistant API connection");
        lines.push("#       - script.execute: manage_run_and_sleep");
        if (layout.autoCycleEnabled) {
            lines.push("#       - script.execute: auto_cycle_timer");
        }
        lines.push("#");
        lines.push("");
        lines.push("# ====================================");
        lines.push("# Device Settings");
        lines.push("# ====================================");
        lines.push(`# Orientation: ${layout.orientation || "landscape"}`);
        lines.push(`# Dark Mode: ${layout.darkMode ? "enabled" : "disabled"}`);
        lines.push(`# Refresh Interval: ${layout.refreshInterval || 600}`);
        const isLcd = !!(profile.features && (profile.features.lcd || profile.features.oled));
        let strategy;
        if (isLcd) {
            const lcdStrategy = layout.lcdEcoStrategy || 'backlight_off';
            const map = { always_on: 'Always On', backlight_off: 'Backlight Off Schedule', halt_updates: 'Halt Updates', deep_sleep: 'Deep Sleep' };
            strategy = map[lcdStrategy] || lcdStrategy;
        } else {
            strategy = layout.deepSleepEnabled ? "Ultra Eco (Deep Sleep)" : (layout.sleepEnabled ? "Eco (Light Sleep)" : "Always On");
        }
        lines.push(`# Power Strategy: ${strategy}`);
        lines.push(`# Deep Sleep Interval: ${layout.deepSleepInterval || 600}`);
        lines.push("# ====================================");
        lines.push("");
        return lines;
    }

    /**
     * Generates the script section for page switching and sleep management.
     * @param {Object} payload 
     * @param {Object[]} pages 
     * @param {Object} profile 
     * @returns {string[]}
     */
    generateScriptSection(payload, pages, profile) {
        const lines = [];
        const displayId = profile.features?.lcd ? "my_display" : "epaper_display";
        const autoCycleEnabled = payload.autoCycleEnabled && pages.length > 1;

        lines.push("script:");

        // Change Page Script
        lines.push("  - id: change_page_to");
        lines.push("    parameters:");
        lines.push("      target_page: int");
        lines.push("    then:");
        lines.push("      - lambda: |-");
        lines.push(`          int pages_count = ${pages.length};`);
        lines.push("          int target = target_page;");
        lines.push("          while (target < 0) target += pages_count;");
        lines.push("          target %= pages_count;");
        lines.push("");
        lines.push("          // Debounce: Ignore page changes within 3000ms of last change");
        lines.push("          // (e-paper display update takes ~1.6s, so we need a longer debounce)");
        lines.push("          uint32_t now = millis();");
        lines.push("          if (now - id(last_page_switch_time) < 3000) {");
        lines.push(`            ESP_LOGD("display", "Page change ignored (debounce), last switch was %d ms ago", now - id(last_page_switch_time));`);
        lines.push("            return;");
        lines.push("          }");
        lines.push("");
        lines.push("          if (id(display_page) != target) {");
        lines.push("            // Set debounce time BEFORE display update (update takes ~1.6s)");
        lines.push("            id(last_page_switch_time) = now;");
        lines.push("            id(display_page) = target;");
        lines.push(`            id(${displayId}).update();`);
        lines.push(`            ESP_LOGI("display", "Switched to page %d", target);`);
        lines.push("            // Restart refresh logic");
        lines.push("            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();");
        lines.push("            id(manage_run_and_sleep).execute();");
        lines.push("          }");

        // Manage Run and Sleep
        lines.push("  - id: manage_run_and_sleep", "    mode: restart", "    then:");
        lines.push("      - logger.log: \"Waiting for sync...\"");
        lines.push("      - wait_until:");
        lines.push("          condition:");
        lines.push("            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'");
        lines.push("          timeout: 60s");
        lines.push("      - delay: 5s");
        lines.push("      - lambda: 'id(page_refresh_current_s) = id(page_refresh_default_s);'");
        lines.push(`      - component.update: ${displayId}`);
        lines.push("      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'");
        lines.push("      - script.execute: manage_run_and_sleep");

        // Auto Cycle Timer
        if (autoCycleEnabled) {
            const interval = payload.autoCycleIntervalS || 30;
            lines.push("  - id: auto_cycle_timer", "    mode: restart", "    then:");
            lines.push(`      - delay: ${interval}s`);
            lines.push("      - script.execute:");
            lines.push("          id: change_page_to");
            lines.push("          target_page: !lambda 'return id(display_page) + 1;'");
            lines.push("      - script.execute: auto_cycle_timer");
        }

        return lines;
    }
}
