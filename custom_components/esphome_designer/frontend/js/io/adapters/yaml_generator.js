/**
 * Modular YAML generator for ESPHome.
 * Handles the structural components of the generated configuration.
 */
export class YamlGenerator {
    /**
     * Generates the instruction header with setup guidance.
     * @param {Object} profile 
     * @param {Object} layout 
     * @returns {string[]}
     */
    generateInstructionHeader(profile, layout) {
        const lines = [];
        lines.push("# ============================================================================");
        lines.push("# ESPHome YAML - Generated by ESPHome Designer");
        lines.push("# ============================================================================");
        lines.push(`# TARGET DEVICE: ${profile.name || "Unknown"}`);

        // Add brief device specs comment based on profile features
        const feats = profile.features || {};
        const platform = profile.displayPlatform || (feats.lcd ? (profile.id === 'reterminal_e1001' ? 'reterminal_e1001' : 'LCD') : (feats.epaper ? "waveshare_epaper" : "Unknown"));

        lines.push(`#         - Display Platform: ${platform}`);
        lines.push(`#         - PSRAM: ${feats.psram ? 'Yes' : 'No'}`);
        lines.push(`#         - Touchscreen: ${feats.touch ? (profile.touch?.platform || 'Yes') : 'No'}`);

        let frameworkHint = "esp-idf (Recommended)";
        if (feats.psram && (profile.chip?.includes("s3") || profile.id?.includes("s3"))) {
            frameworkHint = "ESP-IDF (Required for stable PSRAM/LVGL)";
        }
        lines.push(`#         - Framework: ${frameworkHint}`);

        lines.push("# ============================================================================");
        lines.push("#");
        lines.push("# SETUP INSTRUCTIONS:");
        lines.push("#");
        lines.push("# STEP 1: Copy the Material Design Icons font file");
        lines.push("#         - From this repo: resources/fonts/materialdesignicons-webfont.ttf");
        lines.push("#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf");
        lines.push("#");
        lines.push("# STEP 2: Create a new device in ESPHome");
        lines.push("#         - Click \"New Device\"");
        lines.push("#         - Select: ESP32-S3 (or appropriate for your board)");
        lines.push("#         - Framework: ESP-IDF (Essential for S3 stability)");
        lines.push("#");
        lines.push("# STEP 3: MERGE this snippet into your YAML");
        lines.push("#         - Paste this snippet at the end of your configuration.");
        lines.push("#         - System sections (esphome, esp32, wifi, logger) are commented");
        lines.push("#           out to avoid conflicts with your existing base setup.");
        lines.push("#");
        lines.push("# TIP: For reTerminal / S3 devices, if you cannot see logs via USB,");
        lines.push("#      add this to your base 'logger:' section:");
        lines.push("#      hardware_uart: USB_CDC");
        lines.push("#");
        lines.push("# ============================================================================");
        lines.push("");
        lines.push("# ====================================");
        lines.push("# Device Settings");
        lines.push("# ====================================");
        lines.push(`# Orientation: ${layout.orientation || "landscape"}`);
        lines.push(`# Dark Mode: ${layout.darkMode ? "enabled" : "disabled"}`);
        lines.push(`# Refresh Interval: ${layout.refreshInterval || 600}`);
        const isLcd = !!(profile.features && (profile.features.lcd || profile.features.oled));
        let strategy;
        if (isLcd) {
            const lcdStrategy = layout.lcdEcoStrategy || 'backlight_off';
            const map = { always_on: 'Always On', backlight_off: 'Backlight Off Schedule', halt_updates: 'Halt Updates', deep_sleep: 'Deep Sleep' };
            strategy = map[lcdStrategy] || lcdStrategy;
        } else {
            strategy = layout.deepSleepEnabled ? "Ultra Eco (Deep Sleep)" : (layout.sleepEnabled ? "Eco (Light Sleep)" : "Always On");
        }
        lines.push(`# Power Strategy: ${strategy}`);
        lines.push(`# Deep Sleep Interval: ${layout.deepSleepInterval || 600}`);
        lines.push("# ====================================");
        lines.push("");
        return lines;
    }

    /**
     * Generates a template of system sections, commented out.
     * @param {Object} profile 
     * @returns {string[]}
     */
    generateSystemSections(profile, layout) {
        const lines = [];
        const chip = profile.chip || "esp32-s3";
        const board = profile.board || "esp32-s3-devkitc-1";

        lines.push("# esphome:");
        lines.push("#   name: your-device-name");
        lines.push("#   comment: 'Snippet generated by ESPHome Designer'");
        lines.push("#   on_boot:");
        lines.push("#     priority: 600");
        lines.push("#     then:");
        if (profile.battery && profile.pins && profile.pins.batteryEnable) {
            lines.push("#       - output.turn_on: bsp_battery_enable");
        }
        lines.push("#       - delay: 2s");
        lines.push("#       - script.execute: manage_run_and_sleep");
        if (layout.autoCycleEnabled) {
            lines.push("#       - script.execute: auto_cycle_timer");
        }
        lines.push("#");
        lines.push("# esp32:");
        lines.push(`#   board: ${board}`);
        lines.push("#   framework:");
        lines.push("#     type: esp-idf");
        if (chip.includes("s3")) {
            lines.push("#     sdkconfig_options:");
            lines.push("#       CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: y");
            lines.push("#       CONFIG_ESP32S3_DATA_CACHE_64KB: y");
        }
        lines.push("#");
        lines.push("# logger:");
        if (chip.includes("s3")) {
            lines.push("#   hardware_uart: USB_CDC # Enable for USB debugging on S3");
        }
        lines.push("#   level: DEBUG");
        lines.push("#");
        lines.push("# api:");
        lines.push("# ota:");
        lines.push("# wifi:");
        lines.push("#   # ... your wifi config here");
        lines.push("");
        return lines;
    }

    /**
     * Generates the script section for page switching and sleep management.
     * @param {Object} payload 
     * @param {Object[]} pages 
     * @param {Object} profile 
     * @returns {string[]}
     */
    generateScriptSection(payload, pages, profile) {
        const lines = [];
        const displayId = profile.features?.lcd ? "my_display" : "epaper_display";
        const autoCycleEnabled = payload.autoCycleEnabled && pages.length > 1;

        const isLcd = !!(profile.features && (profile.features.lcd || profile.features.oled));
        const debounceMs = isLcd ? 500 : 3000;

        lines.push("script:");

        // Change Page Script
        lines.push("  - id: change_page_to");
        lines.push("    parameters:");
        lines.push("      target_page: int");
        lines.push("    then:");
        lines.push("      - lambda: |-");
        lines.push(`          int pages_count = ${pages.length};`);
        lines.push("          int target = target_page;");
        lines.push("          while (target < 0) target += pages_count;");
        lines.push("          target %= pages_count;");
        lines.push("");
        lines.push(`          // Debounce: Ignore page changes within ${debounceMs}ms of last change`);
        lines.push(`          // (adjusted for ${isLcd ? 'LCD' : 'e-paper'} display update time)`);
        lines.push("          uint32_t now = millis();");
        lines.push(`          if (now - id(last_page_switch_time) < ${debounceMs}) {`);
        lines.push(`            ESP_LOGD("display", "Page change ignored (debounce), last switch was %d ms ago", now - id(last_page_switch_time));`);
        lines.push("            return;");
        lines.push("          }");
        lines.push("");
        lines.push("          if (id(display_page) != target) {");
        lines.push("            // Set debounce time BEFORE display update (update takes ~1.6s)");
        lines.push("            id(last_page_switch_time) = now;");
        lines.push("            id(display_page) = target;");
        lines.push(`            id(${displayId}).update();`);
        lines.push(`            ESP_LOGI("display", "Switched to page %d", target);`);
        lines.push("            // Restart refresh logic");
        lines.push("            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();");
        lines.push("            id(manage_run_and_sleep).execute();");
        lines.push("          }");

        // Manage Run and Sleep
        lines.push("  - id: manage_run_and_sleep", "    mode: restart", "    then:");
        lines.push("      - logger.log: \"Waiting for sync...\"");
        lines.push("      - wait_until:");
        lines.push("          condition:");
        lines.push("            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'");
        lines.push("          timeout: 60s");
        lines.push("      - delay: 5s");
        lines.push("      - lambda: 'id(page_refresh_current_s) = id(page_refresh_default_s);'");
        lines.push(`      - component.update: ${displayId}`);
        lines.push("      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'");
        lines.push("      - script.execute: manage_run_and_sleep");

        // Auto Cycle Timer
        if (autoCycleEnabled) {
            const interval = payload.autoCycleIntervalS || 30;
            lines.push("  - id: auto_cycle_timer", "    mode: restart", "    then:");
            lines.push(`      - delay: ${interval}s`);
            lines.push("      - script.execute:");
            lines.push("          id: change_page_to");
            lines.push("          target_page: !lambda 'return id(display_page) + 1;'");
            lines.push("      - script.execute: auto_cycle_timer");
        }

        return lines;
    }
}
