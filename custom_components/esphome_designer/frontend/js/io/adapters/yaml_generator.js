/**
 * Modular YAML generator for ESPHome.
 * Handles the structural components of the generated configuration.
 */
export class YamlGenerator {
    /**
     * Generates the instruction header with setup guidance.
     * @param {Object} profile 
     * @param {Object} layout 
     * @returns {string[]}
     */
    generateInstructionHeader(profile, layout) {
        const lines = [];
        lines.push("# ============================================================================");
        lines.push("# ESPHome YAML - Generated by ESPHome Designer");
        lines.push("# ============================================================================");
        lines.push(`# TARGET DEVICE: ${profile.name || "Unknown"}`);
        const dims = window.AppState ? window.AppState.getCanvasDimensions() : { width: 800, height: 480 };
        lines.push(`# Resolution: ${dims.width}x${dims.height}`);
        lines.push(`# Shape: ${window.AppState ? window.AppState.getCanvasShape() : "rect"}`);
        lines.push("#");

        // Add brief device specs comment based on profile features
        const feats = profile.features || {};
        const platform = profile.displayPlatform || (feats.lcd ? "LCD" : (feats.epaper ? "e-paper" : "Unknown"));
        lines.push(`#         - Display Platform: ${platform}`);
        lines.push(`#         - PSRAM: ${feats.psram ? 'Yes' : 'No'}`);
        lines.push(`#         - Battery: ${profile.battery ? 'Yes' : 'No'}`);
        lines.push(`#         - Buttons: ${feats.buttons ? 'Yes' : 'No'}`);
        lines.push(`#         - Buzzer: ${feats.buzzer ? 'Yes' : 'No'}`);
        if (feats.audio) lines.push(`#         - Audio: Yes`);

        lines.push("# ============================================================================");
        lines.push("#");
        lines.push("# SETUP INSTRUCTIONS:");
        lines.push("#");
        lines.push("# STEP 1: Copy the Material Design Icons font file");
        lines.push("#         - From this repo: font_ttf/font_ttf/materialdesignicons-webfont.ttf");
        lines.push("#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf");
        lines.push("#         (Create the fonts folder if it doesn't exist)");
        lines.push("#");
        lines.push("# STEP 2: Create a new device in ESPHome");
        lines.push("#         - Click \"New Device\"");
        lines.push("#         - Name: your-device-name");

        const deviceModel = profile.id || "unknown";
        if (deviceModel === "m5stack_coreink") {
            lines.push("#         - Select: ESP32 (do NOT use S3!)");
            lines.push("#         - Board: m5stack-coreink");
            lines.push("#         - Framework: esp-idf (Recommended) or arduino");
        } else if (deviceModel === "m5stack_paper") {
            lines.push("#         - Select: ESP32 (do NOT use S3!)");
            lines.push("#         - Board: m5stack-paper");
            lines.push("#         - Framework: arduino (Required)");
            lines.push("#         - Flash Size: 16MB");
            lines.push("#         (TIP: If you see strapping pin warnings, you can add 'ignore_strapping_warning: true' to 'esphome:')");
        } else if (deviceModel === "trmnl") {
            lines.push("#         - Select: ESP32-S3");
            lines.push("#         - Board: esp32-s3-devkitc-1");
            lines.push("#         - Framework: esp-idf (Recommended) or arduino");
        } else {
            lines.push("#         - Select: ESP32-S3 (or appropriate for your board)");
        }

        lines.push("#");
        lines.push("# ============================================================================");
        lines.push("");
        return lines;
    }

    /**
     * Generates the script section for page switching and sleep management.
     * @param {Object} payload 
     * @param {Object[]} pages 
     * @param {Object} profile 
     * @returns {string[]}
     */
    generateScriptSection(payload, pages, profile) {
        const lines = [];
        const displayId = profile.features?.lcd ? "my_display" : "epaper_display";
        const autoCycleEnabled = payload.auto_cycle_enabled && pages.length > 1;

        lines.push("script:");

        // Change Page Script
        lines.push("  - id: change_page_to");
        lines.push("    parameters:");
        lines.push("      target_page: int");
        lines.push("    then:");
        lines.push("      - lambda: |-");
        lines.push(`          int pages_count = ${pages.length};`);
        lines.push("          int target = target_page;");
        lines.push("          while (target < 0) target += pages_count;");
        lines.push("          target %= pages_count;");
        lines.push("          if (id(display_page) != target) {");
        lines.push("            id(display_page) = target;");
        lines.push("            id(last_page_switch_time) = millis();");
        lines.push(`            id(${displayId}).update();`);
        lines.push(`            ESP_LOGI("display", "Switched to page %d", target);`);
        lines.push("            // Restart refresh logic");
        lines.push("            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();");
        lines.push("            id(manage_run_and_sleep).execute();");
        lines.push("          }");

        // Manage Run and Sleep
        lines.push("  - id: manage_run_and_sleep", "    mode: restart", "    then:");
        lines.push("      - logger.log: \"Waiting for sync...\"");
        lines.push("      - wait_until:");
        lines.push("          condition:");
        lines.push("            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'");
        lines.push("          timeout: 60s");
        lines.push("      - delay: 5s");
        lines.push("      - lambda: 'id(page_refresh_current_s) = id(page_refresh_default_s);'");
        lines.push(`      - component.update: ${displayId}`);
        lines.push("      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'");
        lines.push("      - script.execute: manage_run_and_sleep");

        // Auto Cycle Timer
        if (autoCycleEnabled) {
            const interval = payload.auto_cycle_interval_s || 30;
            lines.push("  - id: auto_cycle_timer", "    mode: restart", "    then:");
            lines.push(`      - delay: ${interval}s`);
            lines.push("      - script.execute:");
            lines.push("          id: change_page_to");
            lines.push("          target_page: !lambda 'return id(display_page) + 1;'");
            lines.push("      - script.execute: auto_cycle_timer");
        }

        return lines;
    }
}
