"""
YAML snippet generator for the reTerminal Dashboard Designer integration.

This module takes the internal layout model (DeviceConfig / PageConfig / WidgetConfig)
and produces ESPHome-compatible YAML snippets that the user can paste BELOW an
existing base ESPHome config.

Key principles:
- We DO NOT emit:
  - esphome:
  - esp32:
  - wifi:
  - api:
  - ota:
  - logger:
- We ONLY emit additive blocks:
  - globals, fonts, outputs, rtttl, sensors, text_sensors, scripts, display, etc.
- We target the reTerminal E1001 epaper (800x480) as the initial device.

The output is a single YAML snippet string containing:
- Header comments explaining how to use it.
- Behavior/config blocks (buttons, scripts, etc).
- Layout block(s) mapping configured pages/widgets to display lambda code.

NOTE: This is an MVP generator:
- Focus on safe, deterministic output.
- Supports a conservative subset of widget types.
- Uses IDs and structures inspired by the working reference in:
  resources/ESPHome Reterminal/reterminalE-1001-esphome.txt
"""

from __future__ import annotations

from typing import List

from .models import DeviceConfig, PageConfig, WidgetConfig
from .const import IMAGE_WIDTH, IMAGE_HEIGHT


SNIPPET_HEADER = """# ============================================================
# Generated by reTerminal Dashboard Designer
# Target device: reTerminal E1001 (800x480 epaper)
#
# Usage:
# 1. Ensure you already have a working base ESPHome config for your device:
#    - Includes: esphome, esp32, wifi, api, ota, logger
#    - Uses the correct board for the reTerminal E1001
# 2. Paste this snippet BELOW your existing base config.
# 3. Do NOT duplicate esphome:, wifi:, api:, ota:, logger: sections.
# 4. If you already define conflicting ids (e.g. epaper_display), adjust accordingly.
#
# WARNING:
# - This is an MVP generator. Review the result before flashing.
# - Keep this snippet under version control to track your layout changes.
# ============================================================
"""


def generate_snippet(device: DeviceConfig) -> str:
    """
    Generate a complete YAML snippet for the given device configuration.

    The snippet includes:
    - Required globals/fonts/outputs/rtttl/buttons/sensors/scripts for navigation.
    - A display: epaper_display block with lambda that renders all pages/widgets.

    This function assumes:
    - Single device_type: reTerminal E1001.
    - IMAGE_WIDTH/IMAGE_HEIGHT match the target display (800x480).
    """
    device.ensure_pages()

    parts: List[str] = [SNIPPET_HEADER.rstrip(), ""]

    # Core pieces (ordered for readability)
    parts.append(_generate_globals())
    parts.append(_generate_fonts())
    parts.append(_generate_outputs_and_buzzer())
    parts.append(_generate_sensors_and_text_sensors(device))
    parts.append(_generate_navigation_buttons(device))
    parts.append(_generate_scripts(device))
    parts.append(_generate_display_block(device))

    # Join with double newlines between major sections
    return "\n\n".join(p for p in parts if p.strip())


def _generate_globals() -> str:
    return """globals:
  # Current page index (0-based)
  - id: display_page
    type: int
    restore_value: true
    initial_value: '0'

  # Battery icon glyph (optional usage in display lambda)
  - id: battery_glyph
    type: std::string
    restore_value: no
    initial_value: "\\U000F0079"

  # Default page refresh interval (seconds)
  - id: page_refresh_default_s
    type: int
    restore_value: no
    initial_value: '900'
"""


def _generate_fonts() -> str:
    # Minimal conservative font set; must align with widget logic in editor.
    return """font:
  - file: "gfonts://Inter@400"
    id: font_small
    size: 18

  - file: "gfonts://Inter@500"
    id: font_normal
    size: 22

  - file: "gfonts://Inter@700"
    id: font_bold
    size: 26
"""


def _generate_outputs_and_buzzer() -> str:
    # Based on reference: battery enable + buzzer LEDC
    return """output:
  - platform: gpio
    pin: GPIO21
    id: bsp_battery_enable

  - platform: ledc
    pin: GPIO45
    id: buzzer_output

rtttl:
  id: reterminal_buzzer
  output: buzzer_output
"""


def _generate_sensors_and_text_sensors(device: DeviceConfig) -> str:
    """
    Generate sensor and text_sensor blocks including HomeAssistant platform entries
    for all sensor_text widgets found in the device's pages.
    """
    # Collect all unique entity_ids from sensor_text widgets
    entity_ids = set()
    for page in device.pages:
        for widget in page.widgets:
            wtype = (widget.type or "").lower()
            if wtype in ("sensor", "sensor_text"):
                entity_id = (widget.entity_id or "").strip()
                if entity_id:
                    entity_ids.add(entity_id)
    
    # Build text_sensor entries for each unique entity
    text_sensor_entries = []
    for entity_id in sorted(entity_ids):
        # Create a safe ID from entity_id (replace dots with underscores)
        safe_id = entity_id.replace(".", "_").replace("-", "_")
        text_sensor_entries.append(f"""  - platform: homeassistant
    id: {safe_id}
    entity_id: {entity_id}
    internal: true""")
    
    text_sensors_block = "\n".join(text_sensor_entries) if text_sensor_entries else """  # No sensor_text widgets configured yet.
  # Add widgets in the editor to auto-generate HomeAssistant text_sensor entries."""
    
    return f"""sensor:
  # Example onboard / derived sensors; adjust entity_ids or wiring as needed.
  # Battery voltage (ADC)
  - platform: adc
    pin: GPIO1
    name: "reTerminal Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    filters:
      - multiply: 2.0

  - platform: template
    name: "reTerminal Battery Level"
    id: battery_level
    lambda: 'return id(battery_voltage).state;'
    unit_of_measurement: "%"
    device_class: battery
    update_interval: 60s
    filters:
      - calibrate_linear:
          - 3.27 -> 0.0
          - 4.15 -> 100.0
      - clamp:
          min_value: 0
          max_value: 100

  # WiFi signal as an example
  - platform: wifi_signal
    name: "reTerminal WiFi Signal"
    id: wifi_rssi
    update_interval: 60s

text_sensor:
{text_sensors_block}
"""


def _generate_navigation_buttons(device: DeviceConfig) -> str:
    # Template buttons for navigation and refresh.
    # These operate on display_page and let HA/ESPHome automations drive page changes.
    return """button:
  - platform: template
    name: "reTerminal Next Page"
    id: reterminal_next_page
    on_press:
      - lambda: |-
          int pages = {pages};
          id(display_page) = (id(display_page) + 1) % pages;

  - platform: template
    name: "reTerminal Previous Page"
    id: reterminal_prev_page
    on_press:
      - lambda: |-
          int pages = {pages};
          id(display_page) = (id(display_page) - 1 + pages) % pages;

  - platform: template
    name: "reTerminal Refresh Display"
    id: reterminal_refresh_display
    on_press:
      - component.update: epaper_display
""".format(
        pages=len(device.pages)
    )


def _generate_scripts(device: DeviceConfig) -> str:
    """
    Generate time + manage_run_and_sleep script with per-page refresh support.

    Semantics:
    - A global default interval (page_refresh_default_s).
    - Inline switch(page) using PageConfig.refresh_s values when provided.
    - Enforce a minimum of 60 seconds for any effective interval.
    """
    case_lines: List[str] = []
    for idx, page in enumerate(device.pages):
        refresh = getattr(page, "refresh_s", None)
        if refresh is None:
            continue
        try:
            val = int(refresh)
        except (TypeError, ValueError):
            continue
        if val >= 60:
            case_lines.append(f"                  case {idx}: interval = {val}; break;")

    if case_lines:
        cases_block = "\n".join(case_lines)
    else:
        cases_block = "                  default:\n                    break;"

    return f"""time:
  - platform: homeassistant
    id: ha_time

script:
  - id: manage_run_and_sleep
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(ha_time).now().is_valid();'
          then:
            - lambda: |-
                int page = id(display_page);
                int interval = id(page_refresh_default_s);
                switch (page) {{
{cases_block}
                }}
                if (interval < 60) {{
                  interval = 60;
                }}
                ESP_LOGI("refresh", "Next refresh in %d seconds for page %d", interval, page);
            - delay: !lambda 'return std::chrono::seconds(interval);'
            - component.update: epaper_display
            - script.execute: manage_run_and_sleep
          else:
            - delay: 300s
            - component.update: epaper_display
            - script.execute: manage_run_and_sleep
"""


def _generate_display_block(device: DeviceConfig) -> str:
    """
    Generate the display: epaper_display block with a lambda that:
    - Reads current display_page.
    - Draws widgets belonging to the active page.
    - Uses DeviceConfig.orientation to pick rotation:
        - landscape -> rotation: 0
        - portrait  -> rotation: 90
    - DeviceConfig.dark_mode is advisory; widget-level color/invert decide actual draws.
    """
    lines: List[str] = []

    orientation = getattr(device, "orientation", "landscape")
    if orientation == "portrait":
        rotation = 90
    else:
        rotation = 0

    lines.append("display:")
    lines.append("  - platform: waveshare_epaper")
    lines.append("    id: epaper_display")
    lines.append("    # Ensure these pins and model match your hardware/base config")
    lines.append("    cs_pin: GPIO10")
    lines.append("    busy_pin: GPIO3")
    lines.append("    reset_pin: GPIO8")
    lines.append("    dc_pin: GPIO4")
    lines.append("    model: 7.50in-bV3")
    lines.append("    update_interval: 0s")
    lines.append(f"    rotation: {rotation}")
    lines.append("    lambda: |-")
    lines.append("      int page = id(display_page);")

    for page_index, page in enumerate(device.pages):
        _append_page_render(lines, page_index, page)

    return "\n".join(lines)


def _append_page_render(dst: List[str], page_index: int, page: PageConfig) -> None:
    indent = "      "
    dst.append(f'{indent}if (page == {page_index}) {{')
    if not page.widgets:
        dst.append(f"{indent}  // Page {page_index}: no widgets configured.")
    else:
        for widget in page.widgets:
            _append_widget_render(dst, indent + "  ", widget)
    dst.append(f"{indent}}}")


def _resolve_font(props: dict) -> str:
    """Pick a font id based on optional font_size hint in widget props."""
    try:
        size = int(props.get("font_size", 0))
    except (TypeError, ValueError):
        size = 0

    if size <= 0:
        return "id(font_normal)"
    if size < 20:
        return "id(font_small)"
    if size < 26:
        return "id(font_normal)"
    return "id(font_bold)"


def _resolve_font_by_size(size: int) -> str:
    """Pick a font id based on explicit font size value."""
    if size < 20:
        return "id(font_small)"
    if size < 26:
        return "id(font_normal)"
    return "id(font_bold)"


def _append_widget_render(dst: List[str], indent: str, widget: WidgetConfig) -> None:
    """Render a single widget into display lambda C++ code.

    Unified styling semantics:
    - type: "text" / "label"
    - type: "sensor" / "sensor_text"
    - type: "shape_rect"
    - type: "shape_circle"
    - type: "line"
    - type: "image"
    - type: "history"
    """
    # Clamp to canvas
    x = max(0, min(widget.x, IMAGE_WIDTH))
    y = max(0, min(widget.y, IMAGE_HEIGHT))
    w = max(1, min(widget.width, IMAGE_WIDTH - x))
    h = max(1, min(widget.height, IMAGE_HEIGHT - y))

    wtype = (widget.type or "text").lower()
    props = widget.props or {}

    # Determine base color polarity from props.color and invert.
    base_color = (props.get("color") or "").lower()
    if base_color == "white":
        fg = "COLOR_ON"
    elif base_color == "gray":
        # For grayscale we still use COLOR_ON on b/w display; left for future patterns.
        fg = "COLOR_ON"
    else:
        # Default to "dark ink" style
        fg = "COLOR_OFF"

    if props.get("invert"):
        fg = "COLOR_OFF" if fg == "COLOR_ON" else "COLOR_ON"

    # Floating text (no box)
    if wtype in ("label", "text"):
        text = (props.get("text") or widget.title or "").replace('"', '\\"')
        if not text:
            return
        font = _resolve_font(props)
        # Add marker comment for parser
        dst.append(f'{indent}// widget:text id:{widget.id} type:text x:{x} y:{y} w:{w} h:{h} text:"{text}"')
        dst.append(f'{indent}it.print({x}, {y}, {font}, {fg}, "{text}");')
        return

    # Icon widget (MDI icon from font)
    if wtype == "icon":
        code = (props.get("code") or "F0595").strip().upper()
        # Validate code format (Fxxx)
        if not code.startswith("F") or len(code) != 5:
            code = "F0595"  # Default to weather-cloudy
        # Convert to unicode codepoint
        try:
            hex_val = int(code[1:], 16)
            codepoint = 0xF0000 + hex_val
            icon_char = chr(codepoint)
        except (ValueError, OverflowError):
            icon_char = chr(0xF0595)  # Fallback
        
        font_ref = props.get("font_ref", "font_mdi_medium")
        # Escape special characters
        escaped_char = icon_char.replace("\\", "\\\\").replace('"', '\\"')
        # Add marker comment for parser
        dst.append(f'{indent}// widget:icon id:{widget.id} type:icon x:{x} y:{y} w:{w} h:{h} code:{code}')
        dst.append(f'{indent}it.print({x}, {y}, id({font_ref}), {fg}, "{escaped_char}");')
        return

    # Sensor text (label + value from HA sensor)
    if wtype in ("sensor", "sensor_text"):
        entity_id = (widget.entity_id or "").strip()
        label = (widget.title or "").replace('"', '\\"')
        value_format = props.get("value_format", "label_value")
        label_font_size = int(props.get("label_font_size", 14) or 14)
        value_font_size = int(props.get("value_font_size", 20) or 20)
        
        if entity_id:
            # Generate safe ID from entity_id
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            
            # Add marker comment for parser
            dst.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} ent:{entity_id} title:"{label}"')
            
            if value_format == "label_newline_value" and label:
                # Label on one line, value on another - use separate fonts
                label_font = _resolve_font_by_size(label_font_size)
                value_font = _resolve_font_by_size(value_font_size)
                # Print label
                dst.append(f'{indent}it.printf({x}, {y}, {label_font}, {fg}, "{label}");')
                # Print value below label (approximate line height)
                value_y = y + label_font_size + 4
                dst.append(f'{indent}it.printf({x}, {value_y}, {value_font}, {fg}, "%s", id({safe_id}).state.c_str());')
            elif value_format == "label_value" and label:
                # Inline format: "Label: Value" - use average size or value size
                font = _resolve_font_by_size(value_font_size)
                dst.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "{label}: %s", id({safe_id}).state.c_str());')
            else:
                # value_only or no label - just show value
                font = _resolve_font_by_size(value_font_size)
                dst.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "%s", id({safe_id}).state.c_str());')
        else:
            # No entity_id configured - show placeholder
            placeholder = label or "sensor"
            font = _resolve_font_by_size(value_font_size)
            # Add marker comment for parser
            dst.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} title:"{label}"')
            dst.append(f'{indent}// No entity_id configured for this sensor_text widget')
            dst.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "{placeholder}: N/A");')
        return

    # Rectangle / filled rectangle
    if wtype == "shape_rect":
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        opacity = int(props.get("opacity", 100) or 100)
        if fill:
            # For now opacity is advisory; could be mapped to patterns in future.
            dst.append(f"{indent}it.filled_rectangle({x}, {y}, {w}, {h}, {fg});")
            if border_width > 1:
                dst.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
        else:
            if border_width <= 1:
                dst.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
            else:
                # Approximate thicker border using multiple rectangles.
                dst.append(f"{indent}// rectangle with border_width={border_width}")
                dst.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                dst.append(
                    f"{indent}  it.rectangle({x}+i, {y}+i, {w}-2*i, {h}-2*i, {fg});"
                )
                dst.append(f"{indent}}}")
        return

    # Circle / filled circle (use width/height box)
    if wtype == "shape_circle":
        r = max(1, min(w, h) // 2)
        cx = x + w // 2
        cy = y + h // 2
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        if fill:
            dst.append(f"{indent}it.filled_circle({cx}, {cy}, {r}, {fg});")
            if border_width > 1:
                dst.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
        else:
            if border_width <= 1:
                dst.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
            else:
                dst.append(f"{indent}// circle with border_width={border_width}")
                dst.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                dst.append(f"{indent}  it.circle({cx}, {cy}, {r}-i, {fg});")
                dst.append(f"{indent}}}")
        return

    # Line: from (x,y) to (x+width,y+height) using width/height as dx/dy
    if wtype == "line":
        dx = w
        dy = h
        x2 = max(0, min(x + dx, IMAGE_WIDTH))
        y2 = max(0, min(y + dy, IMAGE_HEIGHT))
        stroke_width = int(props.get("stroke_width", 1) or 1)
        if stroke_width <= 1:
            dst.append(f"{indent}it.line({x}, {y}, {x2}, {y2}, {fg});")
        else:
            dst.append(f"{indent}// line with stroke_width={stroke_width}")
            dst.append(f"{indent}for (int i = 0; i < {stroke_width}; i++) {{")
            dst.append(f"{indent}  it.line({x}, {y}+i, {x2}, {y2}+i, {fg});")
            dst.append(f"{indent}}}")
        return

    # Static image widget: expects props.image_id to match an ESPHome image id
    if wtype == "image":
        image_id = (props.get("image_id") or "").strip()
        if image_id:
            dst.append(f"{indent}it.image({x}, {y}, id({image_id}));")
        else:
            dst.append(f"{indent}// image widget missing image_id at ({x},{y})")
        return

    # History widget: placeholder visualization; requires precomputed entity
    if wtype == "history":
        entity_id = (props.get("entity_id") or widget.entity_id or "").replace('"', '\\"')
        style = (props.get("style") or "bars").lower()
        label = entity_id or "history"
        font = _resolve_font(props)
        dst.append(f"{indent}// history widget for {entity_id}; expects external aggregation")
        dst.append(f'{indent}it.print({x}, {y}, {font}, {fg}, "{label}");')
        # Simple placeholder box/lines
        hx = x
        hy = y + 14
        hw = max(10, w)
        hh = max(6, h - 16)
        dst.append(f"{indent}it.rectangle({hx}, {hy}, {hw}, {hh}, {fg});")
        if style == "line":
            dst.append(f"{indent}it.line({hx+2}, {hy+hh-3}, {hx+hw-2}, {hy+3}, {fg});")
        else:
            dst.append(f"{indent}// draw simple bar-style segments as placeholder")
        return

    # Unknown type: emit comment for safety
    dst.append(f'{indent}// TODO: unsupported widget type "{widget.type}" at ({x},{y})')
    if wtype == "image":
        image_id = props.get("image_id")
        if image_id:
            dst.append(f"{indent}it.image({x}, {y}, id({image_id}));")
        else:
            dst.append(f"{indent}// image widget without image_id; nothing drawn")
        return

    # History graph widget (placeholder: renders a labeled box)
    if wtype == "history":
        title = (widget.title or "history").replace('"', '\\"')
        font = _resolve_font(props)
        dst.append(f"{indent}// History widget placeholder for {title}")
        dst.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
        dst.append(f"{indent}it.print({x}+2, {y}+2, {font}, {fg}, \"{title}\");")
        return

    # Fallback
    dst.append(f'{indent}// Unsupported widget type "{widget.type}" at ({x},{y},{w},{h})')